sid,computing_id,cid,pid,submission,judge_output,status,language,submitted_at,score
2,student2,1001,1001,asdfasdf,,judging,cpp,2022-07-28 12:15:26.509667,0
18,student2,1,1006,"#include <stdio.h>
int main(){
	int a;
	scanf(""%d"",&a);
	auto s = [](int x){for(int i=0;i<x;++i) printf("" "");};
	s(a-1); printf("".\n"");
	for(int i=1;i<a;++i){
		s(a-i-1);
		printf(""/"");
		for(int j=1;j<2*i;++j)
			printf(""%c"",'@'+(j<=i?j:2*i-j));
		printf(""\\\n"");
	}
}","",AC,C++17,2022-07-29 23:22:33.410718,50
19,student2,1,1004,"const { createInterface } = require('readline');
const rl = createInterface({
    input: process.stdin,
    output: null
});

rl.question('', n => {
    rl.question('', nums => {
        var sum = 0;
        nums.split(' ').forEach(e => {sum += parseInt(e);});
        console.log(sum);
        rl.close();
    });
});","",AC,NodeJS,2022-07-29 23:23:18.328147,100
15,student2,1001,1003,"#include <iostream>

int main(){
	int n;
	std::cin >> n;
	long long sum = 0, tmp = 0;
	for(int i=0; i<n; ++i){
		std::cin >> tmp;
		sum += tmp;
	}
	std::cout << sum << std::endl;
}",Problem not found,IERR,C++17,2022-07-28 17:59:47.447599,0
20,student2,1,1007,"#include <bits/stdc++.h>
using namespace std;
// incomplete
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef complex<double> cd;

int main() {
	int n, q, a, b;
    char s[12];
    char c;
    
    scanf(""%d%d"", &n, &q);
    
    vector<string> VS(n+7, ""white"");

    while(q--){
        scanf("" %c"", &c);
        if (c == 'q') {
            scanf(""%d"", &a);
            string ans = VS[a];
            printf(""%s\n"",ans.c_str());
        } else {
            scanf(""%d%d %s"", &a, &b, s);
            string S(s);
            rep(i,a,b+1){
                VS[i] = S;
            }
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-29 23:23:48.490677,40
16,student2,1,1004,"n = input()
print(sum(list(map(int, input().split()))))","",AC,Python3,2022-07-29 22:39:02.400711,100
17,student2,1,1005,"#include <bits/stdc++.h>
using namespace std;
// incomplete
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef complex<double> cd;

int n, m;
int N;
vi a;
vector<pii> batch;
// FRONT OF ARROW, BACK OF ARROW
void make_batch(int rep, int step){
	batch.clear();
	int n_to_flip = 1 << (rep);
	int skip = 1 << (step);
	int dir = 0;
	int i = 0;
	int n = 0;
	int k = 0;
	while(i != N){
		if (dir) {
			batch.push_back({i, i+skip});
		} else {
			batch.push_back({i+skip, i});
		}
		i++;
		n++;
		k++;
		if (n == n_to_flip) {
			dir = !dir;
			n = 0;
		}
		if (k == skip) {
			i += skip;
			k = 0;
		}
	}
}
bool set_batch(){
	int k = 0;
	for(auto [i, j] : batch){
		if (a[i] < n && a[j] < n) k++;
	}
	cout << ""q "" << k << endl;
	for(auto [i, j] : batch){
		if (a[i] < n && a[j] < n) {
			cout << a[i] << "" < "" << a[j] << endl;
		}
	}
	vi res(k);
	cin >> res[0];
	if (res[0] == -1) {
		return 0;
	}
	rep(i,1,k) cin >> res[i];
	int p = 0;
	for(auto [i, j] : batch){
		int r;
		if (a[i] < n && a[j] < n) {
			r = res[p++];
		} else if (a[i] >= n && a[j] < n){
			r = 0;
		} else if (a[i] < n && a[j] >= n){
			r = 1;
		} else {
			r = a[i] < a[j];
		}
		if (r) {
			swap(a[i], a[j]);
		}
	}
	return 1;
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	// int n, m;
	cin >> n >> m;
	N = 1;
	int reps = 0;
	while(N < n){
		N <<= 1;
		reps++;
	}
	a.resize(N, 0);
	iota(all(a), 0);
	rep(i,0,reps){
		for(int j=i; j>=0; --j){
			make_batch(i, j);
			if (!set_batch()) {
				return 0;
			}
		}
	}
	cout << ""a"";
	rep(i,0,n) cout << "" "" << a[i];
	cout << endl;

}","",AC,C++17,2022-07-29 22:41:13.512751,100
21,student2,1,1008,asdf,Only your latest submission will be checked,AC,Python3,2022-07-29 23:26:44.55219,10
22,student2,1,1009,"#include <cstdio>
#include <map>
#include <string>
using namespace std;

map<int, string> M;

string q_at(int x){
    auto it = M.upper_bound(x);
    it--;
    return it->second;
}

int main(){
    int n, q, a, b;
    char s[12];
    char c;
    map<int, string>::iterator it, rm_start, rm_end;
    scanf(""%d%d"", &n, &q);
    M[-1]=""white"";
    while(q--){
        scanf("" %c"", &c);
        if (c == 'q') {
            scanf(""%d"", &a);
            it = M.upper_bound(a);
            it--;
            printf(""%s\n"",it->second.c_str());
        } else {
            scanf(""%d%d %s"", &a, &b, s);
            string S(s);
            
            string col_after = q_at(b+1);
            rm_start = M.lower_bound(a);
            rm_end = M.upper_bound(b);

            M.erase(rm_start, rm_end);
            M[a] = S;
            M[b+1] = col_after;
        }
    }
}",Only your latest submission will be checked,AC,C++17,2022-07-29 23:27:05.028664,10
23,student1,1,1007,"#include <bits/stdc++.h>
using namespace std;
// incomplete
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef complex<double> cd;

int main() {
	int n, q, a, b;
    char s[12];
    char c;
    
    scanf(""%d%d"", &n, &q);
    
    vector<string> VS(n+7, ""white"");

    while(q--){
        scanf("" %c"", &c);
        if (c == 'q') {
            scanf(""%d"", &a);
            string ans = VS[a];
            printf(""%s\n"",ans.c_str());
        } else {
            scanf(""%d%d %s"", &a, &b, s);
            string S(s);
            rep(i,a,b+1){
                VS[i] = S;
            }
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 00:16:36.63303,40
1,student2,1001,1001,"","",AC,cpp,2022-07-25 21:34:27.208487,100
50,JavaScriptJatts,1,1004,"#include <bits/stdc++.h>

int main() {

    int L;

    std::cin >> L;

    int sum = 0;

    while(std::cin >> L)
        sum += L;

    std::cout << sum;

    return(0);
}","",AC,C++17,2022-07-30 11:10:40.807957,100
51,PinesCyrex,1,1004,"n = int(input())
nums = list(map(int, input().split()))

# Do calculations
ans = 0
curr = 0
while(curr < n):
    ans += nums[curr]
    curr += 1

print(ans)","",AC,Python3,2022-07-30 11:10:44.68296,100
52,PinesCyrex,1,1004,"n = int(input())
nums = list(map(int, input().split()))
ans = 0

for i in range(n):
    ans += nums[i]


print(ans)","",AC,Python3,2022-07-30 11:11:04.965084,100
53,Albus,1,1004,"n = input()
sum = 0
numbersStr = input()
numbersStr = numbersStr.split(' ')
number = list(map(int,numbersStr))
for i in range(int(n)):
    sum += number[i]
print(sum)","",AC,Python3,2022-07-30 11:11:53.912135,100
55,HS,1,1005,"","/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':
(.text+0x20): undefined reference to `main'
collect2: error: ld returned 1 exit status
",CERR,C++17,2022-07-30 11:13:28.94154,0
56,NKSquared,1,1004,"n = int(input())
#nums = list(map(int, input().split()))

# Do calculations
ans = 0

for i in range(n):
    x = int(input())
    ans += x
    print(ans)


print(ans)","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 8, in <module>
    x = int(input())
ValueError: invalid literal for int() with base 10: '1 2 3 4 5'
",ERR,Python3,2022-07-30 11:13:38.042965,0
24,student1,1,1007,"#include <cstdio>
#include <map>
#include <string>
using namespace std;

map<int, string> M;

string q_at(int x){
    auto it = M.upper_bound(x);
    it--;
    return it->second;
}

int main(){
    int n, q, a, b;
    char s[12];
    char c;
    map<int, string>::iterator it, rm_start, rm_end;
    scanf(""%d%d"", &n, &q);
    M[-1]=""white"";
    while(q--){
        scanf("" %c"", &c);
        if (c == 'q') {
            scanf(""%d"", &a);
            it = M.upper_bound(a);
            it--;
            printf(""%s\n"",it->second.c_str());
        } else {
            scanf(""%d%d %s"", &a, &b, s);
            string S(s);
            
            string col_after = q_at(b+1);
            rm_start = M.lower_bound(a);
            rm_end = M.upper_bound(b);

            M.erase(rm_start, rm_end);
            M[a] = S;
            M[b+1] = col_after;
        }
    }
}","Failed on case 5, test 0",TLE,C++17,2022-07-30 00:17:25.125366,80
25,student1,1,1007,"#include <cstdio>
#include <map>
#include <string>
using namespace std;

map<int, string> M;

string q_at(int x){
    auto it = M.upper_bound(x);
    it--;
    return it->second;
}

int main(){
    int n, q, a, b;
    char s[12];
    char c;
    map<int, string>::iterator it, rm_start, rm_end;
    scanf(""%d%d"", &n, &q);
    M[-1]=""white"";
    while(q--){
        scanf("" %c"", &c);
        if (c == 'q') {
            scanf(""%d"", &a);
            it = M.upper_bound(a);
            it--;
            printf(""%s\n"",it->second.c_str());
        } else {
            scanf(""%d%d %s"", &a, &b, s);
            string S(s);
            
            string col_after = q_at(b+1);
            rm_start = M.lower_bound(a);
            rm_end = M.upper_bound(b);

            M.erase(rm_start, rm_end);
            M[a] = S;
            M[b+1] = col_after;
        }
    }
}","",AC,C++23,2022-07-30 00:18:04.734779,100
26,student1,1001,1001,"n = gets
nums = gets.split
sum = 0
nums.each{|x| sum += x.to_i}
puts sum",Language doesn't exist,InternalError,Ruby,2022-07-30 10:12:51.776444,0
27,student1,1001,1001,"n = gets
nums = gets.split
sum = 0
nums.each{|x| sum += x.to_i}
puts sum",Problem not found,IERR,Ruby,2022-07-30 10:14:07.046048,0
28,SoloGuy,1001,1001,"
n = int(input())

print(sum([i+1 for i in range(1,n+1)]) ",Problem not found,IERR,Python3,2022-07-30 10:43:15.269811,0
29,SoloGuy,1001,1001,"n = int(input))
print(sum([i*2 for i in range(1, n+1)]))
",Problem not found,IERR,Python3,2022-07-30 10:46:33.653415,0
30,untitled,1001,1001,"#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    int total = 0;
    for(int i = 0; i <= n; i++){
        total += i;
    }
    total *= 2;
    cout << total << endl;
}",Problem not found,IERR,C++17,2022-07-30 10:49:40.91891,0
31,untitled,1001,1003,"#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    int total = 0;
    for(int i = 0; i <= n; i++){
        total += i;
    }
    total *= 2;
    cout << total << endl;
}",Problem not found,IERR,C++17,2022-07-30 10:50:22.919023,0
32,untitled,1001,1002,"#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    int total = 0;
    for(int i = 0; i <= n; i++){
        total += i;
    }
    total *= 2;
    cout << total << endl;
}",Problem not found,IERR,C++17,2022-07-30 10:50:30.327857,0
33,untitled,1001,1001,print(30),Problem not found,IERR,Python3,2022-07-30 10:51:13.306351,0
34,HS,1001,1001,"#include <iostream>
using namespace std;

int main() {
cout << ""Hello world!!!"" << endl;
return 0;
}",Problem not found,IERR,C++17,2022-07-30 10:53:35.998949,0
35,teamAverage,1001,1001,"",Problem not found,IERR,C++23,2022-07-30 10:54:21.906653,0
36,datOvercommon,1001,1001,"int main()
{
  cout << ""Hello"";
}",Problem not found,IERR,C++17,2022-07-30 10:56:48.245202,0
37,NKSquared,1001,1001,"int n = 1;

int f(int n)
{
return 2 * n;
}

int main()
{
std::cout << n << std::endl;
return 0;
}",Problem not found,IERR,C++17,2022-07-30 10:59:51.658679,0
38,teamAverage,1001,1003,"#include <iostream>

using std::cout;
using std::cin;

int main(){
    int x=0;
    int sum=0;
    cin >> x;
    for(int i=0; i<(x+1)*2; i+=2){
        sum += i;       
    }
    cout << sum;
}",Problem not found,IERR,C++17,2022-07-30 11:00:35.853149,0
39,untitled,1,1004,"#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    long long answer = 0;
    for(int i = 0; i < n; i++){
        int val;
        cin >> val;
        answer += val;
    }
    cout << answer << endl;
}","",AC,C++17,2022-07-30 11:02:04.426146,100
41,NKSquared,1001,1001,"# get user inputs
user_input_n = input(""Enter n: "")
#user_input_a = input(""Enter a: "")

sum = 0

for i in range(user_input_n):
    sum += 2*i
print(sum)",Problem not found,IERR,Python3,2022-07-30 11:02:16.687349,0
40,HS,1,1004,"
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int n;
    cin >> n;
    int sum = 0;
    for (int i = 0; i < n; i++) {
        int a;
        cin >> a;
        
        sum += a;
    }
    cout << sum << endl;

    return 0;
}
","",AC,C++17,2022-07-30 11:02:14.33953,100
42,NKSquared,1001,1001,"# get user inputs
n = input()

sum = 0

for i in range(n):
    sum += 2*i
print(sum)",Problem not found,IERR,C++17,2022-07-30 11:03:13.049743,0
43,SoloGuy,1,1004,"
input()
print(sum(list(map(int, input().strip().split(' ')))))","",AC,Python3,2022-07-30 11:05:02.863428,100
44,YugoslaviaLover1992,1,1004,"n = int(input())
nums = list(map(int, input().split()))

# Do calculations
ans = 0
for i in range(0, n):
    ans += nums[i]

print(ans)","",AC,Python3,2022-07-30 11:05:26.587905,100
45,datOvercommon,1,1004,"#include <iostream>
#include <vector>
#include <string>
#include <map>

using namespace std;


int main()
{
	int n,temp, total = 0;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> temp;
		total == temp;
	}
	return total;
}

","WA on case 0, test 0",WA,C++17,2022-07-30 11:06:31.238242,0
46,TeamJin,1,1004,"n = int(input())
nums = list(map(int, input().split()))

# Do calculations
ans = 0
for i in range(n):
    ans += nums[i]

print(ans)","",AC,Python3,2022-07-30 11:06:57.278255,100
47,datOvercommon,1,1004,"#include <iostream>
#include <vector>
#include <string>
#include <map>

using namespace std;


int main()
{
	int n,temp, total = 0;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> temp;
		total += temp;
	}
	cout << total;

	return 0;
}

","",AC,C++17,2022-07-30 11:07:36.500866,100
48,rvijayar,1,1004,"#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(NULL);

  int n, x;
  cin >> n;

  int total = 0;

  while(n--) {
    cin >> x;
    total += x;
  }

  cout << total;

  return 0;
}","",AC,C++17,2022-07-30 11:08:18.699149,100
49,NKSquared,1001,1001,"# get user inputs
n = int(input())

sum = 0

for i in range(1,n + 1):
    sum += 2*i
print(sum)",Problem not found,IERR,Python3,2022-07-30 11:08:25.881004,0
54,glovia,1,1004,"n = int(input(""Please enter a number: ""))
result = (n*(n+1)/2)
print(""The answer is %d"" %(result))","WA on case 0, test 0",WA,Python3,2022-07-30 11:13:24.760059,0
57,NKSquared,1,1004,"n = int(input())
nums = list(map(int, input().split()))

# Do calculations
ans = 0

for i in range(n):
    ans += nums[i]


print(ans)","",AC,Python3,2022-07-30 11:14:39.57307,100
58,teamAverage,1,1004,"using namespace std;
#include <iostream>


int main() {
  int i,tot=0,o=0;
  cin >> i;
  if (i<=100&&i>=2){
    int a[i];
;   for (int k=1;k<=i;k++){
      cin >> o;
      if (o>=1&&o<=100000){
        a[k]=o;
        tot += a[k];
      }
      else{
        k--;
      }
    }
  }
  cout<<tot;
}","",AC,C++17,2022-07-30 11:14:57.925008,100
59,duckduckdoo,1,1004,"#include <iostream>
using namespace std;

int main (int argc, char *argv[])
{
    printf(""%d"", argc);
  return 0;
}","WA on case 0, test 0",WA,C++17,2022-07-30 11:18:51.008077,0
60,TeamJin,1,1007,"nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]

fenceColList = []
for i in range(n):
    fenceColList.insert(""white"")


# for number of queries
    # if first char is p
        # set list a-1 to b-1 to that col
        # 
    # if first char is q
        #print a
        # 

for i in range(q):
    charLst =  list(map(int, input().split()))
    a = int(charLst[1]) - 1
    if charLst[0] == ""p"":
        b = int(charLst[2]) - 1
        for i in range(a, b):
            fenceColList[i] = charLst[3]

    else:
        print(charLst[a])","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 7, in <module>
    fenceColList.insert(""white"")
TypeError: insert expected 2 arguments, got 1
",ERR,Python3,2022-07-30 11:19:29.316239,0
61,TeamJin,1,1007,"nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]

fenceColList = []
for i in range(n):
    fenceColList.append(""white"")


# for number of queries
    # if first char is p
        # set list a-1 to b-1 to that col
        # 
    # if first char is q
        #print a
        # 

for i in range(q):
    charLst =  list(map(str, input().split()))
    a = int(charLst[1]) - 1
    
    if charLst[0] == ""p"":
        b = int(charLst[2]) - 1
        for i in range(a, b):
            fenceColList[i] = charLst[3]

    else:
        print(fenceColList[a])","WA on case 0, test 0",WA,Python3,2022-07-30 11:22:11.441616,0
62,TeamJin,1,1007,"nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]

fenceColList = []
for i in range(n):
    fenceColList.append(""white"")


# for number of queries
    # if first char is p
        # set list a-1 to b-1 to that col
        # 
    # if first char is q
        #print a
        # 

for i in range(q):
    charLst =  list(map(str, input().split()))
    a = int(charLst[1]) - 1
    
    if charLst[0] == ""p"":
        b = int(charLst[2]) - 1
        for i in range(a, b + 1):
            fenceColList[i] = charLst[3]

    else:
        print(fenceColList[a])","Failed on case 2, test 0",TLE,Python3,2022-07-30 11:24:49.961853,20
63,Albus,1,1005,"[n, m] = list(map(int, input().split()))
nums = list(map(int, input().split()))
print(""a"", nums)","WA on case 0, test 0",WA,Python3,2022-07-30 11:26:06.607253,0
64,HS,1,1007,"
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int n, q;
    cin >> n >> q;
    
    // init set
    set<pair<int, string>> color_starts;
    color_starts.insert(pair<int, string>(1, ""white""));
    
    for (int i = 0; i < q; i++) {
        char qtype;
        cin >> qtype;
        if (qtype == 'p') {
            int a, b;
            string col;
            cin >> a >> b >> col;
            auto before_a = color_starts.lower_bound(pair<int, string>(a, """"));
            auto before_b = color_starts.upper_bound(pair<int, string>(b+1, """"));
            
            // edge case: nothing to erase
            if (before_a == before_b) {
                color_starts.insert(pair<int, string>(a, col));
                color_starts.insert(pair<int, string>(b+1, ""white""));
                continue;
            }
            
            auto last_inside = before_b;
            last_inside--;
            string old_color = last_inside->second;
            color_starts.erase(before_a, before_b);
            color_starts.insert(pair<int, string>(a, col));
            color_starts.insert(pair<int, string>(b+1, old_color));
        }
        else { // qtype == 'q'
            int a;
            cin >> a;
        
            auto target_color = color_starts.upper_bound(pair<int, string>(a+1, """"));
            target_color--;
            cout << target_color->second << endl;
        }
    }

    return 0;
}
","WA on case 1, test 0",WA,C++17,2022-07-30 11:29:56.012742,0
92,glovia,1,1004,"# Output the sum of the N numbers
n = int(input())
nums = list(map(int, input().split()))

# Do calculations
ans = 0

for i in range(0,len(nums)):
    ans += nums[i]

print(ans)","",AC,Python3,2022-07-30 12:05:57.606481,100
65,teamAverage,1,1006,"#include <iostream>
#include <iomanip>

using std::cout;
using std::cin;
using std::setw;

int main(){
    int x=0;
    int sum=0;
    cin >> x;
    for(int i=0; i<x; i++){
        if(i==0){
            cout << setw(x+1) << '>' << ""\n"";
            cout << setw(x+1) << '|' << ""\n"";
            cout << setw(x+1) << '.' << ""\n"";
        }   
        else{
            cout << setw(x+1-i) << ""/"";
            for(int j=0; j<i;j++){
                cout << char(65+j);
            }
            
            for(int k=i-2; k>-1;k--){
                cout << char(65+k);
            }
            cout << char(92) << ""\n"";
        }   
    }
}
","",AC,C++17,2022-07-30 11:29:59.693881,50
66,duckduckdoo,1,1006,"n=gets.chop.to_i
s=' '*n
puts ""#{s}>\n#{s}|\n#{s}.""
(1...n).map{|i|
  e=(i+64).chr
  a=[*""A""...e].join
  print "" ""*(n-i),'/',a,e,a.reverse,'\\',""\n""
}","",AC,Ruby,2022-07-30 11:34:24.000772,50
67,untitled,1,1007,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const int inf = 1e9;
struct Node {
	Node *l = 0, *r = 0;
	int lo, hi, mset = inf, madd = 0, val = -inf;
	Node(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf
	Node(vi& v, int lo, int hi) : lo(lo), hi(hi) {
		if (lo + 1 < hi) {
			int mid = lo + (hi - lo)/2;
			l = new Node(v, lo, mid); r = new Node(v, mid, hi);
			val = max(l->val, r->val);
		}
		else val = v[lo];
	}
	int query(int L, int R) {
		if (R <= lo || hi <= L) return -inf;
		if (L <= lo && hi <= R) return val;
		push();
		return max(l->query(L, R), r->query(L, R));
	}
	void set(int L, int R, int x) {
		if (R <= lo || hi <= L) return;
		if (L <= lo && hi <= R) mset = val = x, madd = 0;
		else {
			push(), l->set(L, R, x), r->set(L, R, x);
			val = max(l->val, r->val);
		}
	}
	void add(int L, int R, int x) {
		if (R <= lo || hi <= L) return;
		if (L <= lo && hi <= R) {
			if (mset != inf) mset += x;
			else madd += x;
			val += x;
		}
		else {
			push(), l->add(L, R, x), r->add(L, R, x);
			val = max(l->val, r->val);
		}
	}
	void push() {
		if (!l) {
			int mid = lo + (hi - lo)/2;
			l = new Node(lo, mid); r = new Node(mid, hi);
		}
		if (mset != inf)
			l->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;
		else if (madd)
			l->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;
	}
};

map<int, string> colors;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin.exceptions(cin.failbit);

    int n, q;
    cin >> n >> q;

    vector<int> vals(n + 7);
    Node* segtree = new Node(vals, 0, sz(vals));
    colors[0] = ""white"";
    int colorIndex = 1;
    for(int i = 0; i < q; i++){
        string s;
        cin >> s;
        if(s == ""q"") {
            int index;
            cin >> index;
            int val = segtree->query(index, index+1);
            cout << colors[val] << endl;
        }else{
            int l, r;
            string color;
            cin >> l >> r >> color;
            segtree->set(l, r+1, colorIndex);
            colors[colorIndex] = color;
            colorIndex++;
        }
    }
}","Failed on case 4, test 0",MLE,C++17,2022-07-30 11:38:02.642918,60
68,coffeepls,1,1004,"#include <iostream>
using namespace std;

#define ll long long

int main() {
    int n;
    cin >> n;
    int arr[n];
    for (int i=0; i<n; ++i)
        cin >> arr[i];
    int sum = 0;
    for (int i=0; i<n; ++i) 
        sum += arr[i];
    cout << sum << endl;
    return 0;
}","",AC,C++17,2022-07-30 11:38:33.756441,100
93,JavaScriptJatts,1,1006,"#include <bits/stdc++.h>
using namespace::std;int main() {vector<string> c;int N;cin >> N;string o = """";for(int l=1;l<N;l++){string p = """";o += "" "";for(int i=0;i<l;i++)p+=char(65+i);for(int i=l-2;i>=0;i--)p+=p.at(i);c.push_back(p);}cout<<o<<"">""<<endl<<o<<""|""<<endl<<o<<"".""<<endl;for(int i=N-2;i>=0;i--){string t="""";for(int s=0;s<i;s++)t+="" "";t+=(""/""+c[N-i-2]+""\\\n"");cout<<t;}}","",AC,C++17,2022-07-30 12:09:21.589248,50
96,duckduckdoo,1,1007,"#include <iostream>
using namespace std;

int main() {
  int numFences, numQueries;
  cin>>numFences>>numQueries;
  string f[numFences];
  for (int i = 0; i < numFences; i++) {
    f[i] = ""white"";
  }
  for (int i = 0; i < numQueries; i++) {
    char command;
    cin>>command;
    if (command == 'p') {
      int start, end;
      string color;
      cin>>start>>end>>color;
      for (int i = start-1; i < end; i++) {
        f[i] = color;
      }
    }
    else if (command == 'q') {
      int fenceNum;
      cin>>fenceNum;
      cout<<f[fenceNum-1]<<endl;
    }
  }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 12:11:53.201544,40
97,PinesCyrex,1,1007,"#include <iostream>
int main() {
    int fenceCount;
    int qCount;
    std::cin >> fenceCount >> qCount;

    std::string fences[fenceCount];
    std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

    for (int i = 0; i < qCount; i++) {
        std::string qType;
        std::cin >> qType;
        if (qType == ""q"") {
            int retrieve;
            std::cin >> retrieve;
            std::cout << fences[retrieve - 1];
        } else if (qType == ""p"") {
            int first;
            int last;
            std::string color;
            std::cin >> first >> last >> color;
            for (int i = first - 1; i < last; i++) {
                fences[i] = color;
            }
        }
    }

    return 0;
}","WA on case 0, test 0",WA,C++17,2022-07-30 12:13:30.297477,0
100,PinesCyrex,1,1007,"#include <iostream>
int main() {
    int fenceCount;
    int qCount;
    std::cin >> fenceCount >> qCount;

    std::string fences[fenceCount];
    std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

    for (int i = 0; i < qCount; i++) {
        std::string qType;
        std::cin >> qType;
        if (qType == ""q"") {
            int retrieve;
            std::cin >> retrieve;
            std::cout << fences[retrieve - 1] << std::endl;
        } else if (qType == ""p"") {
            int first;
            int last;
            std::string color;
            std::cin >> first >> last >> color;
            for (int i = first - 1; i < last; i++) {
                fences[i] = color;
            }
        }
    }

    return 0;
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 12:18:18.088969,40
101,duckduckdoo,1,1007,"#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
  int numFences, numQueries;
  cin>>numFences>>numQueries;
  unordered_map<int, string> f;
  for (int i = 0; i < numQueries; i++) {
    char command;
    cin>>command;
    if (command == 'p') {
      int start, end;
      string color;
      cin>>start>>end>>color;
      for (int i = start-1; i < end; i++) {
        f[i] = color;
      }
    }
    else if (command == 'q') {
      int fenceNum;
      cin>>fenceNum;
      fenceNum--;
      (f.find(fenceNum) == f.end()) ?
        cout<<""white""<<endl :
        cout<<f[fenceNum]<<endl;
    }
  }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 12:19:57.130875,40
142,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i < plank; i++){
        fences[i] = ""white"";
    }
    vector<string> out;
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.push_back(fences[n]);
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    for(const auto i: out){
        cout << i << endl;
        cout.flush();
    }
}","WA on case 1, test 0",WA,C++17,2022-07-30 13:09:56.473854,0
155,HS,1,1006,"n = int(input())
    print(' '*(n-1)+"">"")
    print(' '*(n-1)+""|"")
    s = """"
    print(' '*(n-1)+""."")
    for i in range(0,n-1):
        s += '/'
        for j in range(0,i+1):
            s+= chr(j+65)
        if(i!=0):
            print(' '*((n-2)-i)+s+s[len(s)-2:0:-1]+'\\')
        else:
            print(' '*((n-2)-i)+s+'\\')
        s=""""","Error with code 1:
  File ""/code/Main.py"", line 2
    print(' '*(n-1)+"">"")
IndentationError: unexpected indent
",ERR,Python3,2022-07-30 13:19:00.468999,0
69,HS,1,1007,"
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int n, q;
    cin >> n >> q;
    
    // init set
    set<pair<int, string>> color_starts;
    color_starts.insert(pair<int, string>(1, ""white""));
    
    for (int i = 0; i < q; i++) {
        char qtype;
        cin >> qtype;
        if (qtype == 'p') {
            int a, b;
            string col;
            cin >> a >> b >> col;
            auto before_a = color_starts.lower_bound(pair<int, string>(a, """"));
            auto after_bpl1 = color_starts.upper_bound(pair<int, string>(b+2, """"));
            
            auto last_inside = after_bpl1;
            last_inside--;
            
            // edge case: nothing to erase
            if (before_a == last_inside) {
                color_starts.insert(pair<int, string>(a, col));
                color_starts.insert(pair<int, string>(b+1, ""white""));
                continue;
            }
            
            string old_color = last_inside->second;
            color_starts.erase(before_a, after_bpl1);
            color_starts.insert(pair<int, string>(a, col));
            color_starts.insert(pair<int, string>(b+1, old_color));
        }
        else { // qtype == 'q'
            int a;
            cin >> a;
        
            auto target_color = color_starts.upper_bound(pair<int, string>(a+1, """"));
            target_color--;
            cout << target_color->second << endl;
        }
    }

    return 0;
}
","WA on case 1, test 0",WA,C++17,2022-07-30 11:39:58.557821,0
70,coffeepls,1,1004,"#include <iostream>
using namespace std;

#define ll long long

int main() {
    int n;
    cin >> n;
    int arr[n];
    for (int i=0; i<n; ++i)
        cin >> arr[i];
    int sum = 0;
    for (int i=0; i<n; ++i) 
        sum += arr[i];
    cout << sum << endl;
    return 0;
}","",AC,C++17,2022-07-30 11:40:43.109695,100
71,duckduckdoo,1,1004,"n = int(input())
nums = list(map(int, input().split()))

# Do calculations
ans = 0
for num in nums:
    ans += nums;

print(ans)
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 7, in <module>
    ans += nums;
TypeError: unsupported operand type(s) for +=: 'int' and 'list'
",ERR,Python3,2022-07-30 11:41:45.904081,0
72,TeamJin,1,1007,"nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]
print(""OK"")

fenceColList = []
for i in range(n):
    fenceColList.append(""white"")

#--------------------------
"""""" 
class BSTNode():
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None


class BST():
    def __init__(self):
        root = None

    

    def insertRec(self, key, curNode):
        if curNode == None:
            return BSTNode(key)
        else:
            if (key < curNode.key):
                curNode.left = insertRec(key, curNode.left)
            else:
                curNode.right = insertRec(key, curNode.right)


    def insert(self, key):
        root = insertRec(self, key, root)

    def searchRec(self, key, curNode):
        if curNode == None:
            return BSTNode(key)
        else:
            if (key > curNode.key):
                curNode.left = in(key, curNode.left)
            else:
                curNode.right = insert(key, curNode.right) """"""

#---------------------


for i in range(q):
    charLst =  list(map(str, input().split()))
    firstIndex = int(charLst[1]) - 1
    
    # p 2 4 black
    if charLst[0] == ""p"":
        secondIndex = int(charLst[2]) - 1
        for i in range(firstIndex, secondIndex + 1):
            fenceColList[i] = charLst[3]

    else:
        print(fenceColList[firstIndex])","WA on case 0, test 0",WA,Python3,2022-07-30 11:43:08.603416,0
73,TeamJin,1,1007,"nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]


fenceColList = []
for i in range(n):
    fenceColList.append(""white"")

#--------------------------
"""""" 
class BSTNode():
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None


class BST():
    def __init__(self):
        root = None

    

    def insertRec(self, key, curNode):
        if curNode == None:
            return BSTNode(key)
        else:
            if (key < curNode.key):
                curNode.left = insertRec(key, curNode.left)
            else:
                curNode.right = insertRec(key, curNode.right)


    def insert(self, key):
        root = insertRec(self, key, root)

    def searchRec(self, key, curNode):
        if curNode == None:
            return BSTNode(key)
        else:
            if (key > curNode.key):
                curNode.left = in(key, curNode.left)
            else:
                curNode.right = insert(key, curNode.right) """"""

#---------------------


for i in range(q):
    charLst =  list(map(str, input().split()))
    firstIndex = int(charLst[1]) - 1
    
    # p 2 4 black
    if charLst[0] == ""p"":
        secondIndex = int(charLst[2]) - 1
        for i in range(firstIndex, secondIndex + 1):
            fenceColList[i] = charLst[3]

    else:
        print(fenceColList[firstIndex])","Failed on case 2, test 0",TLE,Python3,2022-07-30 11:43:40.355582,20
74,glovia,1,1004,"# Output the sum of the N numbers
print(""Please enter some numbers: "")
n = int(input())
nums = list(map(int, input().split()))

# Do calculations
ans = 0

for i in range(0,len(nums)):
    ans += nums[i]

print(ans)","WA on case 0, test 0",WA,Python3,2022-07-30 11:44:17.744162,0
98,YugoslaviaLover1992,1,1006,"#include <iostream>
#include <iomanip>

using namespace std;

int main(int argc, char **argv) {
    int s;
    cin>>s;
    auto w = setw(s+1);
    cout << w << "">\n"" << w << ""|\n"" << w << "".\n"";
    int j; 
    for (int i = 1; i < s; i++) {
        cout << setw(s - i) <<""/"";
        for (j = 0; j < i; j++)
            cout << char(65 + j);
        for (j = i-2; j >= 0; j--)
            cout << char(65 + j);
        cout<<""\\\n"";
    }
    return 0;  
}","",AC,C++17,2022-07-30 12:17:37.145767,50
99,coffeepls,1,1006,"#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

#define ll long long

int main() {
    int n;
    cin >> n;
    string spc, ans;
    for (int i=0; i<n-1; ++i)
        spc += "" "";
    cout << spc+"">"" << endl;
    cout << spc+""|"" << endl;
    cout << spc+""."" << endl;
    string sls = ""/"";
    for (int i=2; i<n+1; ++i) {
        spc.pop_back();
        ans = spc + sls;
        string buf;
        for (int j=0; j<i-1; ++j)
            buf += char(65+j);
        ans += buf;
        buf.pop_back();
        reverse(buf.begin(), buf.end());
        ans += buf + char(92);
        cout << ans << endl;
    }
    return 0;
}","",AC,C++17,2022-07-30 12:17:45.550032,50
225,FuduBoys,1,1006,"r = int(input())
s="" ""*(r-3)
print(s,"" >\n"",s,""|\n"",s,""."")
s+="" ""
c1 = c = k = 0
for i in range(1, r):
  c=r-i-1
  print(s, end="""")
  print(""/"", end="""")
  while k!=((2*i)-1):
      if c<=r-2:
        print(chr(k+65), end="""")
        c+=1
      else:
        c1+=1
        print(chr(k-(2*c1)+65), end="""")
      k+= 1
  c1 = c = k = 0
  s = s[:-1]
  print(""\\"")","",AC,Python3,2022-07-30 14:31:23.81085,50
75,TeamJin,1,1007,"from datetime import datetime

nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]
print(datetime.now())

fenceColList = []
for i in range(n):
    fenceColList.append(""white"")

print(datetime.now())

#--------------------------
"""""" 
class BSTNode():
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None


class BST():
    def __init__(self):
        root = None

    

    def insertRec(self, key, curNode):
        if curNode == None:
            return BSTNode(key)
        else:
            if (key < curNode.key):
                curNode.left = insertRec(key, curNode.left)
            else:
                curNode.right = insertRec(key, curNode.right)


    def insert(self, key):
        root = insertRec(self, key, root)

    def searchRec(self, key, curNode):
        if curNode == None:
            return BSTNode(key)
        else:
            if (key > curNode.key):
                curNode.left = in(key, curNode.left)
            else:
                curNode.right = insert(key, curNode.right) """"""

#---------------------


for i in range(q):
    charLst =  list(input().split())
    firstIndex = int(charLst[1]) - 1
    
    # p 2 4 black
    if charLst[0] == ""p"":
        secondIndex = int(charLst[2]) - 1
        for i in range(firstIndex, secondIndex + 1):
            fenceColList[i] = charLst[3]

    if charLst[0] == ""q"":
        print(fenceColList[firstIndex])","WA on case 0, test 0",WA,Python3,2022-07-30 11:47:00.422717,0
76,TeamJin,1,1007,"from datetime import datetime

nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]
#print(datetime.now())

fenceColList = []
for i in range(n):
    fenceColList.append(""white"")

#print(datetime.now())

#--------------------------
"""""" 
class BSTNode():
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None


class BST():
    def __init__(self):
        root = None

    

    def insertRec(self, key, curNode):
        if curNode == None:
            return BSTNode(key)
        else:
            if (key < curNode.key):
                curNode.left = insertRec(key, curNode.left)
            else:
                curNode.right = insertRec(key, curNode.right)


    def insert(self, key):
        root = insertRec(self, key, root)

    def searchRec(self, key, curNode):
        if curNode == None:
            return BSTNode(key)
        else:
            if (key > curNode.key):
                curNode.left = in(key, curNode.left)
            else:
                curNode.right = insert(key, curNode.right) """"""

#---------------------


for i in range(q):
    charLst =  list(input().split())
    firstIndex = int(charLst[1]) - 1
    
    # p 2 4 black
    if charLst[0] == ""p"":
        secondIndex = int(charLst[2]) - 1
        for i in range(firstIndex, secondIndex + 1):
            fenceColList[i] = charLst[3]

    if charLst[0] == ""q"":
        print(fenceColList[firstIndex])","Failed on case 2, test 0",TLE,Python3,2022-07-30 11:47:45.006,20
77,SoloGuy,1,1007,"n, q = tuple(map(int, input().strip().split(' ')))

fence = [""white""] * n

for i in range(q):
    
    query = input().strip().split(' ')

    if query[0] == 'q':
        print(fence[int(query[1]) - 1])
    
    elif query[0] == 'p':
        
        for i in range(int(query[1]) -1, int(query[2])):
            fence[i] = query[3]
","Failed on case 2, test 0",TLE,Python3,2022-07-30 11:48:13.109611,20
78,NKSquared,1,1006,"n = int(input())
print("" "" * (n - 1) + "">"")
print("" "" * (n - 1) + ""|"")
print("" "" * (n - 1) + ""."")
for i in range(1, n):
    print((n - 1 - i) * "" "" + ""/"", end='')
    for j in range(i):
        print(chr(65 + j), end='')
    for j in reversed(range(i - 1)):
        print(chr(65 + j), end='')
    print(""\\"")","/code/Main.cpp:6:40: error: empty character constant
    6 |     print((n - 1 - i) * "" "" + ""/"", end='')
      |                                        ^~
/code/Main.cpp:8:32: error: empty character constant
    8 |         print(chr(65 + j), end='')
      |                                ^~
/code/Main.cpp:10:32: error: empty character constant
   10 |         print(chr(65 + j), end='')
      |                                ^~
/code/Main.cpp:1:1: error: ‘n’ does not name a type
    1 | n = int(input())
      | ^
",CERR,C++17,2022-07-30 11:48:17.51986,0
79,NKSquared,1,1006,"n = int(input())
print("" "" * (n - 1) + "">"")
print("" "" * (n - 1) + ""|"")
print("" "" * (n - 1) + ""."")
for i in range(1, n):
    print((n - 1 - i) * "" "" + ""/"", end='')
    for j in range(i):
        print(chr(65 + j), end='')
    for j in reversed(range(i - 1)):
        print(chr(65 + j), end='')
    print(""\\"")","/code/Main.cpp:6:40: error: empty character constant
    6 |     print((n - 1 - i) * "" "" + ""/"", end='')
      |                                        ^~
/code/Main.cpp:8:32: error: empty character constant
    8 |         print(chr(65 + j), end='')
      |                                ^~
/code/Main.cpp:10:32: error: empty character constant
   10 |         print(chr(65 + j), end='')
      |                                ^~
/code/Main.cpp:1:1: error: ‘n’ does not name a type
    1 | n = int(input())
      | ^
",CERR,C++17,2022-07-30 11:48:55.885341,0
94,duckduckdoo,1,1007,"#include <iostream>
using namespace std;

int main() {
  int numFences, numQueries;
  cin>>numFences>>numQueries;
  string f[numFences];
  for (int i = 0; i < numFences; i++) {
    f[i] = ""white"";
  }
  for (int i = 0; i < numQueries; i++) {
    char command;
    cin>>command;
    if (command == 'p') {
      int start, end;
      string color;
      cin>>start>>end>>color;
      for (int i = start-1; i < end; i++) {
        f[i] = color;
      }
    }
    else if (command == 'q') {
      int fenceNum;
      cin>>fenceNum;
      cout<<f[fenceNum-1]<<endl;
    }
    for (int i = 0; i < numFences; i++) {
      cout<<f[i]<<"" "";
    }
  }
}
","WA on case 0, test 0",WA,C++17,2022-07-30 12:11:07.888456,0
95,Albus,1,1006,"#include <stdio.h> 
void s(int n){
    for(int i=1;i<n;i++){
        printf("" "");
    }
}
void p(int n, int r){
    s(n-r-1);
    printf(""/"");
    for (int i = 0; i < r; i++)
    {
        printf(""%c"",'A'+i);
    }
    for (int i = r; i > -1; i--)
    {
        printf(""%c"",'A'+i);
    }
    printf(""\\\n"");

    
}
int main()
{
    int n;
    scanf(""%d"",&n);
    s(n);
    printf("">\n"");
    s(n);
    printf(""|\n"");
    s(n);
    printf("".\n"");
    for(int i=1; i<n; i++){
        p(n,i-1);
    }

    return 0;
}
","",AC,C++17,2022-07-30 12:11:22.545249,50
80,HS,1,1007,"
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int n, q;
    cin >> n >> q;
    
    // init set
    set<pair<int, string>> color_starts;
    color_starts.insert(pair<int, string>(1, ""white""));
    
    for (int i = 0; i < q; i++) {
        char qtype;
        cin >> qtype;
        if (qtype == 'p') {
            int a, b;
            string col;
            cin >> a >> b >> col;
            auto before_a = color_starts.lower_bound(pair<int, string>(a, """"));
            auto after_bpl1 = color_starts.upper_bound(pair<int, string>(b+2, """"));
            
            auto last_inside = after_bpl1;
            last_inside--;
            
            string old_color = last_inside->second;
            color_starts.erase(before_a, after_bpl1);
            color_starts.insert(pair<int, string>(a, col));
            color_starts.insert(pair<int, string>(b+1, old_color));
        }
        else { // qtype == 'q'
            int a;
            cin >> a;
        
            auto target_color = color_starts.upper_bound(pair<int, string>(a+1, """"));
            target_color--;
            cout << target_color->second << endl;
        }
    }

    return 0;
}
","Failed on case 5, test 0",TLE,C++17,2022-07-30 11:49:14.671143,80
81,BandishBandit,1,1004,"n = int(input())
nums = list(map(int, input().split()))

# Do calculations
ans = 0
for i in range(n):
    ans += nums[i]

print(ans)","",AC,Python3,2022-07-30 11:50:37.599153,100
82,NKSquared,1,1006,"n = int(input())
if (n < 1 or n > 27):
  exit(0)
print("" "" * (n - 1) + "">"")
print("" "" * (n - 1) + ""|"")
print("" "" * (n - 1) + ""."")
for i in range(1, n):
    print((n - 1 - i) * "" "" + ""/"", end='')
    for j in range(i):
        print(chr(65 + j), end='')
    for j in reversed(range(i - 1)):
        print(chr(65 + j), end='')
    print(""\\"")","/code/Main.cpp:8:40: error: empty character constant
    8 |     print((n - 1 - i) * "" "" + ""/"", end='')
      |                                        ^~
/code/Main.cpp:10:32: error: empty character constant
   10 |         print(chr(65 + j), end='')
      |                                ^~
/code/Main.cpp:12:32: error: empty character constant
   12 |         print(chr(65 + j), end='')
      |                                ^~
/code/Main.cpp:1:1: error: ‘n’ does not name a type
    1 | n = int(input())
      | ^
",CERR,C++17,2022-07-30 11:50:48.40884,0
83,datOvercommon,1,1006,"#include <iostream>
using namespace std;

int main(){
    int n;
    cin >> n;
    for(int i=0;i<n+1;i++){cout << "" "";}
    cout << "">"" << endl;
    for(int i=0;i<n+1;i++){cout << "" "";}
    cout << ""|"" << endl;
    for (int i=0;i<n+1;i++){cout << "" "";}
    cout << ""."" << endl;
    int l = n; int t = 1;
    while(l-1>0){
        for(int i=0; i<l;i++){cout << "" "";}
        cout << ""/"";
        for(int i=65; i<65+t; i++){cout << char(i);}
        for(int i=64+t-1; i>64; i--){cout << char(i);}
        cout << ""\\"" << endl; --l; ++t;
}}","",AC,C++17,2022-07-30 11:51:22.353172,50
84,NKSquared,1,1006,"
n = int(input())


print("" ""*(n-1) + "">"")
print("" ""*(n-1) + ""|"")
print("" ""*(n-1) + ""."")

for i in range(1, n):
    print((n-1-i) * "" "" + ""/"", end = '')
    for j in range(i):
        print(chr(65 + j), end = '') 

    for j in range(i-1):
        print(chr(65 - j + i - 2), end = '') 

    print(""\\"")","",AC,Python3,2022-07-30 11:51:40.854193,50
85,TeamJin,1,1007,"from datetime import datetime

nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]
print(datetime.now())

fenceColList = []
for i in range(n):
    fenceColList.append(""white"")

print(datetime.now())


for i in range(q):
    charLst =  input().split()
    firstIndex = int(charLst[1]) - 1
    
    # p 2 4 black
    if charLst[0] == ""p"":
        secondIndex = int(charLst[2]) - 1
        for i in range(firstIndex, secondIndex + 1):
            fenceColList[i] = charLst[3]

    else:
        print(fenceColList[firstIndex])","WA on case 0, test 0",WA,Python3,2022-07-30 11:53:26.171966,0
87,duckduckdoo,1,1004,"n = int(input())
nums = list(map(int, input().split()))

# Do calculations
ans = 0
p = 0
for num in nums:
    if(p >= n):
        break;
    ans += num;
    p+= 1;
    

print(ans)
","",AC,Python3,2022-07-30 11:55:00.516276,100
86,TeamJin,1,1007,"#from datetime import datetime

nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]
#print(datetime.now())

fenceColList = []
for i in range(n):
    fenceColList.append(""white"")

#print(datetime.now())


for i in range(q):
    charLst =  input().split()
    firstIndex = int(charLst[1]) - 1
    
    # p 2 4 black
    if charLst[0] == ""p"":
        secondIndex = int(charLst[2]) - 1
        for i in range(firstIndex, secondIndex + 1):
            fenceColList[i] = charLst[3]

    else:
        print(fenceColList[firstIndex])","Failed on case 2, test 0",TLE,Python3,2022-07-30 11:54:59.404227,20
88,FuduBoys,1,1004,"n = int(input())
nums = list(map(int, input().split()))
nums = nums[0:n]
ans = sum(nums)
print(ans)","",AC,Python3,2022-07-30 11:56:15.519858,100
89,datOvercommon,1,1006,"#include <iostream>
using namespace std;

int main(){
    int n;cin >> n;
    for(int i=0;i<n+1;i++){cout<<"" "";}cout<<"">""<<endl;
    for(int i=0;i<n+1;i++){cout<<"" "";}cout<<""|""<<endl;
    for(int i=0;i<n+1;i++){cout<<"" "";}cout<<"".""<<endl;
    int l=n;int t=1;
    while(l-1>0){
        for(int i=0;i<l;i++){cout<<"" "";}cout<<""/"";
        for(int i=65;i<65+t;i++){cout<<char(i);}
        for(int i=64+t-1;i>64;i--){cout<<char(i);}
        cout<<""\\""<<endl;--l;++t;
}}","",AC,C++17,2022-07-30 11:59:51.588576,50
90,duckduckdoo,1,1007,"#include <iostream>
using namespace std;

int main() {
  int numFences, numQueries;
  cin>>numFences>>numQueries;
  string f[numFences];
  for (int i = 0; i < numFences; i++) {
    f[i] = ""white"";
  }
  for (int i = 0; i < numQueries; i++) {
    char command;
    cin>>command;
    if (command == 'p') {
      int start, end;
      string color;
      cin>>start>>end>>color;
      for (int i = start; i <= end; i++) {
        f[i] = color;
      }
    }
    else if (command == 'q') {
      int fenceNum;
      cin>>fenceNum;
      cout<<f[fenceNum]<<endl;
    }
  }
}","Traceback (most recent call last):
  File ""/judge/judge_utils/sandbox.py"", line 54, in basic_safe_run
    (out, err) = proc.communicate(
  File ""/usr/lib/python3.10/subprocess.py"", line 1152, in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
  File ""/usr/lib/python3.10/subprocess.py"", line 2041, in _communicate
    stdout = self._translate_newlines(stdout,
  File ""/usr/lib/python3.10/subprocess.py"", line 1029, in _translate_newlines
    data = data.decode(encoding, errors)
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xae in position 84: invalid start byte
",ERR,C++17,2022-07-30 12:00:17.846286,0
91,JavaScriptJatts,1,1006,"var{createInterface:i}=require('readline')
p=process
t=i({input:p.stdin,output:p.stdout})
c=console.log
t.on('line',n=>{
r=(i=0)=>' '.repeat(n-1-i);[...'>|.'].forEach(v=>c(r()+v))
for(i=1;i<n;i++){l=''
for(j=0;j++<i;)l+=String.fromCharCode(64+j);l+=[...l].slice(0,-1).reverse().join('')
c(`${r(i)}/${l}\\`)}t.close()
})","",AC,NodeJS,2022-07-30 12:04:10.087278,50
102,teamAverage,1,1005,"#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(){
    //initialize map and iterator
    map<int, string> fences;

    //read the number of fences and queries
    int numFences, numQueries;
    cin >> numFences >> numQueries;

    //insert all initial elements as white
    for (int i = 0; i < numFences; i++){
        fences.insert(make_pair((i + 1), ""white""));
    }

    //initialize all the variables needed
    char type;

    //take the input in a loop
    for(int i = 0; i < numQueries; i++){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            string color;
            cin >> start >> end;
            cin >> color;
            //modify the fences' colors
            for(int j = start; j <= end; j++){
                fences[j] = color;
            }
        }
        else if(type == 'q'){
            //take in 1 input
            int key;
            cin >> key;
            cout << fences[key] << endl;
        }
    }
}","WA on case 0, test 0",WA,C++17,2022-07-30 12:20:17.832655,0
103,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(){
    //initialize map and iterator
    map<int, string> fences;

    //read the number of fences and queries
    int numFences, numQueries;
    cin >> numFences >> numQueries;

    //insert all initial elements as white
    for (int i = 0; i < numFences; i++){
        fences.insert(make_pair((i + 1), ""white""));
    }

    //initialize all the variables needed
    char type;

    //take the input in a loop
    for(int i = 0; i < numQueries; i++){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            string color;
            cin >> start >> end;
            cin >> color;
            //modify the fences' colors
            for(int j = start; j <= end; j++){
                fences[j] = color;
            }
        }
        else if(type == 'q'){
            //take in 1 input
            int key;
            cin >> key;
            cout << fences[key] << endl;
        }
    }
}","Failed on case 2, test 0",TLE,C++17,2022-07-30 12:20:36.631603,20
104,untitled,1,1007,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

using namespace std;
 
struct node {
  int from, to;
  long long value, lazy;
  node *left, *right;
  node() {
    from=1;
    to=1e5;
    value=0;
    lazy=0;
    left=NULL;
    right=NULL;
  }
  void extend() {
    if(left==NULL) {
      left=new node();
      right=new node();
      left->from=from;
      left->to=(from+to)>>1;
      right->from=((from+to)>>1)+1;
      right->to=to;
    }
  }
};
 
void update_tree(node *curr, int left, int right, long long value) {
  if(curr->lazy) {
    curr->value=(curr->to-curr->from+1)*curr->lazy;
    if(curr->from!=curr->to) {
      curr->extend();
      curr->left->lazy=curr->lazy;
      curr->right->lazy=curr->lazy;
    }
    curr->lazy=0;
  }
  if((curr->from)>(curr->to) || (curr->from)>right || (curr->to)<left) return;
  if(curr->from>=left && curr->to<=right) {
    curr->value=(curr->to-curr->from+1)*value;
    if(curr->from!=curr->to) {
      curr->extend();
      curr->left->lazy=value;
      curr->right->lazy=value;
    }
    return;
  }
  curr->extend();
  update_tree(curr->left,left,right,value);
  update_tree(curr->right,left,right,value);
  curr->value=curr->left->value;
}
 
long long query_tree(node *curr, int left, int right) {
  if((curr->from)>(curr->to) || (curr->from)>right || (curr->to)<left) return 0;
  if(curr->lazy) {
    curr->value=(curr->to-curr->from+1)*curr->lazy;
    curr->extend();
    curr->left->lazy=curr->lazy;
    curr->right->lazy=curr->lazy;
    curr->lazy=0;
  }
  if(curr->from>=left && curr->to<=right) return curr->value;
  long long q1,q2;
  curr->extend();
  q1=query_tree(curr->left,left,right);
  q2=query_tree(curr->right,left,right);
  return q1+q2;
}

map<int, string> colors;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin.exceptions(cin.failbit);

    int n, q;
    cin >> n >> q;

    node* segtree = new node(); 
    colors[0] = ""white"";
    int colorIndex = 1;
    for(int i = 0; i < q; i++){
        string s;
        cin >> s;
        if(s == ""q"") {
            int index;
            cin >> index;
            int val = query_tree(segtree, index, index);
            cout << colors[val] << endl;
        }else{
            int l, r;
            string color;
            cin >> l >> r >> color;
            update_tree(segtree, l, r, colorIndex);
            colors[colorIndex] = color;
            colorIndex++;
            // for(int i = 0; i < 10; i++){
            //     cout << query_tree(segtree, i, i) << "" "";
            // }
            // cout << endl;
        }
    }
}","WA on case 4, test 0",WA,C++17,2022-07-30 12:21:40.936369,60
105,Albus,1,1007,"[n, q] = list(map(int, input().split()))
colors = [""white""]*n

for i in range(q):
    row = input().split()
    if row[0] == 'q':
        print(colors[int(row[1])])
    if row[0] == 'p':
        for j in range(int(row[1]), int(row[2]) + 1):
            colors[j] = row[3]

","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 7, in <module>
    print(colors[int(row[1])])
IndexError: list index out of range
",ERR,Python3,2022-07-30 12:24:14.241688,0
106,Albus,1,1007,"[n, q] = list(map(int, input().split()))
colors = [""white""]*n

for i in range(q):
    row = input().split()
    if row[0] == 'q':
        print(colors[int(row[1])])
    if row[0] == 'p':
        for j in range(int(row[1]), int(row[2]) + 1):
            colors[j] = row[3]

","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 7, in <module>
    print(colors[int(row[1])])
IndexError: list index out of range
",ERR,Python3,2022-07-30 12:24:31.110846,0
107,PinesCyrex,1,1006,"#include <iostream>
using namespace std;typedef int m;m i;char j;m main(){m n;cin >> n;string s(n-1, ' ');cout<<s<<"">\n"";cout<<s<<""|\n"";cout<<s<<"".\n"";for(;i<n-1;i++){for(j=0;j<n-i-2;j++){cout<<"" "";}for(j=64;j<i+66;j++) {if(j==64){cout<<""/"";continue;}cout<<j;}for(j=i+64;j>=64;j--){if(j==64){cout<<""\\"";continue;}cout<<j;}cout<<endl;}}","",AC,C++17,2022-07-30 12:25:30.669941,50
108,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(){
    //initialize map and iterator
    map<int, string> fences;
    
    //read the number of fences and queries
    long numFences;
    long numQueries;
    cin >> numFences >> numQueries;

    //insert all initial elements as white
    for (int i = 0; i < numFences; i++){
        fences.insert(make_pair((i + 1), ""white""));
    }

    //initialize all the variables needed
    char type;

    //take the input in a loop
    for(int i = 0; i < numQueries; i++){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            string color;
            cin >> start >> end;
            cin >> color;
            //modify the fences' colors
            for(int j = start; j <= end; j++){
                fences[j] = color;
            }
        }
        else if(type == 'q'){
            //take in 1 input
            int key;
            cin >> key;
            cout << fences[key] << endl;
        }
    }
}","Failed on case 2, test 0",TLE,C++17,2022-07-30 12:26:28.719107,20
109,untitled,1,1006,"a=""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";n=int(input());o="" ""*(n-1);print(o+'>\n'+o+'|\n'+o+'.')
for i in range(1,n):print(o[:-i]+'/'+a[:i]+(a[i-2::-1]if i>1 else'')+'\\')","",AC,Python3,2022-07-30 12:27:21.801074,50
127,PinesCyrex,1,1007,"#include <iostream>
int main() {
    int fenceCount;
    int qCount;
    std::cin >> fenceCount >> qCount;

    std::string fences[fenceCount];
    std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

    for (int i = 0; i < qCount; i++) {
        std::string qType;
        std::cin >> qType;
        if (qType == ""q"") {
            int retrieve;
            std::cin >> retrieve;
            std::cout << fences[retrieve - 1] << std::endl;
        } else {
            int first;
            int last;
            std::string color;
            std::cin >> first >> last >> color;
            for (int i = first - 1; i < last; i++) {
                fences[i] = color;
            }
        }
    }

    return 0;
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 12:49:06.313184,40
110,untitled,1,1007,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

using namespace std;
 
struct node {
  long long from, to;
  long long value, lazy;
  node *left, *right;
  node() {
    from=1;
    to=1e12;
    value=0;
    lazy=0;
    left=NULL;
    right=NULL;
  }
  void extend() {
    if(left==NULL) {
      left=new node();
      right=new node();
      left->from=from;
      left->to=(from+to)>>1;
      right->from=((from+to)>>1)+1;
      right->to=to;
    }
  }
};
 
void update_tree(node *curr, long long left, long long right, long long value) {
  if(curr->lazy) {
    curr->value=(curr->to-curr->from+1)*curr->lazy;
    if(curr->from!=curr->to) {
      curr->extend();
      curr->left->lazy=curr->lazy;
      curr->right->lazy=curr->lazy;
    }
    curr->lazy=0;
  }
  if((curr->from)>(curr->to) || (curr->from)>right || (curr->to)<left) return;
  if(curr->from>=left && curr->to<=right) {
    curr->value=(curr->to-curr->from+1)*value;
    if(curr->from!=curr->to) {
      curr->extend();
      curr->left->lazy=value;
      curr->right->lazy=value;
    }
    return;
  }
  curr->extend();
  update_tree(curr->left,left,right,value);
  update_tree(curr->right,left,right,value);
  curr->value=curr->left->value;
}
 
long long query_tree(node *curr, long long left, long long right) {
  if((curr->from)>(curr->to) || (curr->from)>right || (curr->to)<left) return 0;
  if(curr->lazy) {
    curr->value=(curr->to-curr->from+1)*curr->lazy;
    curr->extend();
    curr->left->lazy=curr->lazy;
    curr->right->lazy=curr->lazy;
    curr->lazy=0;
  }
  if(curr->from>=left && curr->to<=right) return curr->value;
  long long q1,q2;
  curr->extend();
  q1=query_tree(curr->left,left,right);
  q2=query_tree(curr->right,left,right);
  return q1+q2;
}

map<long long, string> colors;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin.exceptions(cin.failbit);

    int n, q;
    cin >> n >> q;

    node* segtree = new node(); 
    colors[0] = ""white"";
    int colorIndex = 1;
    for(int i = 0; i < q; i++){
        string s;
        cin >> s;
        if(s == ""q"") {
            long long index;
            cin >> index;
            long long val = query_tree(segtree, index, index);
            cout << colors[val] << endl;
        }else{
            long long l, r;
            string color;
            cin >> l >> r >> color;
            update_tree(segtree, l, r, colorIndex);
            colors[colorIndex] = color;
            colorIndex++;
            // for(int i = 0; i < 10; i++){
            //     cout << query_tree(segtree, i, i) << "" "";
            // }
            // cout << endl;
        }
    }
}","Failed on case 4, test 0",TLE,C++17,2022-07-30 12:27:59.152731,60
111,Albus,1,1007,"[n, q] = list(map(int, input().split()))
colors = [""white""]*n
ans = []
for i in range(q):
    row = input().split()
    if row[0] == 'q':
        ans.append(colors[int(row[1])])
    if row[0] == 'p':
        for j in range(int(row[1]), int(row[2]) + 1):
            colors[j] = row[3]
for i in range(len(ans)):
    print(ans[i])
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 7, in <module>
    ans.append(colors[int(row[1])])
IndexError: list index out of range
",ERR,Python3,2022-07-30 12:28:11.918198,0
112,TeamJin,1,1007,"#from datetime import datetime

nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]
#print(datetime.now())


# obj
#   a, b, col

# obj lst

#objlst search = O(n)



class node():
    def __init__(self, fir, sec, col):
        self.first = fir
        self.sec = sec
        self.col = col

nodeLst = []
for i in range(q):
    #print(""--------------------"")
    curLine =  input().split()
    #print(datetime.now())
    firstIndex = int(curLine[1]) - 1
    
    # p 2 4 black
    if curLine[0] == ""p"":
        secondIndex = int(curLine[2]) - 1
        nodeLst.append(node(firstIndex, secondIndex, curLine[3]))

    else:

        prBool = False
        for i in range(len(nodeLst)-1, -1, -1):
            if nodeLst[i].first <= firstIndex <= nodeLst[i].sec:
                print(nodeLst[i].col)
                prBool = True
                break

        if not prBool:
            print(""white"")","Failed on case 3, test 0",TLE,Python3,2022-07-30 12:28:23.850982,40
113,Albus,1,1007,"[n, q] = list(map(int, input().split()))
colors = [""white""]*n
ans = []
for i in range(q):
    row = input().split()
    if row[0] == 'q':
        ans.append(colors[int(row[1])-1])
    if row[0] == 'p':
        for j in range(int(row[1])-1, int(row[2])):
            colors[j] = row[3]
for i in range(len(ans)):
    print(ans[i])

","Failed on case 2, test 0",TLE,Python3,2022-07-30 12:31:31.17592,20
114,coffeepls,1,1006,"#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int main(){
    int n;
    cin>>n;
    string spc, ans;
    for (int i=0;i<n-1;++i)
        spc += "" "";
    cout<<spc+"">""<<endl;
    cout<<spc+""|""<<endl;
    cout<<spc+"".""<<endl;
    string sls=""/"";
    for (int i=2; i<n+1; ++i) {
        spc.pop_back();
        ans=spc+sls;
        string buf;
        for (int j=0;j<i-1;++j)
            buf+=char(65+j);
        ans+=buf;
        buf.pop_back();
        reverse(buf.begin(),buf.end());
        ans+=buf+char(92);
        cout<<ans<<endl;
    }
    return 0;
}","",AC,C++17,2022-07-30 12:34:23.427859,50
115,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(){
    //initialize map and iterator
    map<int, string> fences;

    //read the number of fences and queries
    long numFences;
    long numQueries;
    cin >> numFences >> numQueries;

    //insert all initial elements as white
    for (int i = 0; i < numFences; i++){
        fences.insert(make_pair((i + 1), ""white""));
    }

    //initialize all the variables needed
    char type;

    //take the input in a loop
    for(int i = 0; i < numQueries; i++){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            string color;
            cin >> start >> end;
            cin >> color;
            //modify the fences' colors
            for(int j = start; j <= end; j++){
                fences[j] = color;
            }
        }
        else if(type == 'q'){
            //take in 1 input
            int key;
            cin >> key;
            cout << fences[key] << endl;
        }
    }
}","Failed on case 2, test 0",TLE,C++17,2022-07-30 12:34:25.490867,20
116,NKSquared,1,1007,"

nums = list(map(int, input().split()))

fences = [""white""] * nums[0]
queries = []

print(fences)

for i in range(nums[1]):
    args = list(input().split())
    if(args[0] == 'p'):
        for i in range(int(args[1]), int(args[2]) + 1):
            fences[i - 1] = args[3]
    elif(args[0] == 'q'):
        queries.append(fences[int(args[1])-1])

for i in range(len(queries)):
    print(queries[i])

print(fences)","WA on case 0, test 0",WA,Python3,2022-07-30 12:34:53.652893,0
117,NKSquared,1,1007,"

nums = list(map(int, input().split()))

fences = [""white""] * nums[0]
queries = []

for i in range(nums[1]):
    args = list(input().split())
    if(args[0] == 'p'):
        for i in range(int(args[1]), int(args[2]) + 1):
            fences[i - 1] = args[3]
    elif(args[0] == 'q'):
        queries.append(fences[int(args[1])-1])

for i in range(len(queries)):
    print(queries[i])
","Failed on case 2, test 0",TLE,Python3,2022-07-30 12:35:22.545882,20
118,NKSquared,1,1007,"init = list(map(int, input().split()))
fence = [""white""] * init[0]
output = []
for x in range(init[1]):
    args = list(input().split())
    if (args[0] == ""q""):
        output.append(str(fence[int(args[1]) - 1]))
    if (args[0] == ""p""):
        for i in range(int(args[1]) - 1, int(args[2])):
            fence[i] = args[3]
print(fence)
for line in range(len(output)):
    print(output[line])","WA on case 0, test 0",WA,Python3,2022-07-30 12:37:11.196943,0
119,FuduBoys,1,1008,"# Import random module to generate random numbers
import random

# Take input from user
print('Enter a string to colorify:')
input_string = input() # Generally, variable names use underscores to separate words

# Making Python dictionary of key-value pairs, attributing numbers to ANSI escape
# colour codes
random_color_dict = {
    0 : '\u001b[31;1m', # Bright Red
    1 : '\u001b[32;1m', # Bright Green
    2 : '\u001b[34;1m', # Bright Blue
    3 : '\u001b[35;1m', # Bright Magenta
    4 : '\u001b[36;1m', # Bright Cyan
    5 : '\u001b[37;1m', # Bright White
    6 : '\u001b[41m', # Background Red
    7 : '\u001b[42m', # Background Green
    8 : '\u001b[44m', # Background Blue
    9 : '\u001b[45m', # Background Magenta
    10 : '\u001b[46m', # Background Cyan
}

# String to reset colour/background to default
reset = '\u001b[0m'

# Iterating through string and adding a randomnly generated colour for each character
coloured_char_list = [random_color_dict[random.randint(0, 10)] + char for char in input_string]

# Joining and printing list into string and reseting colour to default
print(''.join(coloured_char_list) + reset)
",Only your latest submission will be checked,AC,Python3,2022-07-30 12:38:40.702478,10
120,JavaScriptJatts,1,1007,"#include <bits/stdc++.h>

using namespace ::std;

int main() {
    int N;
    int Q;

    string option;
    int start;
    int end;

    int q;
    string color;

    cin >> N >> Q;

    vector<string> fence(N+1, ""white"");

    while(cin >> option){
        if(option == ""q""){
            cin >> q;
            cout << fence[q] << ""\n"";
        }

        else{
            cin >> start >> end >> color;
            for(int i = start; i <= end; i++){
                fence[i] = color;
            }
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 12:38:51.847874,40
121,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i<plank; i++){
        fences[i] = ""white"";
    }
    string out = """";
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.append(fences[n] + '\n');
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    cout << out;
}","WA on case 1, test 0",WA,C++17,2022-07-30 12:39:14.507656,0
122,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i<plank; i++){
        fences[i] = ""white"";
    }
    string out = """";
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.append(fences[n] + '\n');
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    cout << out;
    cout.flush();
}",,judging,C++17,2022-07-30 12:42:14.278728,0
123,YugoslaviaLover1992,1,1005,"// #include <stdio.h>
// #include <stdlib.h>
#include <iostream>
#include <iomanip>

using namespace std;

int main(int argc, char **argv) {


    int n, m;
    // get n -> number of elements in the list
    // get m -> number of parallel instructions
    cin >> n >> m;  
     
    // create empty list and fill it with indicies
    int indices[n];
    int i;
    for (i = 0; i < n; i++) {
        indices[i] = i;
    }

    // create a loop to query for element k
    int k = 1; // query size
    int judgeQueryResponse[k];

    cout << ""q "" << k << endl;
    bool found = false;
    int index;
    int smallest;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            cout << indices[i] << "" < "" << indices[j] << ""\n"";
            int validate;
            cin >> validate;
            if (validate == 0) { // false --> swap
                int temp = indices[i];
                indices[i] = indices[j];
                indices[j] = temp;
            } 
        }
    }



    
    // output answer
    cout << ""a"";
    for (int i = 0; i < n; i++) {
        cout << "" "" << indices[i];
    }
    
    return 0;  
}","WA on case 0, test 0",WA,C++17,2022-07-30 12:42:40.461156,0
124,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i<plank; i++){
        fences[i] = ""white"";
    }
    string out = """";
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.append(fences[n] + '\n');
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    cout << out;
    cout.flush();
}","WA on case 1, test 0",WA,C++17,2022-07-30 12:43:37.279241,0
125,theKevin27,1,1006,"#include <iostream>
#include <string>
using namespace std;int main(){int n;cin >> n;string w(n-1,32);cout<<w<<'<'<<endl<<w<<'|'<<endl<<w<<'.'<< endl;for(int i = 2;i<=n;i++){string s(n-i,32);string l=""/"";for(int j=-(i-2);j<=i-2;j++){l.push_back(65+(i-2)-abs(j));}l.push_back(92);cout<<s<<l<<endl;}}","",AC,C++17,2022-07-30 12:44:34.758183,50
126,duckduckdoo,1,1006,"n=gets.to_i
s=' '*n
puts""#{s}>\n#{s}|\n#{s}.""
(1...n).map{|i|
e=(i+64).chr
a=[*""A""...e].join
puts ""#{' '*(n-i)}/#{+a+e+a.reverse}\\""
}","",AC,Ruby,2022-07-30 12:47:12.980388,50
226,PinesCyrex,1,1007,"#include <iostream>
int main() {
int fenceCount;
int qCount;
std::cin >> fenceCount >> qCount;

std::string fences[fenceCount];
std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

for (int i = 0; i < qCount; i++) {
std::string qType;
std::cin >> qType;
if (qType == ""q"") {
int retrieve;
std::cin >> retrieve;
std::cout << fences[retrieve - 1] << std::endl;
} else if (qType == ""p"") {
int first;
int last;
std::string color;
std::cin >> first >> last >> color;
for (int i = first - 1; i < last; i++) {
fences[i] = color;
}
}
}

return 0;
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 14:31:35.396045,40
128,SoloGuy,1,1007,"from collections import OrderedDict
from turtle import color
n, q = tuple(map(int, input().strip().split(' ')))

fence = OrderedDict()
fence[(1, n)] = ""white""

for i in range(q):
    
    query = input().strip().split(' ')

    if query[0] == 'q':
        k = int(query[1])
        col = ""white""
        for key, val in fence.items():
            if key[0] <= k <= key[1]:
                col = val
        print(col)
    
    elif query[0] == 'p':
        _, lo, hi, col = query
        r = (int(lo), int(hi))
        
        if r in fence:
            del fence[r]
            fence[r] = color

        else:
            fence[r] = col


        
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 2, in <module>
    from turtle import color
  File ""/usr/lib/python3.10/turtle.py"", line 107, in <module>
    import tkinter as TK
ModuleNotFoundError: No module named 'tkinter'
",ERR,Python3,2022-07-30 12:50:53.871356,0
129,TeamJin,1,1007,"#from datetime import datetime

nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]


class node():
    def __init__(self, fir, sec, col):
        self.first = fir
        self.sec = sec
        self.col = col

nodeLst = []
#O(q)
for i in range(q):
    #print(""--------------------"")
    curLine =  input().split()
    #print(datetime.now())
    firstIndex = int(curLine[1]) - 1
    
    # p 2 4 black
    #O(1)
    if curLine[0] == ""p"":
        secondIndex = int(curLine[2]) - 1
        nodeLst.append(node(firstIndex, secondIndex, curLine[3]))

    #O(n)
    else:
        prBool = False
        #linear search
        for i in range(len(nodeLst)-1, -1, -1):
            if nodeLst[i].first <= firstIndex <= nodeLst[i].sec:
                print(nodeLst[i].col, flush=True)
                prBool = True
                break

        if not prBool:
            print(""white"", flush=True)

#O(n*q)





#node
    # range = [[]]
","Failed on case 3, test 0",TLE,Python3,2022-07-30 12:51:23.775986,40
130,YugoslaviaLover1992,1,1005,"#include <iostream>

using namespace std;

int main(int argc, char **argv) {


    int n, m;
    // get n -> number of elements in the list
    // get m -> number of parallel instructions
    cin >> n >> m;  
     
    // create empty list and fill it with indicies
    int indices[n];
    int i;
    for (i = 0; i < n; i++) {
        indices[i] = i;
    }

    // create a loop to query for element k
    int k = 1; // query size
    int judgeQueryResponse[k];

    cout << ""q "" << k << endl<< flush;
    bool found = false;
    int index;
    int smallest;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            cout << indices[i] << "" < "" << indices[j] << ""\n""<< flush;
            int validate;
            cin >> validate;
            if (validate == 0) { // false --> swap
                int temp = indices[i];
                indices[i] = indices[j];
                indices[j] = temp;
            } 
        }
    }



    
    // output answer
    cout << ""a"";
    for (int i = 0; i < n; i++) {
        cout << "" "" << indices[i]<< flush;
    }
    
    return 0;  
}
","WA on case 0, test 0",WA,C++17,2022-07-30 12:52:29.974843,0
131,Albus,1,1007,"[n, q] = list(map(int, input().split()))
colors = [""white""]*n
ans = []
for i in range(q):
    row = input().split()
    if row[0] == 'q':
        ans.append(colors[int(row[1])-1])
    if row[0] == 'p':
        for j in range(int(row[1])-1, int(row[2])):
            colors[j] = row[3]
for i in range(len(ans)):
    print(ans[i])

","Failed on case 3, test 0",TLE,Pypy3,2022-07-30 12:52:46.495676,40
141,YugoslaviaLover1992,1,1007,"#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct plank {
  int num;
  string col;
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i < n; i++) {
    plank p;
    p.num = i + 1;
    p.col = ""white"";
    // pushing p
    fence.push_back(p);
  }
  //  for (int i = 0; i < n; i++) {
  //   cout<<fence[i].num;
  //   cout<<fence[i].col << ""\n"";
  // }


  for (int i = 0; i < q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      string startIndstr = query.substr(2, 2);
      string endIndstr = query.substr(4, 4);

      int startInd = stoi(startIndstr) - 1;
      int endInd = stoi(endIndstr) - 1;

      string newCol = query.substr(6, query.length());

      for (startInd; startInd <= endInd; startInd++){
        fence[startInd].col = newCol;
      }
      
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, 2);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col;
    }
  }
}","WA on case 0, test 0",WA,C++17,2022-07-30 13:08:57.788142,0
143,YugoslaviaLover1992,1,1007,"#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct plank {
  int num;
  string col;
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i < n; i++) {
    plank p;
    p.num = i + 1;
    p.col = ""white"";
    // pushing p
    fence.push_back(p);
  }


  for (int i = 0; i < q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      string startIndstr = query.substr(2, 2);
      string endIndstr = query.substr(4, 4);

      int startInd = stoi(startIndstr) - 1;
      int endInd = stoi(endIndstr) - 1;

      string newCol = query.substr(6, query.length());

      for (startInd; startInd <= endInd; startInd++){
        fence[startInd].col = newCol;
      }
      
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, 2);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col << ""\n"";
    }
  }
}","WA on case 0, test 0",WA,C++17,2022-07-30 13:10:42.712192,0
227,FuduBoys,1,1006,"import os
import sys
os.system(""clear"")
r = int(input())
s="" ""

k=r-1

print(""""""%s>
%s|
%s."""""" % (s*k,s*k,s*k))
c1 = c = k = 0
l = r-2
for i in range(1, r):
 
  c=r-i-1
  print(""%s/"" % (s*l)),
  while k!=((2*i)-1):

    if c<=r-2:
      sys.stdout.write(chr(k+65))
      c+=1
    else:
      c1+=1
      sys.stdout.write(chr(k-(2*c1)+65))

    k+= 1
  c1 = c = k = 0
  l-=1
  print(""\\"")","",AC,Python2,2022-07-30 14:31:50.05576,50
132,coffeepls,1,1009,"#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define R(mul,shift,x,y) \
  _=x; \
  x -= mul*y>>shift; \
  y += mul*_>>shift; \
  _ = 3145728-x*x-y*y>>11; \
  x = x*_>>10; \
  y = y*_>>10;

int8_t b[1760], z[1760];

int main() {
  int sA=1024,cA=0,sB=1024,cB=0,_;
  for (;;) {
    memset(b, 32, 1760);  // text buffer
    memset(z, 127, 1760);   // z buffer
    int sj=0, cj=1024;
    for (int j = 0; j < 90; j++) {
      int si = 0, ci = 1024;  // sine and cosine of angle i
      for (int i = 0; i < 324; i++) {
        int R1 = 1, R2 = 2048, K2 = 5120*1024;

        int x0 = R1*cj + R2,
            x1 = ci*x0 >> 10,
            x2 = cA*sj >> 10,
            x3 = si*x0 >> 10,
            x4 = R1*x2 - (sA*x3 >> 10),
            x5 = sA*sj >> 10,
            x6 = K2 + R1*1024*x5 + cA*x3,
            x7 = cj*si >> 10,
            x = 40 + 30*(cB*x1 - sB*x4)/x6,
            y = 12 + 15*(cB*x4 + sB*x1)/x6,
            N = (-cA*x7 - cB*((-sA*x7>>10) + x2) - ci*(cj*sB >> 10) >> 10) - x5 >> 7;

        int o = x + 80 * y;
        int8_t zz = (x6-K2)>>15;
        if (22 > y && y > 0 && x > 0 && 80 > x && zz < z[o]) {
          z[o] = zz;
          b[o] = "".,-~:;=!*#$@""[N > 0 ? N : 0];
        }
        R(5, 8, ci, si)  // rotate i
      }
      R(9, 7, cj, sj)  // rotate j
    }
    for (int k = 0; 1761 > k; k++)
      putchar(k % 80 ? b[k] : 10);
    R(5, 7, cA, sA);
    R(5, 8, cB, sB);
    usleep(15000);
    printf(""\x1b[23A"");
  }
  return 0;
}",Only your latest submission will be checked,AC,C++17,2022-07-30 12:54:11.283318,10
133,HS,1,1006,"n = int(input())
    print(' '*(n-1)+"" >"")
    print(' '*(n-1)+"" |"")
    s = """"
    print(' '*(n-1)+"" ."")
    d = """"
    for i in range(0,n-1):
        d+=' '*((n-1)-i)
        s += '/'
        for j in range(0,i+1):
            s+= chr(j+65)
        if(i!=0):
            print(d+s+s[len(s)-2:0:-1]+'\ ')
        else:
            print(d+s+'\ ')
        s=""""
        d=""""",,judging,Python3,2022-07-30 12:57:24.417958,0
134,SoloGuy,1,1007,"from collections import OrderedDict
from turtle import color
n, q = tuple(map(int, input().strip().split(' ')))

fence = OrderedDict()
fence[(1, n)] = ""white""

for i in range(q):
    
    query = input().strip().split(' ')

    if query[0] == 'q':
        k = int(query[1])
        col = ""white""
        for key, val in fence.items():
            if key[0] <= k <= key[1]:
                col = val
        print(col)
    
    elif query[0] == 'p':
        _, lo, hi, col = query
        r = (int(lo), int(hi))
        
        if r in fence:
            del fence[r]
            fence[r] = color
        else:
            fence = {(a, b) : v for (a, b), v in fence.items() if not (r[0] <= a and r[1] >= b)}
            fence[r] = col


        
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 2, in <module>
    from turtle import color
  File ""/usr/lib/python3.10/turtle.py"", line 107, in <module>
    import tkinter as TK
ModuleNotFoundError: No module named 'tkinter'
",ERR,Python3,2022-07-30 12:57:57.738282,0
135,NKSquared,1,1008,"#include <bits/stdc++.h>
#define WIDTH 10

// Initialize a buffer for strings inputted by the user

std::vector<std::string> buffer {""empty"", ""empty""};

// Initialize a string for each string inputted by the user

std::string yourName;

int main()
{
    std::cout << ""Please enter your full name: "";
    std::getline (std::cin, yourName);
    std::cout << std::setw(WIDTH) << ""Hello "" << yourName << ""!!  So nice to meet you."" << std::endl;
    return 0;
}
",Only your latest submission will be checked,AC,C++17,2022-07-30 12:58:02.210211,10
136,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i < plank; i++){
        fences[i] = ""white"";
    }
    string out = """";
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.append(fences[n] + '\n');
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    cout << out;
}","WA on case 1, test 0",WA,C++20,2022-07-30 13:01:33.118914,0
137,HS,1,1006,"n = int(input())
    print(' '*(n-1)+"" >"")
    print(' '*(n-1)+"" |"")
    s = """"
    print(' '*(n-1)+"" ."")
    d = """"
    for i in range(0,n-1):
        d+=' '*((n-1)-i)
        s += '/'
        for j in range(0,i+1):
            s+= chr(j+65)
        if(i!=0):
            print(d+s+s[len(s)-2:0:-1]+'\ ')
        else:
            print(d+s+'\ ')
        s=""""
        d=""""","/code/Main.cpp:13:40: warning: unknown escape sequence: '\040'
   13 |             print(d+s+s[len(s)-2:0:-1]+'\ ')
      |                                        ^~~~
/code/Main.cpp:15:23: warning: unknown escape sequence: '\040'
   15 |             print(d+s+'\ ')
      |                       ^~~~
/code/Main.cpp:1:1: error: ‘n’ does not name a type
    1 | n = int(input())
      | ^
",CERR,C++17,2022-07-30 13:02:14.673868,0
138,coffeepls,1,1006,"n=int(input())
s=' '*(n-1)
print(s+'>')
print(s+'|')
print(s+'.')
l='/'
a=''
for i in range(2,n+1):
    s=s[:-1]
    a=s+l
    b=''
    for j in range(i-1):
        b+=chr(65+j)
    a+=b
    b=b[:-1]
    b=b[::-1]
    a+=b+chr(92)
    print(a)","",AC,Python3,2022-07-30 13:06:41.998187,50
139,HS,1,1006,"n = int(input())
    print(' '*(n-1)+"" >"")
    print(' '*(n-1)+"" |"")
    s = """"
    print(' '*(n-1)+"" ."")
    d = """"
    for i in range(0,n-1):
        d+=' '*((n-1)-i)
        s += '/'
        for j in range(0,i+1):
            s+= chr(j+65)
        if(i!=0):
            print(d+s+s[len(s)-2:0:-1]+'\\')
        else:
            print(d+s+'\\')
        s=""""
        d=""""","/code/Main.cpp:1:1: error: ‘n’ does not name a type
    1 | n = int(input())
      | ^
",CERR,C++17,2022-07-30 13:07:50.527303,0
140,Dragoneel,1,1004,"n = int(input())
nums = list(map(int, input().split()))

# Do calculations
ans = sum(nums)

print(ans)","",AC,Python3,2022-07-30 13:08:05.932295,100
144,YugoslaviaLover1992,1,1007,"#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct plank {
  int num;
  string col;
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i < n; i++) {
    plank p;
    p.num = i + 1;
    p.col = ""white"";
    // pushing p
    fence.push_back(p);
  }


  for (int i = 0; i < q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      string startIndstr = query.substr(2, 2);
      string endIndstr = query.substr(4, 4);

      int startInd = stoi(startIndstr) - 1;
      int endInd = stoi(endIndstr) - 1;

      string newCol = query.substr(6, query.length());

      for (startInd; startInd <= endInd; startInd++){
        fence[startInd].col = newCol;
      }
      
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, 2);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col << ""\n"";
    }
  }
}","WA on case 0, test 0",WA,C++23,2022-07-30 13:10:51.167153,0
145,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i < plank; i++){
        fences[i] = ""white"";
    }
    vector<string> out;
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.push_back(fences[n]);
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    for(const auto i: out){
        cout << i << endl;
        cout.flush();
    }
}","WA on case 1, test 0",WA,C++17,2022-07-30 13:11:20.391892,0
146,HS,1,1006,"n = int(input())
    print(' '*(n-1)+"">"")
    print(' '*(n-1)+""|"")
    s = """"
    print(' '*(n-1)+""."")
    d = """"
    for i in range(0,n-1):
        d+=' '*((n-2)-i)
        s += '/'
        for j in range(0,i+1):
            s+= chr(j+65)
        if(i!=0):
            print(d+s+s[len(s)-2:0:-1]+'\\')
        else:
            print(d+s+'\\')
        s=""""
        d=""""","Error with code 1:
  File ""/code/Main.py"", line 2
    print(' '*(n-1)+"">"")
IndentationError: unexpected indent
",ERR,Python3,2022-07-30 13:11:28.43591,0
147,HS,1,1006,"n = int(input())
    print(' '*(n-1)+"">"")
    print(' '*(n-1)+""|"")
    s = """"
    print(' '*(n-1)+""."")
    d = """"
    for i in range(0,n-1):
        d+=' '*((n-2)-i)
        s += '/'
        for j in range(0,i+1):
            s+= chr(j+65)
        if(i!=0):
            print(d+s+s[len(s)-2:0:-1]+'\\')
        else:
            print(d+s+'\\')
        s=""""
        d=""""","Error with code 1:
  File ""/code/Main.py"", line 2
    print(' '*(n-1)+"">"")
    ^
IndentationError: unexpected indent
",ERR,Python2,2022-07-30 13:11:49.601737,0
148,YugoslaviaLover1992,1,1007,"#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct plank {
  int num;
  string col;
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i < n; i++) {
    plank p;
    p.num = i + 1;
    p.col = ""white"";
    // pushing p
    fence.push_back(p);
  }


  for (int i = 0; i <= q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      string startIndstr = query.substr(2, 2);
      string endIndstr = query.substr(4, 4);

      int startInd = stoi(startIndstr) - 1;
      int endInd = stoi(endIndstr) - 1;

      string newCol = query.substr(6, query.length());

      for (startInd; startInd <= endInd; startInd++){
        fence[startInd].col = newCol;
      }
      
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, 2);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col << ""\n"";
    }
  }
}","WA on case 1, test 0",WA,C++17,2022-07-30 13:12:20.036467,0
149,coffeepls,1,1006,"n=int(input())
s=' '*(n-1)
print(s+'>\n'+s+'|\n'+s+'.')
for i in range(2,n+1):
    s=s[:-1]
    a=s+'/'
    b=''
    for j in range(i-1): 
        b+=chr(65+j)
    a+=b+b[:-1][::-1]+chr(92)
    print(a)","",AC,Python3,2022-07-30 13:13:28.728638,50
150,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cin >> plank; 
    cin >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i < plank; i++){
        fences[i] = ""white"";
    }
    vector<string> out;
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.push_back(fences[n]);
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start;
            cin >> end;
            cin >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    for(const auto i: out){
        cout << i << endl;
        cout.flush();
    }
}","WA on case 1, test 0",WA,C++17,2022-07-30 13:14:07.819493,0
151,PinesCyrex,1,1009,"import time
import random

width = 80
height = 24

# create a list of lists to represent the screen
screen = []
for row in range(height):
    screen.append([])
    for col in range(width):
        screen[row].append(' ')

frame_count = 0

class Ball:
    ball_row, ball_col, ball_dir_row, ball_dir_col = 0, 0, 0, 0

    def create_ball(self):
        #randomly generate ball position and direction
        self.ball_row = random.randint(1, height - 2)
        self.ball_col = random.randint(1, width - 2)

        self.ball_dir_row = random.choice([-1, 1])
        self.ball_dir_col = random.choice([-1, 1])

    def move_ball(self):
        self.ball_row += self.ball_dir_row
        self.ball_col += self.ball_dir_col
        if self.ball_row == 0 or self.ball_row == height - 1:
            self.ball_dir_row *= -1
        if self.ball_col == 0 or self.ball_col == width - 1:
            self.ball_dir_col *= -1

        # apply gravity
        self.ball_dir_row += 0.05
        self.ball_dir_col += 0.05

        #check collision
        # round ball position to int
        if screen[self.ball_row][self.ball_col] == 'O':
            self.ball_dir_row *= -1
            self.ball_dir_col *= -1

    def draw_ball(self):
        screen[self.ball_row][self.ball_col] = 'O'

def update_screen():
    global frame_count
    for row in range(height):
        for col in range(width):
            print(screen[row][col], end='')
        print()
    print('Frame:', frame_count)
    print()
    frame_count += 1
    for row in range(height):
        for col in range(width):
            screen[row][col] = ' '


def main():
    # create 3 balls
    ball1 = Ball()
    ball2 = Ball()
    ball3 = Ball()

    ball1.create_ball()
    ball2.create_ball()
    ball3.create_ball()

    while True:
        ball1.move_ball()
        ball1.draw_ball()

        ball2.move_ball()
        ball2.draw_ball()

        ball3.move_ball()
        ball3.draw_ball()

        update_screen()

        time.sleep(0.016666)
        if frame_count == 500:
            break

main()",Only your latest submission will be checked,AC,Python3,2022-07-30 13:15:10.144223,10
152,coffeepls,1,1006,"n=int(input())
s=' '*(n-1)
print(s+'>\n'+s+'|\n'+s+'.')
for i in range(2,n+1):
    s=s[:-1]
    b=''
    for j in range(i-1): 
        b+=chr(65+j)
    a=s+'/'+b+b[:-1][::-1]+chr(92)
    print(a)","",AC,Python3,2022-07-30 13:15:51.381395,50
153,duckduckdoo,1,1006,"n=int(input())
s=' '*n
print(s+'>\n'+s+'|\n'+s+""."")
for i in range(1,n):
  e=i+64
  a=''.join([chr(x) for x in range(65,e)])
  print(' '*(n-i)+'/'+a+chr(e)+a[::-1]+'\\')","",AC,Python3,2022-07-30 13:15:56.266239,50
154,rvijayar,1,1006,"#include<iostream>
#define u(x)putchar(x);
#define r(x,a)for(x=0;x<a;x++)
int main(){int i,j,n;char A=65,c[]{"">|.""};std::cin>>n;n--;r(i,3){r(j,n)u(32)u(c[i])u(10)}r(i,n){r(j,n-i-1)u(32)u(47)r(j,i)u(A++)u(A)r(j,i)u(--A)u(92)u(10)}}","",AC,C++17,2022-07-30 13:16:28.907607,50
156,YugoslaviaLover1992,1,1007,"#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct plank {
  int num;
  string col;
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i < n; i++) {
    plank p;
    p.num = i + 1;
    p.col = ""white"";
    // pushing p
    fence.push_back(p);
  }


  for (int i = 0; i <= q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      string startIndstr = query.substr(2, 2);
      string endIndstr = query.substr(4, 4);

      int startInd = stoi(startIndstr) - 1;
      int endInd = stoi(endIndstr) - 1;

      string newCol = query.substr(6, query.length());

      for (startInd; startInd <= endInd; startInd++){
        fence[startInd].col = newCol;
      }
      
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, 2);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col << ""\n"";
    }
  }
}","WA on case 1, test 0",WA,C++17,2022-07-30 13:19:54.661389,0
157,YugoslaviaLover1992,1,1007,"#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct plank {
  int num;
  string col;
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i <= n; i++) {
    plank p;
    p.num = i + 1;
    p.col = ""white"";
    // pushing p
    fence.push_back(p);
  }


  for (int i = 0; i <= q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      string startIndstr = query.substr(2, 2);
      string endIndstr = query.substr(4, 4);

      int startInd = stoi(startIndstr) - 1;
      int endInd = stoi(endIndstr) - 1;

      string newCol = query.substr(6, query.length());

      for (startInd; startInd <= endInd; startInd++){
        fence[startInd].col = newCol;
      }
      
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, 2);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col << ""\n"";
    }
  }
}","WA on case 1, test 0",WA,C++17,2022-07-30 13:22:33.688788,0
158,rvijayar,1,1006,"#include<stdio.h>
#define u(x)putchar(x);
#define r(x,a)for(x=0;x<a;x++)
int main(){char i,j,n,A=65,c[]{"">|.""};scanf(""%hd"",&n);n--;r(i,3){r(j,n)u(32)u(c[i])u(10)}r(i,n){r(j,n-i-1)u(32)u(47)r(j,i)u(A++)u(A)r(j,i)u(--A)u(92)u(10)}}","",AC,C++17,2022-07-30 13:23:38.027414,50
179,theKevin27,1,1005,"#include <iostream>
#include <string>
#include <vector>

int main() {
int n;
std::cin >> n; // N
if (n < 2 || n > 1000) {
std::cout << ""Error: Wrong amount of numbers"" << std::endl;
return 0;
}
std::string nums; //""a""
std::cin.ignore();
std::getline(std::cin, nums);
std::vector<int> numArray;
int index = 0;
int length = 1;
for (int i = 0; i < nums.size(); i++) {
if (isspace(nums.at(i))) {
int number = stoi(nums.substr(index, length));
if (number < 1 || number > 100000) {
std::cout << ""Error: Numbers wrong size"" << std::endl;
return 0;
}
numArray.push_back(number);
length = -1;
index = i + 1;
}
length++;
}
int number = stoi(nums.substr(index, nums.length() - index));
if (number < 1 || number > 100000) {
std::cout << ""Error: Numbers wrong size"" << std::endl;
return 0;
}
numArray.push_back(number);
int total = 0;
for (int i = 0; i < numArray.size(); i++) {
total += numArray[i];
}
std::cout << ""Sum: "" << total << std::endl;
return 1;
}","WA on case 2, test 0",WA,C++17,2022-07-30 13:51:57.073908,70
180,PinesCyrex,1,1007,"#include <iostream>
#include <map>
#include <typeinfo>
using namespace std;
int main() {
    int fenceCount;
    int qCount;
    cin >> fenceCount >> qCount;

    map<int, string> fenceMap;
    fenceMap.insert(pair<int, string>(0, ""white""));
    int* fences = (int*)malloc(fenceCount * sizeof(int));
    //std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

    int counter = 1;
    for (int i = 0; i < qCount; i++) {
        string qType;
        cin >> qType;
        if (qType == ""q"") {
            int retrieve;
            cin >> retrieve;
            auto it = fenceMap.find(fences[retrieve - 1]);
            string result = it->second;
            cout << result << endl;
        } else {
            int first;
            int last;
            string color;
            cin >> first >> last >> color;
            fenceMap.insert(pair<int, string>(counter, color));
            for (int i = first - 1; i < last; i++) {
                fences[i] = counter;
            }
            counter++;
        }
    }

    return 0;
}",Resource temporarily unavailable,ERR,C++17,2022-07-30 13:52:05.721029,60
181,FuduBoys,1,1007,"nums = list(map(int, input().split()))
planks = ['white'] * nums[0]

for i in range(nums[1]):
    query = input()
    if query[0] == 'p':
        for j in range(int(query[2]), int(query[4]) + 1):
            planks[j] = query[6:]
    else:
        print(planks[int(query[2])])
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 7, in <module>
    for j in range(int(query[2]), int(query[4]) + 1):
ValueError: invalid literal for int() with base 10: ' '
",ERR,Python3,2022-07-30 13:52:35.063983,0
189,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

int main(){
    //initialize map and iterator
    unordered_map<int, string> fences;

    //read the number of fences and queries
    long numFences;
    long numQueries;
    cin >> numFences >> numQueries;

    //insert all initial elements as white
    for (int i = 0; i < numFences; i++){
        fences[i+1] = ""white"";
    }

    //initialize all the variables needed
    char type;

    //take the input in a loop
    for(int i = 0; i < numQueries; i++){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            string color;
            cin >> start >> end;
            cin >> color;
            //modify the fences' colors
            for(int j = start; j <= end; j++){
                fences.at(j) = color;
            }
        }
        else if(type == 'q'){
            //take in 1 input
            int key;
            cin >> key;
            cout << fences.at(key) << endl;
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 13:57:42.451526,40
159,coffeepls,1,1009,"#include <iostream>
#include <cstdint>
#include <cstring>
#include <unistd.h>
using namespace std;

#define R(mul,shift,x,y) \
  _=x; \
  x -= mul*y>>shift; \
  y += mul*_>>shift; \
  _ = 3145728-x*x-y*y>>11; \
  x = x*_>>10; \
  y = y*_>>10;

int8_t b[1760], z[1760];

int main() {
  int sA=1024,cA=0,sB=1024,cB=0,_;
  for (;;) {
    memset(b, 32, 1760);  // text buffer
    memset(z, 127, 1760);   // z buffer
    int sj=0, cj=1024;
    for (int j = 0; j < 90; j++) {
      int si = 0, ci = 1024;  // sine and cosine of angle i
      for (int i = 0; i < 324; i++) {
        int R1 = 1, R2 = 2048, K2 = 5120*1024;

        int x0 = R1*cj + R2,
            x1 = ci*x0 >> 10,
            x2 = cA*sj >> 10,
            x3 = si*x0 >> 10,
            x4 = R1*x2 - (sA*x3 >> 10),
            x5 = sA*sj >> 10,
            x6 = K2 + R1*1024*x5 + cA*x3,
            x7 = cj*si >> 10,
            x = 40 + 30*(cB*x1 - sB*x4)/x6,
            y = 12 + 15*(cB*x4 + sB*x1)/x6,
            N = (-cA*x7 - cB*((-sA*x7>>10) + x2) - ci*(cj*sB >> 10) >> 10) - x5 >> 7;

        int o = x + 80 * y;
        int8_t zz = (x6-K2)>>15;
        if (22 > y && y > 0 && x > 0 && 80 > x && zz < z[o]) {
          z[o] = zz;
          b[o] = "".,-~:;=!*#$@""[N > 0 ? N : 0];
        }
        R(5, 8, ci, si)  // rotate i
      }
      R(9, 7, cj, sj)  // rotate j
    }
    for (int k = 0; 1761 > k; k++)
      putchar(k % 80 ? b[k] : 10);
    R(5, 7, cA, sA);
    R(5, 8, cB, sB);
    usleep(15000);
    cout << ""\x1b[23A"" << endl;
  }
  return 0;
}",Only your latest submission will be checked,AC,C++17,2022-07-30 13:24:00.271836,10
160,untitled,1,1007,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

map<int, string> colors;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin.exceptions(cin.failbit);

    int n, q;
    cin >> n >> q;

    set<pair<long long,int>> pos;
    pos.insert({0, 0});
    colors[0] = ""white"";
    int colorIndex = 1;
    for(int i = 0; i < q; i++){
        string s;
        cin >> s;
        if(s == ""q"") {
            long long index;
            cin >> index;
            // for(auto it = pos.begin(); it != pos.end(); it++){
            //     cout << ""("" << it->first << "", "" << it->second << ""), "";
            // }
            // cout << endl;
            auto val = pos.lower_bound({-index, 0});
            cout << colors[val->second] << endl;
        }else{
            long long l, r;
            string color;
            cin >> l >> r >> color;
            colors[colorIndex] = color;
            int continueColor = pos.lower_bound({-(r+1), 0})->second;
            auto it = pos.lower_bound({-r, 0});
            while(it != pos.end() && it->first <= -l) {
                pos.erase(it++);
            }
            pos.insert({-l, colorIndex});
            pos.insert({-(r+1), continueColor});
            colorIndex++;
        }
    }
}","Failed on case 5, test 0",TLE,C++17,2022-07-30 13:26:50.63822,80
161,Albus,1,1005,"import functools

def compare(a, b):
    print('q', 1)
    print(a, "" < "", b)
    q = int(input())
    if q == 1:
        return -1
    else:
        print('q', 1)
        print(a, "" > "", b)
        q = int(input())
        if q == 1:
            return 1
        else:
            return 0  

[n, m] = list(map(int, input().split()))

# print(compare(1,2))

idx = list(range(n))
idx.sort(key=functools.cmp_to_key(compare))

print(""a"", *idx, sep="" "")

","WA on case 1, test 1","",Pypy3,2022-07-30 13:27:45.656674,30
162,untitled,1,1007,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

map<int, string> colors;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin.exceptions(cin.failbit);

    int n, q;
    cin >> n >> q;

    set<pair<int,int>> pos;
    pos.insert({0, 0});
    colors[0] = ""white"";
    int colorIndex = 1;
    for(int i = 0; i < q; i++){
        string s;
        cin >> s;
        if(s == ""q"") {
            int index;
            cin >> index;
            // for(auto it = pos.begin(); it != pos.end(); it++){
            //     cout << ""("" << it->first << "", "" << it->second << ""), "";
            // }
            // cout << endl;
            auto val = pos.lower_bound({-index, 0});
            cout << colors[val->second] << endl;
        }else{
            int l, r;
            string color;
            cin >> l >> r >> color;
            colors[colorIndex] = color;
            int continueColor = pos.lower_bound({-(r+1), 0})->second;
            auto it = pos.lower_bound({-r, 0});
            while(it != pos.end() && it->first <= -l) {
                pos.erase(it++);
            }
            pos.insert({-l, colorIndex});
            pos.insert({-(r+1), continueColor});
            colorIndex++;
        }
    }
}","Failed on case 5, test 0",TLE,C++17,2022-07-30 13:28:29.412476,80
163,rvijayar,1,1006,"#include<stdio.h>
#define u(x)putchar(x);
#define r(x,a)for(x=1;x<a;x++)
int main(){char i,j,n,A=65,c[]{"" >|.""};scanf(""%hd"",&n);r(i,4){r(j,n)u(32)u(c[i])u(10)}r(i,n){r(j,n-i)u(32)u(47)r(j,i)u(A++)u(A)r(j,i)u(--A)u(92)u(10)}}","",AC,C++17,2022-07-30 13:29:10.462628,50
164,HS,1,1006,"def moutain_mad():
    n = int(input())
    print(' '*(n-1)+"">"")
    print(' '*(n-1)+""|"")
    s = """"
    print(' '*(n-1)+""."")
    for i in range(0,n-1):
        s += '/'
        for j in range(0,i+1):
            s+= chr(j+65)
        if(i!=0):
            print(' '*((n-2)-i)+s+s[len(s)-2:0:-1]+'\\')
        else:
            print(' '*((n-2)-i)+s+'\\')
        s=""""
        
        

moutain_mad()","",AC,Python3,2022-07-30 13:33:09.157751,50
165,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i < plank; i++){
        fences[i] = ""white"";
    }
    vector<string> out;
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            cout << fences[n];
            // out.push_back(fences[n]);
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    // for(const auto i: out){
    //     cout << i << endl;
    //     cout.flush();
    // }
}","WA on case 0, test 0",WA,C++17,2022-07-30 13:36:27.150836,0
190,theKevin27,1,1005,"#include <iostream>
#include <string>
#include <vector>

int main() {
int n;
std::cin >> n; // N
if (n < 2 || n > 1000) {
return 0;
}
std::string nums; //""a""
std::cin.ignore();
std::getline(std::cin, nums);
std::vector<int> numArray;
int index = 0;
int length = 1;
for (int i = 0; i < nums.size(); i++) {
if (isspace(nums.at(i))) {
int number = stoi(nums.substr(index, length));
if (number < 1 || number > 100000) {
return 0;
}
numArray.push_back(number);
length = -1;
index = i + 1;
}
length++;
}
int number = stoi(nums.substr(index, nums.length() - index));
if (number < 1 || number > 100000) {
return 0;
}
numArray.push_back(number);
int total = 0;
for (int i = 0; i < numArray.size(); i++) {
total += numArray[i];
}
std::cout << total << std::endl;
return 1;
}","WA on case 0, test 0","",C++17,2022-07-30 13:57:46.763985,0
166,untitled,1,1007,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

map<int, string> colors;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin.exceptions(cin.failbit);

    int n, q;
    cin >> n >> q;

    set<int> pos;
    pos.insert(0);
    colors[0] = ""white"";
    int colorIndex = 1;
    for(int i = 0; i < q; i++){
        string s;
        cin >> s;
        if(s == ""q"") {
            int index;
            cin >> index;
            // for(auto it = pos.begin(); it != pos.end(); it++){
            //     cout << ""("" << it->first << "", "" << it->second << ""), "";
            // }
            // cout << endl;
            int val = *(pos.lower_bound(-index));
            cout << colors[val] << endl;
        }else{
            int l, r;
            string color;
            cin >> l >> r >> color;
            colors[colorIndex] = color;
            string continueColor = colors[*(pos.lower_bound(-(r+1)))];
            auto it = pos.lower_bound(-r);
            while(it != pos.end() && *it <= -l) {
                pos.erase(it++);
            }
            pos.insert(-l);
            pos.insert({-l, colorIndex});
            colors[-l] = color;
            pos.insert(-(r+1));
            colors[-(r+1)] = continueColor;
            colorIndex++;
        }
    }
}","Failed on case 5, test 0",TLE,C++17,2022-07-30 13:37:44.761981,80
167,TeamJin,1,1006,"

n=int(input())

"""""" def recur(inp):
    if not inp:return ('A' + n)

    res = recur(inp-1)

    print(ord(res[0])-1)
    mchar = chr(ord(res[0])-1)

    return mchar + res + mchar


for i in range(n):
    
    print((n-i)*"" "" + ""/"" + recur(n) + ""\\"") """"""

print((n+1)*"" "" + "">"")
print((n+1)*"" "" + ""|"")
print((n+1)*"" "" + ""."")
for i in range(n):
    st = chr(i + 65)
    for j in range(i-1, -1, -1):
        st = chr(j + 65) + st + chr(j + 65)
    print((n-i)*"" "" + ""/"" + st + ""\\"")
","",AC,Python3,2022-07-30 13:38:53.209525,50
168,FuduBoys,1,1006,"r = int(input())
s="" ""*(r-3)
print(s,"" >\n"",s,""|\n"",s,""."")
c1 = c = k = 0
for i in range(1, r):
  for a in range(1, (r-i)):
    print("" "", end="""")
    c+=1
  print(""/"", end="""")
  while k!=((2*i)-1):
      if c<=r-2:
        print(chr(k+65), end="""")
        c+=1
      else:
        c1+=1
        print(chr(k-(2*c1)+65), end="""")
      k+= 1
  c1 = c = k = 0
  print(""\\"")","",AC,Python3,2022-07-30 13:41:25.437332,50
169,TeamJin,1,1006,"n=int(input())
print((n+1)*"" ""+"">\n""+(n+1)*"" ""+""|\n""+(n+1)*"" ""+""."")
for i in range(n):
    s=chr(i+65)
    for j in range(i-1,-1,-1):
        s=chr(j+65)+s+chr(j+65)
    print((n-i)*"" ""+""/""+s+""\\"")
","",AC,Python3,2022-07-30 13:41:39.8948,50
170,YugoslaviaLover1992,1,1007,"#include <iostream>
#include <string>
#include <vector>
#include<sstream>

using namespace std;

struct plank {
  int num;
  string col;
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i <= n; i++) {
    plank p;
    p.num = i + 1;
    p.col = ""white"";
    // pushing p
    fence.push_back(p);
  }

  for (int i = 0; i <= q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      int startInd, endInd;

      int counter = 0;
      
      istringstream iss(query);
    
      string word, newCol;
    
      while(iss >> word) {  
        if (counter == 1){
          startInd = stoi(word) - 1;
        }
        else if (counter == 2){
          endInd = stoi(word) - 1;
        }
        else if (counter == 3){
          newCol = word;
        } 
        counter ++;
      }

      for (startInd; startInd <= endInd; startInd++){
        fence[startInd].col = newCol;
      }
      
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, query.length()-1);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col << ""\n"";
    }
  }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 13:41:40.074993,40
204,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i < plank; i++){
        fences[i] = ""white"";
    }
    vector<string> out;
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.push_back(fences[n]);
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    for(const auto i: out){
        cout << i << endl;
        cout.flush();
    }
}","WA on case 1, test 0",WA,C++17,2022-07-30 14:10:40.328106,0
228,FuduBoys,1,1007,"nums = list(map(int, input().split()))
planks = {}
for i in range(nums[0]):
    planks[i] = 'white'

for i in range(nums[1]):
    query = input().split()
    if query[0] == 'p':
        for j in range(int(query[1]) - 1, int(query[2])):
            planks[j] = query[3]
    else:
        print(planks[int(query[1]) - 1])
","Failed on case 2, test 0",TLE,Python3,2022-07-30 14:32:27.607882,20
232,Albus,1,1005,"import functools

def merge(arr, n, k):
    quaries = [""""]*k
    for i in range(k):
        quaries[i] = str(arr[2*i]) + "" < "" + str(arr[2*i + 1])
    print('q', k)
    for q in quaries:
        print(q)
    ans = [""""] * k
    for i in range(k):
        ans[i] = int(input())
    print(""ans"", ans)
    for i in range(k):
        if ans[i] == 0:
            arr[2*i], arr[2*i+1] = arr[2*i+1], arr[2*i]
    
    return arr

def compare(a, b):
    print('q', 1)
    print(a, "" < "", b)
    q = int(input())
    if q == 1:
        return -1
    else:
        return 1
        # print('q', 1)
        # print(a, "" > "", b)
        # q = int(input())
        # if q == 1:
        #     return 1
        # else:
        #     return 0  

[n, m] = list(map(int, input().split()))

idx = list(range(n))
idx = merge(idx, n, n//2)
idx.sort(key=functools.cmp_to_key(compare))
print(""a"", *idx, sep="" "")
","WA on case 0, test 0","",Pypy3,2022-07-30 14:37:47.702305,0
171,YugoslaviaLover1992,1,1007,"#include <iostream>
#include <string>
#include <vector>
#include<sstream>

using namespace std;

struct plank {
  int num;
  string col;
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i <= n; i++) {
    plank p;
    p.num = i + 1;
    p.col = ""white"";
    // pushing p
    fence.push_back(p);
  }

  for (int i = 0; i <= q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      int startInd, endInd;
      string word, newCol;
      istringstream iss(query);
    
      iss >> word;  
      startInd = stoi(word) - 1;
      iss >> word;  
      endInd = stoi(word) - 1;
      iss >> word;        
      newCol = word;

      for (startInd; startInd <= endInd; startInd++){
        fence[startInd].col = newCol;
      }
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, query.length()-1);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col << ""\n"";
    }
  }
}",No such device or address,ERR,C++17,2022-07-30 13:43:47.250431,0
172,theKevin27,1,1005,"#include <iostream>
#include <string>
#include <vector>

int main() {
  int n;
  std::cin >> n; // N
  if (n < 2 || n > 100) {
    std::cout << ""Error: Wrong amount of numbers"" << std::endl;
    return 0;
  }
  std::string nums; //""a""
  std::cin.ignore();
  std::getline(std::cin, nums);
  std::vector<int> numArray;
  int index = 0;
  int length = 1;
  for (int i = 0; i < nums.size(); i++) {
    if (isspace(nums.at(i))) {
      int number = stoi(nums.substr(index, length));
      if (number < 1 || number > 100000) {
        std::cout << ""Error: Numbers wrong size"" << std::endl;
        return 0;
      }
      numArray.push_back(number);
      length = -1;
      index = i + 1;
    }
    length++;
  }
  int number = stoi(nums.substr(index, nums.length() - index));
  if (number < 1 || number > 100000) {
    std::cout << ""Error: Numbers wrong size"" << std::endl;
    return 0;
  }
  numArray.push_back(number);
  int total = 0;
  for (int i = 0; i < numArray.size(); i++) {
    total += numArray[i];
  }
  std::cout << ""Sum: "" << total << std::endl;
  return 1;
}
","WA on case 2, test 0","",C++17,2022-07-30 13:44:20.378564,70
173,theKevin27,1,1004,"#include <iostream>
#include <string>
#include <vector>

int main() {
  int n;
  std::cin >> n; // N
  if (n < 2 || n > 100) {
    std::cout << ""Error: Wrong amount of numbers"" << std::endl;
    return 0;
  }
  std::string nums; //""a""
  std::cin.ignore();
  std::getline(std::cin, nums);
  std::vector<int> numArray;
  int index = 0;
  int length = 1;
  for (int i = 0; i < nums.size(); i++) {
    if (isspace(nums.at(i))) {
      int number = stoi(nums.substr(index, length));
      if (number < 1 || number > 100000) {
        std::cout << ""Error: Numbers wrong size"" << std::endl;
        return 0;
      }
      numArray.push_back(number);
      length = -1;
      index = i + 1;
    }
    length++;
  }
  int number = stoi(nums.substr(index, nums.length() - index));
  if (number < 1 || number > 100000) {
    std::cout << ""Error: Numbers wrong size"" << std::endl;
    return 0;
  }
  numArray.push_back(number);
  int total = 0;
  for (int i = 0; i < numArray.size(); i++) {
    total += numArray[i];
  }
  std::cout << ""Sum: "" << total << std::endl;
  return 1;
}
","Error with code 1:
",ERR,C++17,2022-07-30 13:44:37.760393,0
174,theKevin27,1,1004,"#include <iostream>
#include <string>
#include <vector>

int main() {
  int n;
  std::cin >> n; // N
  if (n < 2 || n > 100) {
    std::cout << ""Error: Wrong amount of numbers"" << std::endl;
    return 0;
  }
  std::string nums; //""a""
  std::cin.ignore();
  std::getline(std::cin, nums);
  std::vector<int> numArray;
  int index = 0;
  int length = 1;
  for (int i = 0; i < nums.size(); i++) {
    if (isspace(nums.at(i))) {
      int number = stoi(nums.substr(index, length));
      if (number < 1 || number > 100000) {
        std::cout << ""Error: Numbers wrong size"" << std::endl;
        return 0;
      }
      numArray.push_back(number);
      length = -1;
      index = i + 1;
    }
    length++;
  }
  int number = stoi(nums.substr(index, nums.length() - index));
  if (number < 1 || number > 100000) {
    std::cout << ""Error: Numbers wrong size"" << std::endl;
    return 0;
  }
  numArray.push_back(number);
  int total = 0;
  for (int i = 0; i < numArray.size(); i++) {
    total += numArray[i];
  }
  std::cout << total << std::endl;
  return 1;
}
","Error with code 1:
",ERR,C++17,2022-07-30 13:45:01.666948,0
175,YugoslaviaLover1992,1,1007,"#include <iostream>
#include <string>
#include <vector>
#include<sstream>

using namespace std;

struct plank {
  int num = 0;
  string col = ""white"";
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i <= n; i++) {
    plank p;
    p.num = i + 1;
    // pushing p
    fence.push_back(p);
  }

  for (int i = 0; i <= q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      int startInd, endInd;
      string word, newCol;
      istringstream iss(query);
    
      iss >> word;  
      startInd = stoi(word) - 1;
      iss >> word;  
      endInd = stoi(word) - 1;
      iss >> word;        
      newCol = word;

      for (startInd; startInd <= endInd; startInd++){
        fence[startInd].col = newCol;
      }
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, query.length()-1);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col << ""\n"";
    }
  }
}",No such device or address,ERR,C++17,2022-07-30 13:45:32.758359,0
176,SoloGuy,1,1006,"m=int(input())
mw=m*2-1
mi=mw//2
ll=[]
def f(r, w, ll):
    if r == 1:
        ll.append(' '*mi + '.')
        ll.append(' '*mi + '|')
        ll.append(' '*mi + '<')
    else:
        s=w-2
        t=[' ' for i in range(s)]
        for i in range(0, s//2+1):
            t[i]=t[s-1-i]=chr(65+i)
        ll.append(' '*((mw-w)//2)+'/'+''.join(t)+'\\')
        f(r-1,w-2,ll)
f(m, mw, ll)
for row in ll[::-1]:
    print(row)
","",AC,Python3,2022-07-30 13:46:30.139233,50
177,theKevin27,1,1004,"#include <iostream>
#include <string>
#include <vector>

int main() {
  int n;
  std::cin >> n; // N
  if (n < 2 || n > 100) {
    std::cout << ""Error: Wrong amount of numbers"" << std::endl;
    return 0;
  }
  std::string nums; //""a""
  std::cin.ignore();
  std::getline(std::cin, nums);
  std::vector<int> numArray;
  int index = 0;
  int length = 1;
  for (int i = 0; i < nums.size(); i++) {
    if (isspace(nums.at(i))) {
      int number = stoi(nums.substr(index, length));
      if (number < 1 || number > 100000) {
        std::cout << ""Error: Numbers wrong size"" << std::endl;
        return 0;
      }
      numArray.push_back(number);
      length = -1;
      index = i + 1;
    }
    length++;
  }
  int number = stoi(nums.substr(index, nums.length() - index));
  if (number < 1 || number > 100000) {
    std::cout << ""Error: Numbers wrong size"" << std::endl;
    return 0;
  }
  numArray.push_back(number);
  int total = 0;
  for (int i = 0; i < numArray.size(); i++) {
    total += numArray[i];
  }
  std::cout << total << std::endl;
}
","",AC,C++17,2022-07-30 13:46:41.14207,100
178,PinesCyrex,1,1009,"import time
import random

width = 80
height = 24

# create a list of lists to represent the screen
screen = []
for row in range(height):
    screen.append([])
    for col in range(width):
        screen[row].append(' ')

frame_count = 0

class Ball:
    ball_row, ball_col, ball_dir_row, ball_dir_col = 0, 0, 0, 0

    def create_ball(self):
        #randomly generate ball position and direction
        self.ball_row = random.randint(1, height - 2)
        self.ball_col = random.randint(1, width - 2)

        # check if there's already a ball in the position
        if screen[self.ball_row][self.ball_col] == 'O':
            self.create_ball()

        self.ball_dir_row = random.choice([-1, 1])
        self.ball_dir_col = random.choice([-1, 1])

    def move_ball(self):
        self.ball_row += self.ball_dir_row
        self.ball_col += self.ball_dir_col
        if self.ball_row == 0 or self.ball_row == height - 1:
            self.ball_dir_row *= -1
        if self.ball_col == 0 or self.ball_col == width - 1:
            self.ball_dir_col *= -1

        #check collision
        # round ball position to int
        if screen[self.ball_row][self.ball_col] == 'O':
            self.ball_dir_row *= -1
            self.ball_dir_col *= -1

    def draw_ball(self):
        screen[self.ball_row][self.ball_col] = 'O'

def update_screen():
    global frame_count
    for row in range(height):
        for col in range(width):
            print(screen[row][col], end='')
        print()
    print('Frame:', frame_count)
    print()
    frame_count += 1
    for row in range(height):
        for col in range(width):
            screen[row][col] = ' '


def main():
    listOfBalls = []
    FPS = 60
    frame_delay = 1 / (FPS + 10)
    seconds = 10
    ballCount = 20

    for i in range(ballCount):
        ball = Ball()
        ball.create_ball()
        listOfBalls.append(ball)

    while True:
        for i in range(ballCount):
            listOfBalls[i].move_ball()
            listOfBalls[i].draw_ball()

        update_screen()

        time.sleep(frame_delay)
        if frame_count == seconds * FPS:
            break

main()",Only your latest submission will be checked,AC,Python3,2022-07-30 13:49:34.267477,10
205,duckduckdoo,1,1007,"
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    int numFences, numQueries;
    cin>>numFences>>numQueries;
    unordered_map<int, string> f;
    for (int i = 0; i < numQueries; i++) {
        char command;
        cin>>command;
        if (command == 'p') {
            int start, end;
            string color;
            cin>>start>>end>>color;
            for (int i = start-1; i < end; i++) {
                f[i] = color;
            }
        }
        else if (command == 'q') {
            int fenceNum;
            cin>>fenceNum;
            fenceNum--;
            (f.find(fenceNum) == f.end()) ?
            cout<<""white""<<endl :
            cout<<f[fenceNum]<<endl;
        }
    }
}","Failed on case 3, test 0",TLE,C++23,2022-07-30 14:13:48.751485,40
182,duckduckdoo,1,1005,"void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        cout << arr[i] << "" "";
    cout << endl;
}
  
// Driver code
int main()
{
  int arrSize, numQueries;
  cin>>arrSize>>numQueries;
  int arr[arrSize];
  for (int i = 0; i < arrSize; i++)
    arr[i] = i;
  
  for (int i = 0; i < arrSize - 1; i++) {
    for (int j = 0; j < arrSize - i - 1; j++) {
      cout<<""q 1""<<endl;
      cout<<arr[j]<<"" > ""<<arr[j+1]<<endl;
      bool x;
      cin>>x;
      if (x) {
        swap(arr[j], arr[j + 1]);
      }
    }
    
    cout<<""a "";
    printArray(arr, arrSize);
  }
    return 0;
}","/code/Main.cpp: In function ‘void printArray(int*, int)’:
/code/Main.cpp:5:9: error: ‘cout’ was not declared in this scope
    5 |         cout << arr[i] << "" "";
      |         ^~~~
/code/Main.cpp:6:5: error: ‘cout’ was not declared in this scope
    6 |     cout << endl;
      |     ^~~~
/code/Main.cpp:6:13: error: ‘endl’ was not declared in this scope
    6 |     cout << endl;
      |             ^~~~
/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:13:3: error: ‘cin’ was not declared in this scope
   13 |   cin>>arrSize>>numQueries;
      |   ^~~
/code/Main.cpp:20:7: error: ‘cout’ was not declared in this scope
   20 |       cout<<""q 1""<<endl;
      |       ^~~~
/code/Main.cpp:20:20: error: ‘endl’ was not declared in this scope
   20 |       cout<<""q 1""<<endl;
      |                    ^~~~
/code/Main.cpp:25:9: error: ‘swap’ was not declared in this scope
   25 |         swap(arr[j], arr[j + 1]);
      |         ^~~~
/code/Main.cpp:29:5: error: ‘cout’ was not declared in this scope
   29 |     cout<<""a "";
      |     ^~~~
",CERR,C++17,2022-07-30 13:52:39.195181,0
183,TeamJin,1,1005,"n=int(input())
print((n+1)*"" ""+"">\n""+(n+1)*"" ""+""|\n""+(n+1)*"" ""+""."")
for i in range(n):
    s=chr(i+65)
    for j in range(i-1,-1,-1):s=chr(j+65)+s+chr(j+65)
    print((n-i)*"" ""+""/""+s+""\\"")
","WA on case 0, test 0",WA,Python3,2022-07-30 13:53:50.660381,0
184,TeamJin,1,1006,"n=int(input())
print((n+1)*"" ""+"">\n""+(n+1)*"" ""+""|\n""+(n+1)*"" ""+""."")
for i in range(n):
    s=chr(i+65)
    for j in range(i-1,-1,-1):s=chr(j+65)+s+chr(j+65)
    print((n-i)*"" ""+""/""+s+""\\"")
","",AC,Python3,2022-07-30 13:54:02.377616,50
185,PinesCyrex,1,1007,"#include <iostream>
#include <map>
#include <typeinfo>
using namespace std;
int main() {
    int fenceCount;
    int qCount;
    cin >> fenceCount >> qCount;

    map<int, string> fenceMap;
    fenceMap[0] = ""white"";
    int* fences = (int*)malloc(fenceCount * sizeof(int));
    //std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

    int counter = 1;
    for (int i = 0; i < qCount; i++) {
        string qType;
        cin >> qType;
        if (qType == ""q"") {
            int retrieve;
            cin >> retrieve;
            auto it = fenceMap.find(fences[retrieve - 1]);
            string result = it->second;
            cout << result << endl;
        } else {
            int first;
            int last;
            string color;
            cin >> first >> last >> color;
            fenceMap[counter] = color;
            for (int i = first - 1; i < last; i++) {
                fences[i] = counter;
            }
            counter++;
        }
    }

    return 0;
}",Resource temporarily unavailable,ERR,C++17,2022-07-30 13:54:37.158607,60
186,theKevin27,1,1005,"#include <iostream>
#include <string>
#include <vector>

int main() {
int n;
std::cin >> n; // N
if (n < 2 || n > 10000) {
std::cout << ""Error: Wrong amount of numbers"" << std::endl;
return 0;
}
std::string nums; //""a""
std::cin.ignore();
std::getline(std::cin, nums);
std::vector<int> numArray;
int index = 0;
int length = 1;
for (int i = 0; i < nums.size(); i++) {
if (isspace(nums.at(i))) {
int number = stoi(nums.substr(index, length));
if (number < 1 || number > 10000000) {
std::cout << ""Error: Numbers wrong size"" << std::endl;
return 0;
}
numArray.push_back(number);
length = -1;
index = i + 1;
}
length++;
}
int number = stoi(nums.substr(index, nums.length() - index));
if (number < 1 || number > 10000000) {
std::cout << ""Error: Numbers wrong size"" << std::endl;
return 0;
}
numArray.push_back(number);
int total = 0;
for (int i = 0; i < numArray.size(); i++) {
total += numArray[i];
}
std::cout << ""Sum: "" << total << std::endl;
return 1;
}","WA on case 2, test 0",WA,C++17,2022-07-30 13:55:07.603435,70
187,FuduBoys,1,1007,"nums = list(map(int, input().split()))
planks = ['white'] * nums[0]

for i in range(nums[1]):
    query = input()
    if query[0] == 'p':
        for j in range(int(query[2]), int(query[4]) + 1):
            planks[j] = query[6:]
    else:
        if int(query[2]) < nums[0]:
            print(planks[int(query[2])])
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 7, in <module>
    for j in range(int(query[2]), int(query[4]) + 1):
ValueError: invalid literal for int() with base 10: ' '
",ERR,Python3,2022-07-30 13:55:54.655927,0
188,FuduBoys,1,1007,"nums = list(map(int, input().split()))
planks = ['white'] * nums[0]

for i in range(nums[1]):
    query = input()
    if query[0] == 'p':
        for j in range(int(query[2]), int(query[4]) + 1):
            planks[j] = query[6:]
    else:
        if int(query[2]) < nums[0]:
            print(planks[int(query[2])])
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 7, in <module>
    for j in range(int(query[2]), int(query[4]) + 1):
ValueError: invalid literal for int() with base 10: ' '
",ERR,Python3,2022-07-30 13:57:05.029768,0
191,PinesCyrex,1,1007,"#include <iostream>
#include <map>
#include <typeinfo>
using namespace std;
int main() {
    int fenceCount;
    int qCount;
    cin >> fenceCount >> qCount;

    map<int, string> fenceMap;
    fenceMap[0] = ""white"";
    int* fences = (int*)malloc(fenceCount * sizeof(int));
    //std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

    int counter = 1;
    string qType;
    int first;
    int last;
    string color;
    for (int i = 0; i < qCount; i++) {
        cin >> qType;
        if (qType == ""q"") {
            int retrieve;
            cin >> retrieve;
            auto it = fenceMap.find(fences[retrieve - 1]);
            string result = it->second;
            cout << result << endl;
        } else {
            cin >> first >> last >> color;
            fenceMap[counter] = color;
            for (int i = first - 1; i < last; i++) {
                fences[i] = counter;
            }
            counter++;
        }
    }

    return 0;
}",,judging,C++17,2022-07-30 13:58:03.660073,0
192,PinesCyrex,1,1007,"#include <iostream>
#include <map>
#include <typeinfo>
using namespace std;
int main() {
    int fenceCount;
    int qCount;
    cin >> fenceCount >> qCount;

    map<int, string> fenceMap;
    fenceMap[0] = ""white"";
    int* fences = (int*)malloc(fenceCount * sizeof(int));
    //std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

    int counter = 1;
    string qType;
    int first;
    int last;
    string color;
    for (int i = 0; i < qCount; i++) {
        cin >> qType;
        if (qType == ""q"") {
            int retrieve;
            cin >> retrieve;
            auto it = fenceMap.find(fences[retrieve - 1]);
            string result = it->second;
            cout << result << endl;
        } else {
            cin >> first >> last >> color;
            fenceMap[counter] = color;
            for (int i = first - 1; i < last; i++) {
                fences[i] = counter;
            }
            counter++;
        }
    }

    return 0;
}",Resource temporarily unavailable,ERR,C++17,2022-07-30 13:58:19.189862,60
193,theKevin27,1,1005,"#include <iostream>
#include <string>
#include <vector>

int main() {
int n;
std::cin >> n; // N
if (n < 2 || n > 1000) {
std::cout << ""Error: Wrong amount of numbers"" << std::endl;
return 0;
}
std::string nums; //""a""
std::cin.ignore();
std::getline(std::cin, nums);
std::vector<int> numArray;
int index = 0;
int length = 1;
for (int i = 0; i < nums.size(); i++) {
if (isspace(nums.at(i))) {
int number = stoi(nums.substr(index, length));
if (number < 1 || number > 100000) {
std::cout << ""Error: Numbers wrong size"" << std::endl;
return 0;
}
numArray.push_back(number);
length = -1;
index = i + 1;
}
length++;
}
int number = stoi(nums.substr(index, nums.length() - index));
if (number < 1 || number > 100000) {
std::cout << ""Error: Numbers wrong size"" << std::endl;
return 0;
}
numArray.push_back(number);
int total = 0;
for (int i = 0; i < numArray.size(); i++) {
total += numArray[i];
}
std::cout << ""Sum: "" << total << std::endl;
return 1;
}
","WA on case 2, test 0",WA,C++17,2022-07-30 13:58:41.760088,70
194,Albus,1,1008,"/*
 Authors : Shahrad Sharif, Alireza Noori
 Date	 : July 30, 2022
 A Strange Programming Contest!
-------------------------------------------------------------------
This program is a tic-tac-toe game. User is playing ""O"", and
computer plays ""X"". User always plays first.
-------------------------------------------------------------------
*/

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>

/* Constants for TTT game board symbols. */
#define EMPTY ' '
#define USER 'O'
#define COMPUTER 'X'
#define O 2
#define X 3
#define DRAW 1
#define THE_GAME_MUST_GO_ON 0
#define TRUE 1
#define FALSE 0

// Functions prototypes

void displayHorizontalLine();
void displayOneRow(char s1, char s2, char s3);
void tttTable(char[]);

int rowIsWinner(char s1, char s2, char s3);
int winning_arrangments(char[]);
int draw(char[]);

int valueInRange(int value);
int getUserChoice(char[]);
int insertUserChoice(char[]);

int compChoice(char array[], int);
void insertCompChoice(char[], int);

int userSaysYes(char[]);
char getCharInput();
void clearInputStream();
int getIntInput();

void game(char[], char[]);

// A function to start the array which will be in the 9 square of the tic-tac-to.
//  A function to ask the users and start the game
//  Initially the board is empty

/*In main, two arrays have created. One is for guiding user to choose the right square, and the other one, tttArray, is the game board itself.
The game will run continuously as long as the user wants to play.
*/
int main()
{
    char guidetttArray[9] = {'0', '1', '2', '3', '4', '5', '6', '7', '8'};
    char tttArray[9] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};

    if (userSaysYes(""Do you wanna play Tic-Tac-Toe?""))
    {
        game(tttArray, guidetttArray);
        while (userSaysYes(""Do you wanna play again?""))
        {
            char tttArray[9] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};
            game(tttArray, guidetttArray);
        }
    }

    return 0;
}

// This function displays one of the horizontal line in a TTT board.
void displayHorizontalLine()
{
    int lenghtOfTheLine = 20;
    for (int i = 0; i < lenghtOfTheLine; i++)
    {
        printf(""-"");
    }
    printf(""\n"");
}

// This function displays one row of a TTT board with squares s1, s2 and s3.
void displayOneRow(char s1, char s2, char s3)
{
    char vLine = '|';
    printf(""%7c%7c\n"", vLine, vLine);
    printf(""   %c  |  %c   |   %c  \n"", s1, s2, s3);
    printf(""%7c%7c%\n"", vLine, vLine);
}

// This function displays a complete TTT board, by using displayOneRow and displayHorizontalLine functions.
void tttTable(char array[])
{
    displayOneRow(array[0], array[1], array[2]);
    displayHorizontalLine();
    displayOneRow(array[3], array[4], array[5]);
    displayHorizontalLine();
    displayOneRow(array[6], array[7], array[8]);
}

// This function determine whether a series of 3 squares is winer or not.
int rowIsWinner(char s1, char s2, char s3)
{
    return (s1 == s2 && s2 == s3 && s1 != ' ');
}

// This function determines if a value is within a range of 0 to 8 for the game or not.
int valueInRange(int value)
{
    return (value >= 0 && value <= 8);
}

/* A function for all possible ways to find the winner, which is 8 possible ways. In the if function we call the numbers
 from the tttArray which represent the squares in the game, then if tttArray are now represented by O, user is the winner,
if represented by X, computer is the winner, if all of the squares are full but no one is winner, it is a draw,
and if neither, the game continues and the function return 0;
*/
int winning_arrangments(char tttArray[9])
{
    if (rowIsWinner(tttArray[0], tttArray[1], tttArray[2]))
    {
        if (tttArray[0] == 'O')
            return O;
        return X;
    }
    else if (rowIsWinner(tttArray[3], tttArray[4], tttArray[5]))
    {
        if (tttArray[3] == 'O')
            return O;
        return X;
    }
    else if (rowIsWinner(tttArray[6], tttArray[7], tttArray[8]))
    {
        if (tttArray[6] == 'O')
            return O;
        return X;
    }
    else if (rowIsWinner(tttArray[0], tttArray[3], tttArray[6]))
    {
        if (tttArray[0] == 'O')
            return O;
        return X;
    }
    else if (rowIsWinner(tttArray[1], tttArray[4], tttArray[7]))
    {
        if (tttArray[1] == 'O')
            return O;
        return X;
    }
    else if (rowIsWinner(tttArray[2], tttArray[5], tttArray[8]))
    {
        if (tttArray[2] == 'O')
            return O;
        return X;
    }
    else if (rowIsWinner(tttArray[0], tttArray[4], tttArray[8]))
    {
        if (tttArray[0] == 'O')
            return O;
        return X;
    }
    else if (rowIsWinner(tttArray[2], tttArray[4], tttArray[6]))
    {
        if (tttArray[2] == 'O')
            return O;
        return X;
    }
    else if (draw(tttArray))
        return DRAW;
    else
        return THE_GAME_MUST_GO_ON;
}

// This function determine if a draw has happened or not.
int draw(char tttArray[])
{
    for (int i = 0; i < 9; i++)
    {
        if (tttArray[i] == ' ')
            return FALSE;
    }
    return TRUE;
}

// A function to get the user choice; and if he/she does not follow the guide, program wants him/her to try again.
int getUserChoice(char Array[])
{
    int choice;
    printf(""Please choose a spot based on the guide!\n"");
    choice = getIntInput();
    while (!valueInRange(choice))
    {
        printf(""Invalid input! Please choose a spot based on the guide!\n"");
        choice = getIntInput();
    }
    while (Array[choice] == 'O' || Array[choice] == 'X')
    {
        printf(""This cell is occupied, choose another one.\n"");
        choice = getUserChoice(Array);
    }
    return choice;
}

// This function insert the approved input from the user into the game's Array.
int insertUserChoice(char array[])
{
    int i = getUserChoice(array);
    array[i] = 'O';
    return i;
}

/*This function return a choice for the computer.
computer choice is depend to the previous choice of the user.
If in the last move, user has chosen the square number n,
the computer will choose the (n+1)th empty square.
*/
int compChoice(char array[], int userChoice)
{
    int i = 0, count = 0;
    while (count < userChoice || array[(i) % 9] == 'X' || array[(i) % 9] == 'O')
    {
        if (array[(i) % 9] != 'X' && array[(i) % 9] != 'O')
        {
            count++;
        }
        i++;
    }
    return i % 9;
}

// This function will insert the computer choice into the the game's Array.
void insertCompChoice(char array[], int userChoice)
{
    array[compChoice(array, userChoice)] = 'X';
}

// This function asks the user if he/she wants to play ttt or not.
int userSaysYes(char question[])
{
    char answer;
    do
    {
        printf(""%s (Y/N):"", question);

        answer = getCharInput();
        answer = toupper(answer);
        clearInputStream();
    } while (!(answer == 'Y' || answer == 'N'));
    printf(""\n"");
    return (answer == 'Y');
}

// This function clears the newline characters ('\n') from the input stream and reads the first non-newline character.
char getCharInput()
{
    char input;
    input = getchar();
    while (input == '\n')
    {
        input = getchar();
    }
    return input;
}

/* This function clears everything left on the input stream until a newline
   character is read
*/
void clearInputStream()
{
    char input = getchar();
    while (input != '\n')
    {
        input = getchar();
    }
}

// This function keeps prompting the user to enter an int until they do so.
int getIntInput()
{
    int num;
    char term;

    while (scanf(""%d%c"", &num, &term) != 2 || term != '\n')
    {
        printf(""Improper input. Please enter an integer: \n"");
        clearInputStream();
    }
    return num;
}

/*This function calls different needed to play one turn.
First a guide for the game. Then getting user choice. After that Computer choose a square and the board will pop-up for the user.
When the game is done, this function will print who has won or it is a draw.
*/
void game(char tttArray[], char guidetttArray[])
{
    do
    {
        printf(""Great! It's your turn! You are playing 'O', and computer is 'X'.\n\n"");
        tttTable(guidetttArray);
        printf(""\n"");
        int choice = insertUserChoice(tttArray);
        if (winning_arrangments(tttArray))
        {
            break;
        }
        insertCompChoice(tttArray, choice);
        if (winning_arrangments(tttArray))
        {
            break;
        }
        printf(""\n"");
        tttTable(tttArray);
        printf(""\n"");

    }
    // A function that tells the user if they have won, lost or Draw versus computer.

    while (!winning_arrangments(tttArray));
    tttTable(tttArray);
    printf(""\n"");
    if (winning_arrangments(tttArray) == X)
    {
        printf(""\nComputer Won!\n"");
    }
    else if (winning_arrangments(tttArray) == O)
    {
        printf(""\nCongratulation! You Won.\n"");
    }
    else
    {
        printf(""\nDraw!\n"");
    }
}

/*
    for loosing play 0 - 8 - 3
    for a draw play 0 - 3 - 7 - 2 - 5
*/
",Only your latest submission will be checked,AC,C++17,2022-07-30 13:58:55.848449,10
195,FuduBoys,1,1007,"nums = list(map(int, input().split()))
planks = ['white'] * nums[0]

for i in range(nums[1]):
    query = input()
    if query[0] == 'p':
        for j in range(int(query[2]) - 1, int(query[4])):
            planks[j] = query[6:]
    else:
        print(planks[int(query[2]) - 1])
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 7, in <module>
    for j in range(int(query[2]) - 1, int(query[4])):
ValueError: invalid literal for int() with base 10: ' '
",ERR,Python3,2022-07-30 14:00:53.746549,0
196,YugoslaviaLover1992,1,1005,"#include <iostream>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

struct plank {
  int num;
  string col = ""white"";
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i <= n; i++) {
    plank p;
    p.num = i + 1;
    // pushing p
    fence.push_back(p);
  }

  for (int i = 0; i <= q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      int startInd, endInd;

      int counter = 0;

      istringstream iss(query);

      string word, newCol;

      while (iss >> word) {
        if (counter == 1) {
          startInd = stoi(word) - 1;
        } else if (counter == 2) {
          endInd = stoi(word) - 1;
        } else if (counter == 3) {
          newCol = word;
        }
        counter++;
      }

      for (startInd; startInd <= endInd; startInd++) {
        fence[startInd].col = newCol;
      }
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, query.length() - 1);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col << ""\n"";
    }
  }
}","WA on case 0, test 0",WA,C++17,2022-07-30 14:02:57.838597,0
229,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main(){
    //initialize map and iterator
    vector<string> fences;

    //read the number of fences and queries
    long numFences;
    long numQueries;
    cin >> numFences >> numQueries;

    //insert all initial elements as white
    for (int i = 0; i < numFences; i++){
        fences.push_back(""white"");
    }

    //initialize all the variables needed
    char type;

    //take the input in a loop
    for(int i = 0; i < numQueries; i++){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            string color;
            cin >> start >> end;
            cin >> color;
            //modify the fences' colors
            for(int j = start; j <= end; j++){
                fences.at(j-1) = color;
            }
        }
        else if(type == 'q'){
            //take in 1 input
            int key;
            cin >> key;
            cout << fences.at(key-1) << endl;
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 14:33:09.547993,40
197,YugoslaviaLover1992,1,1007,"#include <iostream>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

struct plank {
  int num;
  string col = ""white"";
};

int main() {
  // n = number of planks, q = number of queries
  int n, q;

  cin >> n >> q;
  vector<plank> fence;

  for (int i = 0; i <= n; i++) {
    plank p;
    p.num = i + 1;
    // pushing p
    fence.push_back(p);
  }

  for (int i = 0; i <= q; i++) {
    string query;
    getline(cin, query);

    char qType = query[0];

    if (query[0] == 'p') {
      // paint colours from query[2] and query[4]
      int startInd, endInd;

      int counter = 0;

      istringstream iss(query);

      string word, newCol;

      while (iss >> word) {
        if (counter == 1) {
          startInd = stoi(word) - 1;
        } else if (counter == 2) {
          endInd = stoi(word) - 1;
        } else if (counter == 3) {
          newCol = word;
        }
        counter++;
      }

      for (startInd; startInd <= endInd; startInd++) {
        fence[startInd].col = newCol;
      }
    }

    if (query[0] == 'q') {
      string queryNum = query.substr(2, query.length() - 1);
      int ind = stoi(queryNum) - 1;

      cout << fence[ind].col << ""\n"";
    }
  }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 14:03:13.3095,40
198,theKevin27,1,1007,"#include <iostream>
#include <string>
#include <vector>

int main() {
int n;
std::cin >> n; // N
if (n < 2 || n > 1000) {
std::cout << ""Error: Wrong amount of numbers"" << std::endl;
return 0;
}
std::string nums; //""a""
std::cin.ignore();
std::getline(std::cin, nums);
std::vector<int> numArray;
int index = 0;
int length = 1;
for (int i = 0; i < nums.size(); i++) {
if (isspace(nums.at(i))) {
int number = stoi(nums.substr(index, length));
if (number < 1 || number > 100000) {
std::cout << ""Error: Numbers wrong size"" << std::endl;
return 0;
}
numArray.push_back(number);
length = -1;
index = i + 1;
}
length++;
}
int number = stoi(nums.substr(index, nums.length() - index));
if (number < 1 || number > 100000) {
std::cout << ""Error: Numbers wrong size"" << std::endl;
return 0;
}
numArray.push_back(number);
int total = 0;
for (int i = 0; i < numArray.size(); i++) {
total += numArray[i];
}
std::cout << ""Sum: "" << total << std::endl;
return 1;
}
","Error with code 1:
",ERR,C++17,2022-07-30 14:04:30.502988,0
199,PinesCyrex,1,1007,"#include <iostream>
#include <map>
#include <typeinfo>
using namespace std;
int main() {
    int fenceCount;
    int qCount;
    cin >> fenceCount >> qCount;

    map<int, string> fenceMap;
    fenceMap[0] = ""white"";
    int* fences = new int[fenceCount];
    //std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

    int counter = 1;
    string qType;
    int first;
    int last;
    string color;
    for (int i = 0; i < qCount; i++) {
        cin >> qType;
        if (qType == ""q"") {
            int retrieve;
            cin >> retrieve;
            auto it = fenceMap.find(fences[retrieve - 1]);
            string result = it->second;
            cout << result << endl;
        } else {
            cin >> first >> last >> color;
            fenceMap[counter] = color;
            for (int i = first - 1; i < last; i++) {
                fences[i] = counter;
            }
            counter++;
        }
    }

    delete[] fences;
    return 0;
}","Failed on case 4, test 0",MLE,C++17,2022-07-30 14:04:47.226692,60
200,duckduckdoo,1,1005,"#include <iostream>
using namespace std;
  
// Function to print an array 
void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        cout << arr[i] << "" "";
    cout << endl;
}
  
// Driver code
int main()
{
  int arrSize, numQueries;
  cin>>arrSize>>numQueries;
  int arr[arrSize];
  for (int i = 0; i < arrSize; i++)
    arr[i] = i;
  
  for (int i = 0; i < arrSize - 1; i++) {
    for (int j = 0; j < arrSize - i - 1; j++) {
      cout<<""q 1""<<endl;
      cout<<arr[j]<<"" > ""<<arr[j+1]<<endl;
      bool x;
      cin>>x;
      if (x) {
        swap(arr[j], arr[j + 1]);
      }
    }
    
    cout<<""a "";
    printArray(arr, arrSize);
  }
    return 0;
}","WA on case 0, test 2","",C++17,2022-07-30 14:05:26.083436,0
201,rvijayar,1,1005,"#include <bits/stdc++.h>
#define rep(x, start, end) for (int x = start; x < end; x++)
#define pb(x)              push_back(x)
#define mp(x, y)           make_pair(x, y)
using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;

const int MAXN = 100;
int altb[MAXN][MAXN];  // a < b?

vector<pii> history;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(NULL);

  rep(i, 0, MAXN) fill(altb[i], altb[i] + MAXN, 0);

  int n, m;
  cin >> n >> m;

  vi nums(n);
  iota(nums.begin(), nums.end(), 0);

  rep(i, 0, n) {
    history.clear();

    rep(j, 0, n) {
      if (i != j)
        history.pb(mp(i, j));
    }
    cout << ""q "" << history.size() << endl;

    for (auto&& x : history)
      cout << x.first << "" > "" << x.second << endl;

    for (auto&& x : history) {
      cin >> altb[x.first][x.second];
      if (altb[x.first][x.second] == -1)
        exit(-1);
    }
  }
  cout << ""a "";

  rep(i, 0, n) {
    rep(j, 0, n) {
      if (accumulate(&altb[j][0], &altb[j][n], 0) == i)
        cout << j << ' ';
    }
  }
  cout << flush;

  cin >> n;

  return 0;
}","WA on case 0, test 0",WA,C++17,2022-07-30 14:07:54.108257,0
202,duckduckdoo,1,1008,"#include <iostream>
#include <unistd.h>
using namespace std;

/****************************************************************/
/*                    Fractal Curve Function                    */
/* Mandelbrot set is used: en.wikipedia.org/wiki/Mandelbrot_set */
/*  Function creates a 2D array and populates it with values    */
/*                    based off Mandelbrot set                  */
/****************************************************************/
int **calculateSet(int maxX, int maxY){
    //Intialise an empty 2D array that corresponds to the max width and height
    int **returnSet = new int*[maxY];
    for(int p = 0; p < maxY; p++){
        returnSet[p] = new int[maxX];
    }

    //Create variables that will hold values for the Mandelbrot set
    float scale_x, scale_y;
    float r_x, r_y;
    float c_x, c_y;
    float t;

    //Ratio of how much the fractal takes up the avaliable spaace
    float x_ratio = .25;
    float y_ratio = .5;

    //Both values are buffers to centre the drawing
    float R = 1;
    float L = .15;  

    //Initalise the x and y scale of the fractal based off the max screen sizes and the x and y ratio of the fractals size
    scale_x = x_ratio/maxX;
    scale_y = y_ratio/maxY;

    //iterate through every x and y position and calculate the Mandelbrot set
    for(int i = 1;  i < maxY; i++){
        for(int k = 1; k < maxX; k++){
            //intialising real part for Mandelbrot set
            c_x = k * scale_x - L;  
            //intialising imaginary part for Mandelbrot set
            c_y = i * scale_y - R;

            //Real part for Z
            r_x = 0;
            //Imaginary Part for Z
            r_y = 0;

            // initalise empty colour value
            int colour = 0;

            //Figure out if the corresponding x and y position of the 2D array is a member of the Mandelbrot set
            //2 exit conditions are if it reaches a maximum iteration count of 100 or the distance diverges to far from the origin
            while((r_x*r_x + r_y*r_y < 4 ) && (colour <= 100)){
                //calculate real part of Z
                t  = r_x*r_x - r_y*r_y + c_x; 
                //calculate imaginary part of Z
                r_y = 2 * r_x * r_y + c_y;
                // update real component
                r_x = t;
                //Increase value
                colour++;
            }
            //set given value 
            returnSet[i][k] = colour;

        }
    }
    //return the 2D set for drawing
    return returnSet;
}

/********************************************************/
/*                     Draw Function                    */
/*  This function draws a given 2D set of values with   */
/*  rectangles, whos colour is dependent on a bucketed  */
/*                 value pre determined.                */
/********************************************************/
void draw(int **toDraw, int mX, int mY){

    //Intialising colour values 
	string green = ""\033[22;32m"";
	string _green = ""\033[01;32m"";
	string orange = ""\033[22;33m"";
	string yellow = ""\033[01;33m"";
	string blue = ""\033[22;34m"";
	string _blue = ""\033[01;34m"";
	string magenta = ""\033[22;35m"";
	string _magenta = ""\033[01;35m"";
	string cyan = ""\033[22;36m"";
	string _cyan = ""\033[01;36m"";

    //iterate through the 2D array toDraw
    for(int i = 0; i < mX; i++){
        for(int k = 0; k < mY; k++){
            //Check colour value of toDraw and print the corresponding coloured rectangle
            if(toDraw[k][i] == 100)      cout << "" "";
            else if(toDraw[k][i] > 90) cout << green << ""\u2588"";
            else if(toDraw[k][i] > 80) cout << _green << ""\u2588"";
            else if(toDraw[k][i] > 70) cout << orange << ""\u2588"";
            else if(toDraw[k][i] > 60) cout << yellow << ""\u2588"";
            else if(toDraw[k][i] > 50) cout << blue << ""\u2588"";
            else if(toDraw[k][i] > 40) cout << _blue << ""\u2588"";
            else if(toDraw[k][i] > 30) cout << magenta << ""\u2588"";
            else if(toDraw[k][i] > 20) cout << _magenta << ""\u2588"";
            else if(toDraw[k][i] > 10) cout << cyan << ""\u2588"";
            else if(toDraw[k][i] > 0) cout << _cyan <<  ""\u2588"";

        }
        //New line once it hits the max width
        cout << ""\n"";
    }
    return;
}

/*********************************************************/
/*                  Fractal Drawer 1.0                   */
/*  Using 2 custom functions, this file allows the user  */
/* to specify 2 input values of max width and max height */
/*   for the program to draw a fractal based of these    */
/*                     dimensions                        */
/*********************************************************/
int main(){
    //Intialise max height and width values
    int maxX, maxY;
    cout << "" Input Max X size: "";
    cin >> maxX;
    cout << "" Input Max Y size: "";    
    cin >> maxY;

    //Create a 2D set of values that determine colour value
    int **set = calculateSet(maxX, maxY);
    //Draw using 2D array of values
    draw(set, maxX, maxY);
        
    return 0;
}",Only your latest submission will be checked,AC,C++17,2022-07-30 14:08:21.970837,10
203,datOvercommon,1,1007,"import os
import sys

plank1 = list(map(int, input().split()))
query = plank1[1]
plank = plank1[0]

fences = {1: ""white""}

for x in range(1, plank+1):
    fences.update({x: ""white""})

out = []
for x in range(query):
    command = list(input().split())
    # print(command)
    if command[0] == 'q':
        n = command[1]
        out.append(fences.get(int(n)))
        # print(out)
    if command[0] == 'p':
        # print(command)
        start = int(command[1])
        end = int(command[2])
        col = command[3]
        # print(col)
        for x in range(start, end+1):
            fences[x] = col
        # print(fences)
for x in out:
    print(x)
","Failed on case 2, test 0",TLE,Python3,2022-07-30 14:08:35.624803,20
206,FuduBoys,1,1007,"nums = list(map(int, input().split()))
planks = ['white'] * nums[0]

for i in range(nums[1]):
    query = input().split()
    if query[0] == 'p':
        for j in range(int(query[1]) - 1, int(query[2])):
            planks[j] = query[3]
    else:
        print(planks[int(query[1]) - 1])
","Failed on case 2, test 0",TLE,Python3,2022-07-30 14:15:02.04012,20
230,SoloGuy,1,1006,"m=int(input())
mw=m*2-1
mi=mw//2
ll=[]
def f(r, w, ll):
    if r == 1:
        ll.append(' '*mi+'<\n'+' '*mi+'|\n'+' '*mi+'.')
    else:
        s=w-2
        t=[' ' for i in range(s)]
        for i in range(0, s//2+1):
            t[i]=t[s-1-i]=chr(65+i)
        ll.append(' '*((mw-w)//2)+'/'+''.join(t)+'\\')
        f(r-1,w-2,ll)
f(m, mw, ll)
for row in ll[::-1]:
    print(row)
","",AC,Python3,2022-07-30 14:33:56.176737,50
207,JavaScriptJatts,1,1007,"#include <bits/stdc++.h>

using namespace ::std;


class paint{
public:
    int start;
    int end;
    string color;

    paint(int start, int end, string color): start(start), end(end), color(color){}

};


void fix(vector<string>& fence, vector<paint>& instructions , int&N){

    vector<int> allowed(N+1, 1);

    int start,end;
    string color;

    for(int i = instructions.size()-1; i >= 0; i--){

        start = instructions[i].start;
        end = instructions[i].end;
        color = instructions[i].color;

        for(int j = start; j <= end; j++){
            if(allowed[j]){
                fence[j] = color;
                allowed[j] = 0;
            }
        }



    }




}

int main() {
    int N;
    int Q;

    string option;
    int start;
    int end;

    int q;
    string color;

    cin >> N >> Q;

    vector<string> fence(N+1, ""white"");
    vector<paint> instructions;

    while(cin >> option){

        //while painting
        while(option == ""p""){
            cin >> start >> end >> color;
            paint obj(start,end,color);
            instructions.push_back(obj);
            cin >> option;
        }

        //else if q
        if(option == ""q""){
            fix(fence, instructions, N);
            cin >> q;
            cout << fence[q] << ""\n"";
        }
    }
}

// \o/
//  |
// /_\_","Failed on case 2, test 0",TLE,C++17,2022-07-30 14:15:47.782733,20
208,PinesCyrex,1,1007,"#include <iostream>
#include <map>
#include <typeinfo>
using namespace std;
int main() {
    int fenceCount;
    int qCount;
    cin >> fenceCount >> qCount;

    map<int, string> fenceMap;
    fenceMap[0] = ""white"";
    int* fences = new int[fenceCount];
    //std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

    int counter = 1;
    int retrieve;
    string qType;
    int first;
    int last;
    string color;
    bool existInMap;
    int existIndex;
    map<int, string>::iterator itr;
    for (int i = 0; i < qCount; i++) {
        cin >> qType;
        if (qType == ""q"") {
            cin >> retrieve;
            auto it = fenceMap.find(fences[retrieve - 1]);
            string result = it->second;
            cout << result << endl;
        } else {
            cin >> first >> last >> color;
            for(itr = fenceMap.begin(); itr != fenceMap.end(); itr++) {
                if (itr->second == color) {
                    existInMap = true;
                    existIndex = itr->first;
                }
            }
            if (!existInMap) {
                fenceMap[counter] = color;
            }
            
            for (int i = first - 1; i < last; i++) {
                if (existInMap) {
                    fences[i] = existIndex;
                } else {
                fences[i] = counter;
                }
            }
            counter++;
            existInMap = false;
        }
    }

    delete[] fences;
    return 0;
}","Failed on case 4, test 0",MLE,C++17,2022-07-30 14:16:50.764281,60
209,Dragoneel,1,1006,"m = int(input())

print(("" "" * (m-1)) + "">\n"" + ("" "" * (m-1)) + ""|\n"" + ("" "" * (m-1)) + ""."")
m = m - 1
for i in range(65,65+m):
    m=m-1
    
    print(("" "" * (m)) + ""/"",end="""")
    for k in range(65,i+1):
        print(chr(k),end="""")

    for j in range(i-1,64,-1):
        print(chr(j),end="""")  
    print('\\')


","",AC,Python3,2022-07-30 14:17:12.208338,50
244,duckduckdoo,1,1007,"
#include <iostream>
#include <unordered_map>
#include <map>
#include <vector>
using namespace std;


int main() {
    int numFences, numQueries;
    cin>>numFences>>numQueries;
    map<int, string> *f = new map<int, string>[numFences];
    vector<string> vect(numFences, ""white"");

    for (int i = 0; i < numQueries; i++) {
        char command;
        cin>>command;
        if (command == 'p') {
            int start, end;
            string color;
            cin>>start>>end>>color;
            for (int i = start-1; i < end; i++) {
                vect[i] = color;
            }
        }
        else if (command == 'q') {
            int fenceNum;
            cin>>fenceNum;
            vect[--fenceNum];
        }
    }
}","WA on case 0, test 0",WA,C++17,2022-07-30 14:47:28.974352,0
245,duckduckdoo,1,1007,"
#include <iostream>
#include <unordered_map>
#include <map>
#include <vector>
using namespace std;


int main() {
    int numFences, numQueries;
    cin>>numFences>>numQueries;
    map<int, string> *f = new map<int, string>[numFences];
    vector<string> vect(numFences, ""white"");

    for (int i = 0; i < numQueries; i++) {
        char command;
        cin>>command;
        if (command == 'p') {
            int start, end;
            string color;
            cin>>start>>end>>color;
            for (int i = start-1; i < end; i++) {
                vect[i] = color;
            }
        }
        else if (command == 'q') {
            int fenceNum;
            cin>>fenceNum;
            vect[--fenceNum];
        }
    }
}","WA on case 0, test 0",WA,C++23,2022-07-30 14:47:48.578323,0
210,datOvercommon,1,1005,"#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <queue>

using namespace std;

class node {
public:
	int index;
	vector<node*> lesser;
	node(int ind) : index(ind) { }
	int height(node* i, int height)
	{
		if (i->lesser.size() == 0) return 1;
		while (lesser.size() != 0)
		{
			int max = 0;
			for (auto& k : i->lesser)
			{
				if (i->height(k, height) > max) max = i->height(k, height);
			}
			return 1 + max;
		}
	}
};
int sorted(vector<node*>& nodes, int& n)
{
	for (int i = 0; i < nodes.size(); i++)
	{
		if (nodes[i]->height(nodes[i], 1) == n) return i;
	}
	return -1;
}
void permutation(string s)
{
	sort(s.begin(), s.end());
	do {
		cout << s << "" "";
	} while (next_permutation(s.begin(), s.end())); // std::next_permutation

	cout << endl;
}
int main()
{
	vector<node*> nodes;
	int n, m,temp;
	cin >> n;
	cin >> m;
	for (int i = 0; i < n; i++) 
	{ 
		node* newnode = new node(i);
		nodes.push_back(newnode); 
	}
	//while (!sorted(nodes,n))
	//{

	//}

	for (int k = 1; k < n; k++)
	{
		vector<pair<node*, node*>> nodepairs;
		int index = 0,space = 1;
		for (int i = 0; i < n / 2; i++)
		{
			space = (k + index) % n;
			if (k == n - 1 && i != 0) space = index + 1;
			//Run code
			nodepairs.push_back({ nodes[index], nodes[space] });

			/////////
			index = (index + k + 1)%n;
			if (k == n - 1) 
			{ ++space; ++index; }
		}
		cout << ""q "" << n / 2 << endl;
		for (auto& i : nodepairs) cout << i.first->index << "" > "" << i.second->index << endl;
		for (auto& i : nodepairs)
		{
			cin >> temp;
			if (temp == 1) i.first->lesser.push_back(i.second);
			else i.second->lesser.push_back(i.first);
		}
		if (sorted(nodes, n) != -1)
		{
			vector<int> ordered;
			node* iterate = nodes[sorted(nodes, n)];
			ordered.push_back(iterate->index);
			while (iterate->lesser.size() != 0)
			{
				int maxheight = 0,max,index = 0;
				for (auto i : iterate->lesser)
				{
					if (i->height(i, 1) > maxheight)
					{
						maxheight = i->height(i, 1);
						max = index;
					}
					++index;
				}
				iterate = iterate->lesser[max];
				ordered.push_back(iterate->index);
			}
			reverse(ordered.begin(), ordered.end());
			cout << ""a "";
			for (int i = 0; i < ordered.size() - 1; i++) cout << ordered[i] << "" "";
			cout << ordered[ordered.size() - 1];
			break;
		}
	}
	return 0;
}

","/code/Main.cpp: In function ‘int sorted(std::vector<node*>&, int&)’:
/code/Main.cpp:30:27: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<node*>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]
   30 |         for (int i = 0; i < nodes.size(); i++)
      |                         ~~^~~~~~~~~~~~~~
/code/Main.cpp: In function ‘void permutation(std::string)’:
/code/Main.cpp:38:9: error: ‘sort’ was not declared in this scope; did you mean ‘short’?
   38 |         sort(s.begin(), s.end());
      |         ^~~~
      |         short
/code/Main.cpp:41:18: error: ‘next_permutation’ was not declared in this scope; did you mean ‘permutation’?
   41 |         } while (next_permutation(s.begin(), s.end())); // std::next_permutation
      |                  ^~~~~~~~~~~~~~~~
      |                  permutation
/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:105:25: error: ‘reverse’ was not declared in this scope
  105 |                         reverse(ordered.begin(), ordered.end());
      |                         ^~~~~~~
/code/Main.cpp:107:43: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<int>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]
  107 |                         for (int i = 0; i < ordered.size() - 1; i++) cout << ordered[i] << "" "";
      |                                         ~~^~~~~~~~~~~~~~~~~~~~
/code/Main.cpp: In member function ‘int node::height(node*, int)’:
/code/Main.cpp:26:9: warning: control reaches end of non-void function [-Wreturn-type]
   26 |         }
      |         ^
",CERR,C++17,2022-07-30 14:18:21.29221,0
211,PinesCyrex,1,1007,"#include <iostream>
#include <map>
#include <typeinfo>
using namespace std;
int main() {
    int fenceCount;
    int qCount;
    cin >> fenceCount >> qCount;

    map<int, string> fenceMap;
    fenceMap[0] = ""white"";
    int* fences = new int[fenceCount];
    //std::fill_n(fences, fenceCount, ""white""); // initialize all fences to white

    int counter = 1;
    int retrieve;
    string qType;
    int first;
    int last;
    string color;
    bool existInMap;
    int existIndex;
    map<int, string>::iterator itr;
    for (int i = 0; i < qCount; i++) {
        cin >> qType;
        if (qType == ""q"") {
            cin >> retrieve;
            auto it = fenceMap.find(fences[retrieve - 1]);
            string result = it->second;
            cout << result << endl;
        } else {
            cin >> first >> last >> color;
            for(itr = fenceMap.begin(); itr != fenceMap.end(); itr++) {
                if (itr->second == color) {
                    existInMap = true;
                    existIndex = itr->first;
                }
            }
            if (!existInMap) {
                fenceMap[counter] = color;
            }
            
            for (int i = first - 1; i < last; i++) {
                if (existInMap) {
                    fences[i] = existIndex;
                } else {
                fences[i] = counter;
                }
            }
            counter++;
            existInMap = false;
        }
    }

    return 0;
}","Failed on case 4, test 0",MLE,C++17,2022-07-30 14:18:33.691197,60
212,Dragoneel,1,1006,"m = int(input()) - 1
s = ("" "" * (m))
print(s + "">\n"" + s + ""|\n"" + s + ""."")
for i in range(65,65+m):
    m=m-1
    print(("" "" * (m)) + ""/"",end="""")
    for k in range(65,i+1):
        print(chr(k),end="""")
    for j in range(i-1,64,-1):
        print(chr(j),end="""")  
    print('\\')","",AC,Python3,2022-07-30 14:19:45.696568,50
252,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    int plank;
    int query;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for (int i = 0; i < plank; i++) {
        fences[i] = ""white"";
    }
    string out = """";
    for (int i = 0; i < query; i++) {
        cin >> command;
        if (command == 'q') {
            int n;
            cin >> n;
            out.append(fences[n] + '\n');
        }
        if (command == 'p') {
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for (int i = start; i <= end; i++) {
                fences[i] = col;
            }
        }
    }
    cout << out;
    cout.flush();
}","WA on case 1, test 0",WA,C++17,2022-07-30 14:52:43.387123,0
213,datOvercommon,1,1005,"#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <queue>

using namespace std;

class node {
public:
	int index;
	vector<node*> lesser;
	node(int ind) : index(ind) { }
	int height(node* i, int height)
	{
		if (i->lesser.size() == 0) return 1;
		while (lesser.size() != 0)
		{
			int max = 0;
			for (auto& k : i->lesser)
			{
				if (i->height(k, height) > max) max = i->height(k, height);
			}
			return 1 + max;
		}
	}
};
int sorted(vector<node*>& nodes, int& n)
{
	for (int i = 0; i < nodes.size(); i++)
	{
		if (nodes[i]->height(nodes[i], 1) == n) return i;
	}
	return -1;
}
void permutation(string s)
{
	sort(s.begin(), s.end());
	do {
		cout << s << "" "";
	} while (next_permutation(s.begin(), s.end())); // std::next_permutation

	cout << endl;
}
int main()
{
	vector<node*> nodes;
	int n, m,temp;
	cin >> n;
	cin >> m;
	for (int i = 0; i < n; i++) 
	{ 
		node* newnode = new node(i);
		nodes.push_back(newnode); 
	}
	//while (!sorted(nodes,n))
	//{

	//}

	for (int k = 1; k < n; k++)
	{
		vector<pair<node*, node*>> nodepairs;
		int index = 0,space = 1;
		for (int i = 0; i < n / 2; i++)
		{
			space = (k + index) % n;
			if (k == n - 1 && i != 0) space = index + 1;
			//Run code
			nodepairs.push_back({ nodes[index], nodes[space] });

			/////////
			index = (index + k + 1)%n;
			if (k == n - 1) 
			{ ++space; ++index; }
		}
		cout << ""q "" << n / 2 << endl;
		for (auto& i : nodepairs) cout << i.first->index << "" > "" << i.second->index << endl;
		for (auto& i : nodepairs)
		{
			cin >> temp;
			if (temp == 1) i.first->lesser.push_back(i.second);
			else i.second->lesser.push_back(i.first);
		}
		if (sorted(nodes, n) != -1)
		{
			vector<int> ordered;
			node* iterate = nodes[sorted(nodes, n)];
			ordered.push_back(iterate->index);
			while (iterate->lesser.size() != 0)
			{
				int maxheight = 0,max,index = 0;
				for (auto i : iterate->lesser)
				{
					if (i->height(i, 1) > maxheight)
					{
						maxheight = i->height(i, 1);
						max = index;
					}
					++index;
				}
				iterate = iterate->lesser[max];
				ordered.push_back(iterate->index);
			}
			reverse(ordered.begin(), ordered.end());
			cout << ""a "";
			for (int i = 0; i < ordered.size() - 1; i++) cout << ordered[i] << "" "";
			cout << ordered[ordered.size() - 1] << endl;
			break;
		}
	}
	return 0;
}

","/code/Main.cpp: In function ‘int sorted(std::vector<node*>&, int&)’:
/code/Main.cpp:30:27: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<node*>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]
   30 |         for (int i = 0; i < nodes.size(); i++)
      |                         ~~^~~~~~~~~~~~~~
/code/Main.cpp: In function ‘void permutation(std::string)’:
/code/Main.cpp:38:9: error: ‘sort’ was not declared in this scope; did you mean ‘short’?
   38 |         sort(s.begin(), s.end());
      |         ^~~~
      |         short
/code/Main.cpp:41:18: error: ‘next_permutation’ was not declared in this scope; did you mean ‘permutation’?
   41 |         } while (next_permutation(s.begin(), s.end())); // std::next_permutation
      |                  ^~~~~~~~~~~~~~~~
      |                  permutation
/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:105:25: error: ‘reverse’ was not declared in this scope
  105 |                         reverse(ordered.begin(), ordered.end());
      |                         ^~~~~~~
/code/Main.cpp:107:43: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<int>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]
  107 |                         for (int i = 0; i < ordered.size() - 1; i++) cout << ordered[i] << "" "";
      |                                         ~~^~~~~~~~~~~~~~~~~~~~
/code/Main.cpp: In member function ‘int node::height(node*, int)’:
/code/Main.cpp:26:9: warning: control reaches end of non-void function [-Wreturn-type]
   26 |         }
      |         ^
",CERR,C++17,2022-07-30 14:19:47.607384,0
214,JavaScriptJatts,1,1007,"#include <bits/stdc++.h>

using namespace ::std;


class paint{
public:
    int start;
    int end;
    string color;

    paint(int start, int end, string color): start(start), end(end), color(color){}

};


void fix(vector<string>& fence, vector<paint>& instructions , int&N){

    vector<int> allowed(N+1, 1);

    int start,end;
    string color;

    for(int i = instructions.size()-1; i >= 0; i--){

        start = instructions[i].start;
        end = instructions[i].end;
        color = instructions[i].color;

        for(int j = start; j <= end; j++){
            if(allowed[j]){
                fence[j] = color;
                allowed[j] = 0;
            }
        }
    }

    instructions.clear();
}

int main() {
    int N;
    int Q;

    string option;
    int start;
    int end;

    int q;
    string color;

    cin >> N >> Q;

    vector<string> fence(N+1, ""white"");
    vector<paint> instructions;

    while(cin >> option){

        //while painting
        while(option == ""p""){
            cin >> start >> end >> color;
            paint obj(start,end,color);
            instructions.push_back(obj);
            cin >> option;
        }

        //else if q
        if(option == ""q""){
            fix(fence, instructions, N);
            cin >> q;
            cout << fence[q] << ""\n"";
        }
    }
}

// \o/
//  |
// /_\_","Failed on case 2, test 0",TLE,C++17,2022-07-30 14:20:02.814257,20
221,JavaScriptJatts,1,1007,"#include <bits/stdc++.h>

using namespace ::std;


class paint{
public:
    int start;
    int end;
    string color;

    paint(int start, int end, string color): start(start), end(end), color(color){}

};


void fix(vector<string>& fence, vector<paint*>& instructions , int&N){

    vector<int> allowed(N+1, 1);

    int start,end;
    string color;

    for(int i = instructions.size()-1; i >= 0; i--){

        start = instructions[i]->start;
        end = instructions[i]->end;
        color = instructions[i]->color;

        for(int j = start; j <= end; j++){
            if(allowed[j]){
                fence[j] = color;
                allowed[j] = 0;
            }
        }

        delete instructions[i];
    }

    instructions.clear();
}

int main() {
    int N;
    int Q;

    string option;
    int start;
    int end;

    int q;
    string color;

    cin >> N >> Q;

    vector<string> fence(N+1, ""white"");
    vector<paint*> instructions;

    while(cin >> option){

        //while painting
        while(option == ""p""){
            cin >> start >> end >> color;
            paint* obj = new paint(start,end,color);
            instructions.push_back(obj);
            cin >> option;
        }

        //else if q
        if(option == ""q""){
            fix(fence, instructions, N);
            cin >> q;
            cout << fence[q] << ""\n"";
        }
    }
}

// \o/
//  |
// /_\_","Failed on case 2, test 0",TLE,C++17,2022-07-30 14:25:37.964376,20
231,teamAverage,1,1009,"#include <iostream>
#include <ctime>
#include <cstdio>
#include <Windows.h>
using namespace std;
 
// change row and column value to set the canvas size
const int row = 24;
const int col = 80;

// returns the count of alive neighbours
int count_live_neighbour_cell(int a[row][col], int r, int c){
    int i, j, count = 0;
    for (i = r - 1; i <= r + 1; i++) {
        for (j = c - 1; j <= c + 1; j++) {
            if ((i == r && j == c) || (i < 0 || j < 0)
                || (i >= row || j >= col)) {
                continue;
            }
            if (a[i][j] == 1) {
                count++;
            }
        }
    }
    return count;
}
 
int main(){
    int a[row][col], b[row][col];
    int i, j;
    int neighbour_live_cell;

    srand(time(NULL));

    // generate matrix canvas with random values (live and
    // dead cells)
    for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++) {
            a[i][j] = rand() % 2;
        }
    }
 
    // print array matrix
    for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++) {
            if(b[i][j]==0){
                    cout<<'.';
                }
                else
                    cout<<'0';
        }
        cout << ""\n"";
    }
    int time = 30;
    time *= CLOCKS_PER_SEC;
    clock_t curr = clock();
    while(clock()-curr<time){
        // next canvas values based on live neighbour count
        for (i = 0; i < row; i++) {
            for (j = 0; j < col; j++) {
                neighbour_live_cell
                    = count_live_neighbour_cell(a, i, j);
                if (a[i][j] == 1
                    && (neighbour_live_cell == 2
                        || neighbour_live_cell == 3)) {
                    b[i][j] = 1;
                }
    
                else if (a[i][j] == 0
                        && neighbour_live_cell == 3) {
                    b[i][j] = 1;
                }
    
                else {
                    b[i][j] = 0;
                }
            }
        }
    
        // print next generation
        for (i = 0; i < row; i++) {
            for (j = 0; j < col; j++) {
                a[i][j] = b[i][j];
                if(b[i][j]==0){
                    cout<<' ';
                }
                else
                    cout<<'#';
            }
            cout << ""\n"";
        }
        Sleep(200);
    }
 
    return 0;
}","/code/Main.cpp:4:10: fatal error: Windows.h: No such file or directory
    4 | #include <Windows.h>
      |          ^~~~~~~~~~~
compilation terminated.
",CERR,C++17,2022-07-30 14:35:42.016356,0
215,datOvercommon,1,1005,"#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <queue>

using namespace std;

class node {
public:
	int index;
	vector<node*> lesser;
	node(int ind) : index(ind) { }
	int height(node* i, int height)
	{
		if (i->lesser.size() == 0) return 1;
		while (lesser.size() != 0)
		{
			int max = 0;
			for (auto& k : i->lesser)
			{
				if (i->height(k, height) > max) max = i->height(k, height);
			}
			return 1 + max;
		}
	}
};
int sorted(vector<node*>& nodes, int& n)
{
	for (int i = 0; i < nodes.size(); i++)
	{
		if (nodes[i]->height(nodes[i], 1) == n) return i;
	}
	return -1;
}
void permutation(string s)
{
	sort(s.begin(), s.end());
	do {
		cout << s << "" "";
	} while (next_permutation(s.begin(), s.end())); // std::next_permutation

	cout << endl;
}
int main()
{
	vector<node*> nodes;
	int n, m,temp;
	cin >> n;
	cin >> m;
	for (int i = 0; i < n; i++) 
	{ 
		node* newnode = new node(i);
		nodes.push_back(newnode); 
	}
	//while (!sorted(nodes,n))
	//{

	//}

	for (int k = 1; k < n; k++)
	{
		vector<pair<node*, node*>> nodepairs;
		int index = 0,space = 1;
		for (int i = 0; i < n / 2; i++)
		{
			space = (k + index) % n;
			if (k == n - 1 && i != 0) space = index + 1;
			//Run code
			nodepairs.push_back({ nodes[index], nodes[space] });

			/////////
			index = (index + k + 1)%n;
			if (k == n - 1) 
			{ ++space; ++index; }
		}
		cout << ""q "" << n / 2 << endl;
		for (auto& i : nodepairs) cout << i.first->index << "" > "" << i.second->index << endl;
		for (auto& i : nodepairs)
		{
			cin >> temp;
			if (temp == 1) i.first->lesser.push_back(i.second);
			else i.second->lesser.push_back(i.first);
		}
		if (sorted(nodes, n) != -1)
		{
			vector<int> ordered;
			node* iterate = nodes[sorted(nodes, n)];
			ordered.push_back(iterate->index);
			while (iterate->lesser.size() != 0)
			{
				int maxheight = 0,max,index = 0;
				for (auto i : iterate->lesser)
				{
					if (i->height(i, 1) > maxheight)
					{
						maxheight = i->height(i, 1);
						max = index;
					}
					++index;
				}
				iterate = iterate->lesser[max];
				ordered.push_back(iterate->index);
			}
			reverse(ordered.begin(), ordered.end());
			cout << ""a "";
			for (int i = 0; i < ordered.size() - 1; i++) cout << ordered[i] << "" "";
			cout << ordered[ordered.size() - 1] << endl;
			cin >> temp;
			break;
		}
	}
	return 0;
}

","/code/Main.cpp: In function ‘int sorted(std::vector<node*>&, int&)’:
/code/Main.cpp:30:27: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<node*>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]
   30 |         for (int i = 0; i < nodes.size(); i++)
      |                         ~~^~~~~~~~~~~~~~
/code/Main.cpp: In function ‘void permutation(std::string)’:
/code/Main.cpp:38:9: error: ‘sort’ was not declared in this scope; did you mean ‘short’?
   38 |         sort(s.begin(), s.end());
      |         ^~~~
      |         short
/code/Main.cpp:41:18: error: ‘next_permutation’ was not declared in this scope; did you mean ‘permutation’?
   41 |         } while (next_permutation(s.begin(), s.end())); // std::next_permutation
      |                  ^~~~~~~~~~~~~~~~
      |                  permutation
/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:105:25: error: ‘reverse’ was not declared in this scope
  105 |                         reverse(ordered.begin(), ordered.end());
      |                         ^~~~~~~
/code/Main.cpp:107:43: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<int>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]
  107 |                         for (int i = 0; i < ordered.size() - 1; i++) cout << ordered[i] << "" "";
      |                                         ~~^~~~~~~~~~~~~~~~~~~~
/code/Main.cpp: In member function ‘int node::height(node*, int)’:
/code/Main.cpp:26:9: warning: control reaches end of non-void function [-Wreturn-type]
   26 |         }
      |         ^
",CERR,C++17,2022-07-30 14:20:34.58306,0
216,datOvercommon,1,1006,"#include <iostream>
using namespace std;int main(){int n;cin>>n;for(int i=0;i<n+1;i++){cout<<"" "";}cout<<"">""<<endl;for(int i=0;i<n+1;i++){cout<<"" "";}cout<<""|""<<endl;for(int i=0;i<n+1;i++){cout<<"" "";}cout<<"".""<<endl;int l=n;int t=1;while(l-1>0){for(int i=0;i<l;i++){cout<<"" "";}cout<<""/"";for(int i=65;i<65+t;i++){cout<<char(i);}for(int i=64+t-1;i>64;i--){cout<<char(i);}cout<<""\\""<<endl;--l;++t;}}",,judging,C++17,2022-07-30 14:20:47.885076,0
217,datOvercommon,1,1006,"#include <iostream>
using namespace std;int main(){int n;cin>>n;for(int i=0;i<n+1;i++){cout<<"" "";}cout<<"">""<<endl;for(int i=0;i<n+1;i++){cout<<"" "";}cout<<""|""<<endl;for(int i=0;i<n+1;i++){cout<<"" "";}cout<<"".""<<endl;int l=n;int t=1;while(l-1>0){for(int i=0;i<l;i++){cout<<"" "";}cout<<""/"";for(int i=65;i<65+t;i++){cout<<char(i);}for(int i=64+t-1;i>64;i--){cout<<char(i);}cout<<""\\""<<endl;--l;++t;}}","",AC,C++17,2022-07-30 14:21:33.886211,50
218,duckduckdoo,1,1007,"
#include <iostream>
#include <unordered_map>
#include <map>
using namespace std;

int main() {
    int numFences, numQueries;
    cin>>numFences>>numQueries;
    unordered_map<int, string> f;
    map<int,string> tt; 
    for(int i = 0; i<numFences; i++){
        tt[i]= ""white"";
    }

    for (int i = 0; i < numQueries; i++) {
        char command;
        cin>>command;
        if (command == 'p') {
            int start, end;
            string color;
            cin>>start>>end>>color;
            for (int i = start-1; i < end; i++) {
                tt[i] = color;
            }
        }
        else if (command == 'q') {
            int fenceNum;
            cin>>fenceNum;
            cout<<tt[--fenceNum]<<endl;
        }
    }
}","Failed on case 2, test 0",TLE,C++17,2022-07-30 14:22:09.327127,20
219,Dragoneel,1,1006,"m = int(input()) - 1
s = ("" "" * (m))
print(s + "">\n"" + s + ""|\n"" + s + ""."")
for i in range(65,65+m):
    m=m-1
    print(("" "" * (m)) + ""/"",end="""")
    [print(chr(k),end="""") for k in range(65,i+1)]
    [print(chr(j),end="""") for j in range(i-1,64,-1)]
    print('\\')","",AC,Python3,2022-07-30 14:22:26.805677,50
220,JavaScriptJatts,1,1007,"#include <bits/stdc++.h>

using namespace ::std;


class paint{
public:
    int start;
    int end;
    string color;

    paint(int start, int end, string color): start(start), end(end), color(color){}

};


void fix(vector<string>& fence, vector<paint*>& instructions , int&N){

    vector<int> allowed(N+1, 1);

    int start,end;
    string color;

    for(int i = instructions.size()-1; i >= 0; i--){

        start = instructions[i]->start;
        end = instructions[i]->end;
        color = instructions[i]->color;

        for(int j = start; j <= end; j++){
            if(allowed[j]){
                fence[j] = color;
                allowed[j] = 0;
            }
        }

        delete instructions[i];
    }

    instructions.clear();
}

int main() {
    int N;
    int Q;

    string option;
    int start;
    int end;

    int q;
    string color;

    cin >> N >> Q;

    vector<string> fence(N+1, ""white"");
    vector<paint*> instructions;

    while(cin >> option){

        //while painting
        while(option == ""p""){
            cin >> start >> end >> color;
            paint* obj = new paint(start,end,color);
            instructions.push_back(obj);
            cin >> option;
        }

        //else if q
        if(option == ""q""){
            fix(fence, instructions, N);
            cin >> q;
            cout << fence[q] << ""\n"";
        }
    }
}

// \o/
//  |
// /_\_",judging failed,IERR,C++23,2022-07-30 14:25:16.212654,0
222,HS,1,1005,"
#include <bits/stdc++.h>
using namespace std;

struct Node_struct {
    vector<int> prev;
    vector<int> next;
};

int n, m;
vector<struct Node_struct> nodes;
int num_comparisons;
vector<pair<int, int>> comparison_targets;
vector<pair<int, int>> comparison_caller; // this is for change after comparison
vector<bool> in_targets;
vector<bool> visited;

// add to targets. increment num_comparisons
// option: (1: from prev), (2: from next)
void add_to_targets(const int& a, const int& b, const int& caller, const int& option) {
    //cout << ""-- add to targets: "" << a << "", "" << b 
        //<< "" caller "" << caller << "", option"" << option<< endl;
    comparison_targets.push_back(pair<int, int>(a, b));
    comparison_caller.push_back(pair<int, int>(caller, option));
    in_targets[a] = true;
    in_targets[b] = true;
    num_comparisons++;
}

/*DFS description:
    test if more than 2 prevs
        find possible targets and add
        return if (num_comparisons == m)
    test if more than 2 nexts
        find possible targets and add
        return if (num_comparisons == m)
    iterate nexts
        if not visited, DFS that.
        return if (num_comparisons == m)

*/
void DFS(const int& current) {
    visited[current] = true;
    if (nodes[current].prev.size() > 1) {
        int i = 0;
        while (num_comparisons < m && i < nodes[current].prev.size()) {
            int a = -1;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    a = nodes[current].prev[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    b = nodes[current].prev[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 1);
            }
        }
        if (num_comparisons == m) return;
    }
    if (nodes[current].next.size() > 1) {
        int i = 0;
        while (num_comparisons < m && i < nodes[current].next.size()) {
            int a = -1;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    a = nodes[current].next[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    b = nodes[current].next[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 2);
            }
        }
        if (num_comparisons == m) return;
    }

    // children
    for (int i = 0; i < nodes[current].next.size(); i++) {
        if (!visited[nodes[current].next[i]]) {
            //cout << ""--visiting child "" << nodes[current].next[i] << endl;
            DFS(nodes[current].next[i]);
            if (num_comparisons == m) return;
        }
    }
    for (int i = 0; i < nodes[current].prev.size(); i++) {
        if (!visited[nodes[current].prev[i]]) {
            //cout << ""--visiting parnet "" << nodes[current].next[i] << endl;
            DFS(nodes[current].prev[i]);
            if (num_comparisons == m) return;
        }
    }
}

int main()
{
    cin >> n >> m;
    
    nodes = vector<struct Node_struct>(n);
    
    bool ans_found = false;
    while (!ans_found) {
        num_comparisons = 0;
        comparison_targets.clear();
        comparison_caller.clear();
        in_targets = vector<bool>(n, false);
        visited = vector<bool>(n, false);
        
        int last_DFS_start = -1;
        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            //cout << ""--loop "" << i << endl;
            // connect disconnected graph
            if (last_DFS_start != -1) {
                for (int j = i-1; j >= 0; j--) {
                    if (!in_targets[j]) {
                        add_to_targets(j, i, -1, -1);
                        break;
                    }
                }
                if (num_comparisons == m) break;
            }
            // run DFS
            //cout << ""--running DFS"" << endl;
            DFS(i);
            last_DFS_start = i;
            //cout << ""-- num comparisons: "" << num_comparisons << endl;
            if (num_comparisons == m) break;
        }
        
        // break if no change
        if (num_comparisons == 0) break;
        // send query
        cout << ""q "" << num_comparisons << endl;
        for (int i = 0; i < num_comparisons; i++) {
             cout << comparison_targets[i].first << "" < "" << comparison_targets[i].second << endl;
        }
        // receive input
        for (int i = 0; i < num_comparisons; i++) {
            int ans;
            cin >> ans;
            
            // get 2 target nodes
            int a, b; // a <= b
            if (ans == 1) {
                a = comparison_targets[i].first;
                b = comparison_targets[i].second;
            }
            else {
                a = comparison_targets[i].second;
                b = comparison_targets[i].first;
            }
            // get caller and option
            int caller = comparison_caller[i].first;
            int option = comparison_caller[i].second;
            
            // connect two nodes
            //cout << ""--edge created between "" << a << "" -> "" << b << endl;
            nodes[a].next.push_back(b);
            nodes[b].prev.push_back(a);
            
            if (caller == -1) {
                // called to connect disconnected graphs
                // do nothing
                //cout << ""--no removal as no caller node"" << endl;
            }
            else if (option == 1) {
                // called from caller's prev
                //cout << ""--(op1)removed link between "" << caller << "" and "" << a << endl;
                auto to_remove = find(nodes[caller].prev.begin(), nodes[caller].prev.end(), a);
                nodes[caller].prev.erase(to_remove);
                to_remove = find(nodes[a].next.begin(), nodes[a].next.end(), caller);
                nodes[a].next.erase(to_remove);
            }
            else if (option == 2) {
                // called from caller's next
                //cout << ""--(op2)removed link between "" << caller << "" and "" << b << endl;
                auto to_remove = find(nodes[caller].next.begin(), nodes[caller].next.end(), b);
                nodes[caller].next.erase(to_remove);
                to_remove = find(nodes[b].prev.begin(), nodes[b].prev.end(), caller);
                nodes[b].prev.erase(to_remove);
            }
        }
    }
    if (num_comparisons == 0) {
        // start from the very first
        int current = 0;
        while (nodes[current].prev.size() != 0) {
            current = nodes[current].prev[0];
        }
        cout << ""a "";
        while (nodes[current].next.size() != 0) {
            cout << current << "" "";
            current = nodes[current].next[0];
        }
        cout << current << "" "";
        cout << endl;
    }
    int result;
    cin >> result;

    return 0;
}
","WA on case 0, test 4",WA,C++17,2022-07-30 14:26:11.646916,0
223,datOvercommon,1,1007,"import os
import sys

plank1 = list(map(int, input().split()))
query = plank1[1]
plank = plank1[0]

fences = {}

for x in range(1, plank+1):
    fences.update({x: ""white""})

out = []
for x in range(query):
    command = list(input().split())
    if command[0] == 'q':
        n = command[1]
        out.append(fences.get(int(n)))
    if command[0] == 'p':
        start = int(command[1])
        end = int(command[2])
        col = command[3]
        for x in range(start, end+1):
            fences[x] = col

for x in out:
    print(x)
","Failed on case 2, test 0",TLE,Python3,2022-07-30 14:27:20.662493,20
224,duckduckdoo,1,1007,"
#include <iostream>
#include <map>
using namespace std;

int main() {
    int numFences, numQueries;
    cin>>numFences>>numQueries;
    map<int,string> tt; 
    for (int i = 0; i < numQueries; i++) {
        char command;
        cin>>command;
        if (command == 'p') {
            int start, end;
            string color;
            cin>>start>>end>>color;
            for (int i = start-1; i < end; i++) {
                tt[i] = color;
            }
        }
        else if (command == 'q') {
            cin>>numFences;
            (tt.find(--numFences) == tt.end()) ?
            cout<<""white""<<endl :
            cout<<tt[numFences]<<endl;
        }
    }
}","Failed on case 2, test 0",TLE,C++17,2022-07-30 14:29:02.08778,20
233,HS,1,1005,"
#include <bits/stdc++.h>
using namespace std;

struct Node_struct {
    vector<int> prev;
    vector<int> next;
};

int n, m;
vector<struct Node_struct> nodes;
int num_comparisons;
vector<pair<int, int>> comparison_targets;
vector<pair<int, int>> comparison_caller; // this is for change after comparison
vector<bool> in_targets;
vector<bool> visited;

// add to targets. increment num_comparisons
// option: (1: from prev), (2: from next)
void add_to_targets(const int& a, const int& b, const int& caller, const int& option) {
    //cout << ""-- add to targets: "" << a << "", "" << b 
        //<< "" caller "" << caller << "", option"" << option<< endl;
    comparison_targets.push_back(pair<int, int>(a, b));
    comparison_caller.push_back(pair<int, int>(caller, option));
    in_targets[a] = true;
    in_targets[b] = true;
    num_comparisons++;
}

/*DFS description:
    test if more than 2 prevs
        find possible targets and add
        return if (num_comparisons == m)
    test if more than 2 nexts
        find possible targets and add
        return if (num_comparisons == m)
    iterate nexts
        if not visited, DFS that.
        return if (num_comparisons == m)

*/
void DFS(const int& current) {
    visited[current] = true;
    if (nodes[current].prev.size() > 1) {
        int i = 0;
        while (num_comparisons < m && i < nodes[current].prev.size()) {
            int a = -1;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    a = nodes[current].prev[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    b = nodes[current].prev[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 1);
            }
        }
        if (num_comparisons == m) return;
    }
    if (nodes[current].next.size() > 1) {
        int i = 0;
        while (num_comparisons < m && i < nodes[current].next.size()) {
            int a = -1;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    a = nodes[current].next[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    b = nodes[current].next[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 2);
            }
        }
        if (num_comparisons == m) return;
    }

    // children
    for (int i = 0; i < nodes[current].next.size(); i++) {
        if (!visited[nodes[current].next[i]]) {
            //cout << ""--visiting child "" << nodes[current].next[i] << endl;
            DFS(nodes[current].next[i]);
            if (num_comparisons == m) return;
        }
    }
    for (int i = 0; i < nodes[current].prev.size(); i++) {
        if (!visited[nodes[current].prev[i]]) {
            //cout << ""--visiting parnet "" << nodes[current].next[i] << endl;
            DFS(nodes[current].prev[i]);
            if (num_comparisons == m) return;
        }
    }
}

int main()
{
    cin >> n >> m;
    
    nodes = vector<struct Node_struct>(n);
    
    bool ans_found = false;
    while (!ans_found) {
        num_comparisons = 0;
        comparison_targets.clear();
        comparison_caller.clear();
        in_targets = vector<bool>(n, false);
        visited = vector<bool>(n, false);
        
        int last_DFS_start = -1;
        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            //cout << ""--loop "" << i << endl;
            // connect disconnected graph
            if (last_DFS_start != -1) {
                for (int j = i-1; j >= 0; j--) {
                    if (!in_targets[j]) {
                        add_to_targets(j, i, -1, -1);
                        break;
                    }
                }
                if (num_comparisons == m) break;
            }
            // run DFS
            //cout << ""--running DFS"" << endl;
            DFS(i);
            last_DFS_start = i;
            //cout << ""-- num comparisons: "" << num_comparisons << endl;
            if (num_comparisons == m) break;
        }
        
        // break if no change
        if (num_comparisons == 0) break;
        // send query
        cout << ""q "" << num_comparisons << endl;
        for (int i = 0; i < num_comparisons; i++) {
             cout << comparison_targets[i].first << "" < "" << comparison_targets[i].second << endl;
        }
        cout << flush;
        // receive input
        for (int i = 0; i < num_comparisons; i++) {
            int ans;
            cin >> ans;
            
            // get 2 target nodes
            int a, b; // a <= b
            if (ans == 1) {
                a = comparison_targets[i].first;
                b = comparison_targets[i].second;
            }
            else {
                a = comparison_targets[i].second;
                b = comparison_targets[i].first;
            }
            // get caller and option
            int caller = comparison_caller[i].first;
            int option = comparison_caller[i].second;
            
            // connect two nodes
            //cout << ""--edge created between "" << a << "" -> "" << b << endl;
            nodes[a].next.push_back(b);
            nodes[b].prev.push_back(a);
            
            if (caller == -1) {
                // called to connect disconnected graphs
                // do nothing
                //cout << ""--no removal as no caller node"" << endl;
            }
            else if (option == 1) {
                // called from caller's prev
                //cout << ""--(op1)removed link between "" << caller << "" and "" << a << endl;
                auto to_remove = find(nodes[caller].prev.begin(), nodes[caller].prev.end(), a);
                nodes[caller].prev.erase(to_remove);
                to_remove = find(nodes[a].next.begin(), nodes[a].next.end(), caller);
                nodes[a].next.erase(to_remove);
            }
            else if (option == 2) {
                // called from caller's next
                //cout << ""--(op2)removed link between "" << caller << "" and "" << b << endl;
                auto to_remove = find(nodes[caller].next.begin(), nodes[caller].next.end(), b);
                nodes[caller].next.erase(to_remove);
                to_remove = find(nodes[b].prev.begin(), nodes[b].prev.end(), caller);
                nodes[b].prev.erase(to_remove);
            }
        }
    }
    if (num_comparisons == 0) {
        // start from the very first
        int current = 0;
        while (nodes[current].prev.size() != 0) {
            current = nodes[current].prev[0];
        }
        cout << ""a "";
        while (nodes[current].next.size() != 0) {
            cout << current << "" "";
            current = nodes[current].next[0];
        }
        cout << current << "" "";
        cout << endl << flush;
    }
    int result;
    cin >> result;

    return 0;
}
","WA on case 0, test 5",WA,C++17,2022-07-30 14:38:30.718454,0
234,datOvercommon,1,1005,"#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <queue>

using namespace std;

class node {
public:
	int index;
	vector<node*> lesser;
	node(int ind) : index(ind) { }
	int height(node* i, int height)
	{
		if (i->lesser.size() == 0) return 1;
		while (lesser.size() != 0)
		{
			int max = 0;
			for (auto& k : i->lesser)
			{
				if (i->height(k, height) > max) max = i->height(k, height);
			}
			return 1 + max;
		}
	}
};
int sorted(vector<node*>& nodes, int& n)
{
	for (int i = 0; i < nodes.size(); i++)
	{
		if (nodes[i]->height(nodes[i], 1) == n) return i;
	}
	return -1;
}
void permutation(string s)
{
	sort(s.begin(), s.end());
	do {
		cout << s << "" "";
	} while (next_permutation(s.begin(), s.end())); // std::next_permutation

	cout << endl;
}
int main()
{
	vector<node*> nodes;
	int n, m,temp;
	cin >> n;
	if (n == -1) return 0;
	cin >> m;
	if (m == -1) return 0;

	for (int i = 0; i < n; i++) 
	{ 
		node* newnode = new node(i);
		nodes.push_back(newnode); 
	}
	//while (!sorted(nodes,n))
	//{

	//}

	for (int k = 0; k < n; k++)
	{
		vector<pair<node*, node*>> nodepairs;
		int index = k,space = 1;
		for (int i = 0; i < n/2; i++)
		{
			space = (index + 1) % n;
			//Run code
			nodepairs.push_back({ nodes[index], nodes[space] });
			index = (index + 2) % n;
		}
		cout << ""q "" << n / 2 << endl;
		for (auto& i : nodepairs) cout << i.first->index << "" > "" << i.second->index << endl;
		for (auto& i : nodepairs)
		{
			cin >> temp;
			if (temp == -1) return 0;
			if (temp == 1) i.first->lesser.push_back(i.second);
			else i.second->lesser.push_back(i.first);
		}
		if (sorted(nodes, n) != -1)
		{
			vector<int> ordered;
			node* iterate = nodes[sorted(nodes, n)];
			ordered.push_back(iterate->index);
			while (iterate->lesser.size() != 0)
			{
				int maxheight = 0,max,index = 0;
				for (auto i : iterate->lesser)
				{
					if (i->height(i, 1) > maxheight)
					{
						maxheight = i->height(i, 1);
						max = index;
					}
					++index;
				}
				iterate = iterate->lesser[max];
				ordered.push_back(iterate->index);
			}
			reverse(ordered.begin(), ordered.end());
			cout << ""a "";
			for (int i = 0; i < ordered.size() - 1; i++) cout << ordered[i] << "" "";
			cout << ordered[ordered.size() - 1] << endl;
			cin >> temp;
			break;
		}
	}
	return 0;
}

","/code/Main.cpp: In function ‘int sorted(std::vector<node*>&, int&)’:
/code/Main.cpp:30:27: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<node*>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]
   30 |         for (int i = 0; i < nodes.size(); i++)
      |                         ~~^~~~~~~~~~~~~~
/code/Main.cpp: In function ‘void permutation(std::string)’:
/code/Main.cpp:38:9: error: ‘sort’ was not declared in this scope; did you mean ‘short’?
   38 |         sort(s.begin(), s.end());
      |         ^~~~
      |         short
/code/Main.cpp:41:18: error: ‘next_permutation’ was not declared in this scope; did you mean ‘permutation’?
   41 |         } while (next_permutation(s.begin(), s.end())); // std::next_permutation
      |                  ^~~~~~~~~~~~~~~~
      |                  permutation
/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:104:25: error: ‘reverse’ was not declared in this scope
  104 |                         reverse(ordered.begin(), ordered.end());
      |                         ^~~~~~~
/code/Main.cpp:106:43: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<int>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]
  106 |                         for (int i = 0; i < ordered.size() - 1; i++) cout << ordered[i] << "" "";
      |                                         ~~^~~~~~~~~~~~~~~~~~~~
/code/Main.cpp: In member function ‘int node::height(node*, int)’:
/code/Main.cpp:26:9: warning: control reaches end of non-void function [-Wreturn-type]
   26 |         }
      |         ^
",CERR,C++17,2022-07-30 14:38:38.084494,0
235,FuduBoys,1,1007,"nums = list(map(int, input().split()))
planks = {}

for i in range(nums[1]):
    query = input().split()
    if query[0] == 'p':
        for j in range(int(query[1]) - 1, int(query[2])):
            planks[j] = query[3]
    else:
        if (int(query[1]) - 1) not in planks:
            print('white')
        else:
            print(planks[int(query[1]) - 1])","Failed on case 2, test 0",TLE,Python3,2022-07-30 14:38:50.333539,20
236,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

int main(){
    //initialize map and iterator
    unordered_map<int, string> fences;

    //read the number of fences and queries
    int numFences;
    int numQueries;
    cin >> numFences >> numQueries;

    //initialize all the variables needed
    char type;

    //take the input in a loop
    for(int i = 0; i < numQueries; i++){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            string color;
            cin >> start >> end;
            cin >> color;
            //modify the fences' colors
            for(int j = start; j <= end; j++){
                fences[j] = color;
            }
        }
        else if(type == 'q'){
            //take in 1 input
            int key;
            cin >> key;
            try{
                cout << fences.at(key) << endl;
            }
            catch (...){
                cout << ""white"" << endl;
            }
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 14:38:54.558593,40
237,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(){
    //initialize map and iterator
    map<int, string> fences;

    //read the number of fences and queries
    int numFences;
    int numQueries;
    cin >> numFences >> numQueries;

    //initialize all the variables needed
    char type;

    //take the input in a loop
    for(int i = 0; i < numQueries; i++){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            string color;
            cin >> start >> end;
            cin >> color;
            //modify the fences' colors
            for(int j = start; j <= end; j++){
                fences[j] = color;
            }
        }
        else if(type == 'q'){
            //take in 1 input
            int key;
            cin >> key;
            try{
                cout << fences.at(key) << endl;
            }
            catch (...){
                cout << ""white"" << endl;
            }
        }
    }
}","Failed on case 2, test 0",TLE,C++17,2022-07-30 14:40:11.690613,20
254,Dragoneel,1,1007,"import os
from tkinter import N
# Sample Input
# 10 5
# q 1
# p 2 4 black
# p 1 2 green
# q 2
# q 3
# Sample Output
# white
# green
# black


    
    
def show_names(choice):
    for i in range(int(choice[1]), int(choice[2])+1):
        planks[i] = choice[3]
    
        
def get_new_name(ent):
    print(planks[ent])


### MAIN PROGRAM ###

# Set up a loop where users can choose what they'd like to do.

n = 10 
q = 5
nums = list(map(int, input().split()))
planks = [""white""] * nums[0]
print(planks)
while nums[1] != 0:    
    
    choice = list(input().split())
    
    # Respond to the user's choice.
    
    if choice[0] == 'p':
        show_names(choice)
    elif choice[0] == 'q':
        get_new_name(int(choice[1]))
    else:
        print(""\nI didn't understand that choice.\n"")","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 2, in <module>
    from tkinter import N
ModuleNotFoundError: No module named 'tkinter'
",ERR,Python3,2022-07-30 14:53:44.786601,0
238,JavaScriptJatts,1,1009,"const WIDTH = 80, HEIGHT = 24, FPS = 5;

const RESET = '\x1b[0m'
const BRIGHT = '\x1b[1m'
const DIM = '\x1b[2m'
const UNDERSCORE = '\x1b[4m'
const BLINK = '\x1b[5m'
const REVERSE = '\x1b[7m'
const HIDDEN = '\x1b[8m'

const FG_BLACK = '\x1b[30m'
const FG_RED = '\x1b[31m'
const FG_GREEN = '\x1b[32m'
const FG_YELLOW = '\x1b[33m'
const FG_BLUE = '\x1b[34m'
const FG_MAGENTA = '\x1b[35m'
const FG_CYAN = '\x1b[36m'
const FG_WHITE = '\x1b[37m'

const BG_BLACK = '\x1b[40m'
const BG_RED = '\x1b[41m'
const BG_GREEN = '\x1b[42m'
const BG_YELLOW = '\x1b[43m'
const BG_BLUE = '\x1b[44m'
const BG_MAGENTA = '\x1b[45m'
const BG_CYAN = '\x1b[46m'
const BG_WHITE = '\x1b[47m'

const texture = [' ', '.', ',', ':', ';', '!', '$', '?', '#', '@']

const buffer = new Array(WIDTH)
for (let i = 0; i < WIDTH; i++) {
    buffer[i] = new Array(HEIGHT)
}

const clearBuffer = (n = 0) => {
    for (let i = 0; i < WIDTH; i++) {
        for (let j = 0; j < HEIGHT; j++) {
            buffer[i][j] = n;
        }
    }
}

const drawBuffer = () => {
    let str = '';
    for (let y = 0; y < HEIGHT; y++) {
        for (let x = 0; x < WIDTH; x++) {
            // process.stdout.write(texture[buffer[x][y]])
            str += isNaN(buffer[x][y]) ? buffer[x][y] ?? ' ' : texture[buffer[x][y]] ?? ' ';
        }
        // process.stdout.write('\n')
        str += '\n';
    }
    process.stdout.write(str + '\n')
}

const clamp = (n, min, max) => Math.max(Math.min(n, max), min);
const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

class Particle {
    constructor(x, y, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.x = clamp(this.x, 0, WIDTH - 1);
        this.y = clamp(this.y, 0, HEIGHT - 1);
    }

    draw() {
        buffer[this.x][this.y] = 1;
    }
}

class Line {
    static #angles = {
        0: '-',
        45: '\\',
        90: '|',
        135: '/'
    }

    constructor(x1, y1, x2, y2, vx = 0, vy = 0) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.vx = vx;
        this.vy = vy;
    }

    update() {
        this.x1 += this.vx;
        this.y1 += this.vy;
        this.x2 += this.vx;
        this.y2 += this.vy;
        this.x1 = clamp(this.x1, 0, WIDTH - 1);
        this.y1 = clamp(this.y1, 0, HEIGHT - 1);
        this.x2 = clamp(this.x2, 0, WIDTH - 1);
        this.y2 = clamp(this.y2, 0, HEIGHT - 1);
    }

    draw() {
        const x1 = this.x1;
        const y1 = this.y1;
        const x2 = this.x2;
        const y2 = this.y2;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        console.log(angle)
        const length = Math.sqrt(dx ** 2 + dy ** 2);
        const angleStr = Line.#angles[Math.round(angle)];
        for (let i = 0; i < length; i++) {
            const x = x1 + i * dx / length;
            const y = y1 + i * dy / length;
            buffer[Math.round(x)][Math.round(y)] = 1;
            if (angleStr) {
                buffer[Math.round(x)][Math.round(y) + 1] = angleStr;
            }
        }
    }
}

const cop =
    ` ____          
 | *|          
 ======        
( う-´)づ︻╦̵̵̿╤── `.split('\n').map(line => line.split(''))

const drawCop = (x, y) => {
    for (let i = 0; i < cop.length; i++) {
        for (let j = 0; j < cop[i].length; j++) {
            buffer[x + j][y + i] = cop[i][j];
        }
    }
}

const victim =
    `


\\(˚☐˚”)/`.split('\n').map(line => line.split(''))

const drawVictim = (x, y) => {
    for (let i = 0; i < victim.length; i++) {
        for (let j = 0; j < victim[i].length; j++) {
            buffer[x + j][y + i] = victim[i][j];
        }
    }
}

const drawText = (x, y, text) => {
    for (let i = 0; i < text.length; i++) {
        buffer[x + i][y] = text[i];
    }
}

const p = new Particle(WIDTH / 4 + cop[0].length, HEIGHT / 2 + 1, 2);
let frame = 0;
setInterval(() => {
    clearBuffer()
    buffer[0][0] = FG_YELLOW
    drawCop(frame < WIDTH / 4 ? frame : WIDTH / 4, HEIGHT / 2 - cop.length / 2)
    if (frame > WIDTH / 4 && p.x < WIDTH / 4 * 3) {
        buffer[0][0] = FG_RED
        p.update();
        p.draw();
    }
    drawVictim(WIDTH / 4 * 3, HEIGHT / 2 - victim.length / 2);
    if (p.x > WIDTH / 4 * 3) {
        buffer[0][0] = RESET
        drawText(WIDTH / 4 * 3, HEIGHT / 2 - victim.length / 2, 'ouch');
    }
    if (frame > WIDTH / 4 * 3) {
        p.x = WIDTH / 4 + cop[0].length;
        frame = 0;
    }
    drawBuffer()
    frame++;
}, 1000 / FPS)
",Only your latest submission will be checked,AC,NodeJS,2022-07-30 14:40:59.862596,10
239,JavaScriptJatts,1,1009,"const WIDTH = 80, HEIGHT = 24, FPS = 5;

const RESET = '\x1b[0m'
const BRIGHT = '\x1b[1m'
const DIM = '\x1b[2m'
const UNDERSCORE = '\x1b[4m'
const BLINK = '\x1b[5m'
const REVERSE = '\x1b[7m'
const HIDDEN = '\x1b[8m'

const FG_BLACK = '\x1b[30m'
const FG_RED = '\x1b[31m'
const FG_GREEN = '\x1b[32m'
const FG_YELLOW = '\x1b[33m'
const FG_BLUE = '\x1b[34m'
const FG_MAGENTA = '\x1b[35m'
const FG_CYAN = '\x1b[36m'
const FG_WHITE = '\x1b[37m'

const BG_BLACK = '\x1b[40m'
const BG_RED = '\x1b[41m'
const BG_GREEN = '\x1b[42m'
const BG_YELLOW = '\x1b[43m'
const BG_BLUE = '\x1b[44m'
const BG_MAGENTA = '\x1b[45m'
const BG_CYAN = '\x1b[46m'
const BG_WHITE = '\x1b[47m'

const texture = [' ', '.', ',', ':', ';', '!', '$', '?', '#', '@']

const buffer = new Array(WIDTH)
for (let i = 0; i < WIDTH; i++) {
    buffer[i] = new Array(HEIGHT)
}

const clearBuffer = (n = 0) => {
    for (let i = 0; i < WIDTH; i++) {
        for (let j = 0; j < HEIGHT; j++) {
            buffer[i][j] = n;
        }
    }
}

const drawBuffer = () => {
    let str = '';
    for (let y = 0; y < HEIGHT; y++) {
        for (let x = 0; x < WIDTH; x++) {
            // process.stdout.write(texture[buffer[x][y]])
            str += isNaN(buffer[x][y]) ? buffer[x][y] ?? ' ' : texture[buffer[x][y]] ?? ' ';
        }
        // process.stdout.write('\n')
        str += '\n';
    }
    process.stdout.write(str + '\n')
}

const clamp = (n, min, max) => Math.max(Math.min(n, max), min);
const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

class Particle {
    constructor(x, y, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.x = clamp(this.x, 0, WIDTH - 1);
        this.y = clamp(this.y, 0, HEIGHT - 1);
    }

    draw() {
        buffer[this.x][this.y] = 1;
    }
}

class Line {
    static #angles = {
        0: '-',
        45: '\\',
        90: '|',
        135: '/'
    }

    constructor(x1, y1, x2, y2, vx = 0, vy = 0) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.vx = vx;
        this.vy = vy;
    }

    update() {
        this.x1 += this.vx;
        this.y1 += this.vy;
        this.x2 += this.vx;
        this.y2 += this.vy;
        this.x1 = clamp(this.x1, 0, WIDTH - 1);
        this.y1 = clamp(this.y1, 0, HEIGHT - 1);
        this.x2 = clamp(this.x2, 0, WIDTH - 1);
        this.y2 = clamp(this.y2, 0, HEIGHT - 1);
    }

    draw() {
        const x1 = this.x1;
        const y1 = this.y1;
        const x2 = this.x2;
        const y2 = this.y2;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        console.log(angle)
        const length = Math.sqrt(dx ** 2 + dy ** 2);
        const angleStr = Line.#angles[Math.round(angle)];
        for (let i = 0; i < length; i++) {
            const x = x1 + i * dx / length;
            const y = y1 + i * dy / length;
            buffer[Math.round(x)][Math.round(y)] = 1;
            if (angleStr) {
                buffer[Math.round(x)][Math.round(y) + 1] = angleStr;
            }
        }
    }
}

const cop =
    ` ____          
 | *|          
 ======        
( う-´)づ︻╦̵̵̿╤── `.split('\n').map(line => line.split(''))

const drawCop = (x, y) => {
    for (let i = 0; i < cop.length; i++) {
        for (let j = 0; j < cop[i].length; j++) {
            buffer[x + j][y + i] = cop[i][j];
        }
    }
}

const victim =
    `


\\(˚☐˚”)/`.split('\n').map(line => line.split(''))

const drawVictim = (x, y) => {
    for (let i = 0; i < victim.length; i++) {
        for (let j = 0; j < victim[i].length; j++) {
            buffer[x + j][y + i] = victim[i][j];
        }
    }
}

const drawText = (x, y, text) => {
    for (let i = 0; i < text.length; i++) {
        buffer[x + i][y] = text[i];
    }
}

const p = new Particle(WIDTH / 4 + cop[0].length, HEIGHT / 2 + 1, 2);
let frame = 0;
let time = 0;
setInterval(() => {
    clearBuffer()
    buffer[0][0] = FG_YELLOW
    drawCop(frame < WIDTH / 4 ? frame : WIDTH / 4, HEIGHT / 2 - cop.length / 2)
    if (frame > WIDTH / 4 && p.x < WIDTH / 4 * 3) {
        buffer[0][0] = FG_RED
        p.update();
        p.draw();
    }
    drawVictim(WIDTH / 4 * 3, HEIGHT / 2 - victim.length / 2);
    if (p.x > WIDTH / 4 * 3) {
        buffer[0][0] = RESET
        drawText(WIDTH / 4 * 3, HEIGHT / 2 - victim.length / 2, 'ouch');
    }
    if (frame > WIDTH / 4 * 3) {
        // p.x = WIDTH / 4 + cop[0].length;
        // frame = 0;
        process.exit()
    }
    drawBuffer()
    frame++;
    time += 1000 / FPS;
}, 1000 / FPS)
",Only your latest submission will be checked,AC,NodeJS,2022-07-30 14:43:46.657465,10
240,HS,1,1005,"
#include <bits/stdc++.h>
using namespace std;

struct Node_struct {
    vector<int> prev;
    vector<int> next;
};

int n, m;
vector<struct Node_struct> nodes;
int num_comparisons;
vector<pair<int, int>> comparison_targets;
vector<pair<int, int>> comparison_caller; // this is for change after comparison
vector<bool> in_targets;
vector<bool> visited;

// add to targets. increment num_comparisons
// option: (1: from prev), (2: from next)
void add_to_targets(const int& a, const int& b, const int& caller, const int& option) {
    comparison_targets.push_back(pair<int, int>(a, b));
    comparison_caller.push_back(pair<int, int>(caller, option));
    in_targets[a] = true;
    in_targets[b] = true;
    num_comparisons++;
}

/*DFS description:
    test if more than 2 prevs
        find possible targets and add
        return if (num_comparisons == m)
    test if more than 2 nexts
        find possible targets and add
        return if (num_comparisons == m)
    iterate nexts
        if not visited, DFS that.
        return if (num_comparisons == m)
*/
void DFS(const int& current) {
    visited[current] = true;
    if (nodes[current].prev.size() > 1) {
        int i = 0;
        while (num_comparisons < m && i < nodes[current].prev.size()) {
            int a = -1;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    a = nodes[current].prev[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    b = nodes[current].prev[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 1);
            }
        }
        if (num_comparisons == m) return;
    }
    if (nodes[current].next.size() > 1) {
        int i = 0;
        while (num_comparisons < m && i < nodes[current].next.size()) {
            int a = -1;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    a = nodes[current].next[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    b = nodes[current].next[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 2);
            }
        }
        if (num_comparisons == m) return;
    }

    // children
    for (int i = 0; i < nodes[current].next.size(); i++) {
        if (!visited[nodes[current].next[i]]) {
            DFS(nodes[current].next[i]);
            if (num_comparisons == m) return;
        }
    }
    for (int i = 0; i < nodes[current].prev.size(); i++) {
        if (!visited[nodes[current].prev[i]]) {
            DFS(nodes[current].prev[i]);
            if (num_comparisons == m) return;
        }
    }
}

int main()
{
    cin >> n >> m;
    
    nodes = vector<struct Node_struct>(n);
    
    bool ans_found = false;
    while (!ans_found) {
        num_comparisons = 0;
        comparison_targets.clear();
        comparison_caller.clear();
        in_targets = vector<bool>(n, false);
        visited = vector<bool>(n, false);
        
        int last_DFS_start = -1;
        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            // connect disconnected graph
            if (last_DFS_start != -1) {
                for (int j = i-1; j >= 0; j--) {
                    if (!in_targets[j]) {
                        add_to_targets(j, i, -1, -1);
                        break;
                    }
                }
                if (num_comparisons == m) break;
            }
            // run DFS
            DFS(i);
            last_DFS_start = i;
            if (num_comparisons == m) break;
        }
        
        // break if no change
        if (num_comparisons == 0) break;
        // send query
        cout << ""q "" << num_comparisons << endl;
        for (int i = 0; i < num_comparisons; i++) {
             cout << comparison_targets[i].first << "" < "" << comparison_targets[i].second << endl;
        }
        cout << flush;
        // receive input
        for (int i = 0; i < num_comparisons; i++) {
            int ans;
            cin >> ans;
            
            // get 2 target nodes
            int a, b; // a <= b
            if (ans == 1) {
                a = comparison_targets[i].first;
                b = comparison_targets[i].second;
            }
            else {
                a = comparison_targets[i].second;
                b = comparison_targets[i].first;
            }
            // get caller and option
            int caller = comparison_caller[i].first;
            int option = comparison_caller[i].second;
            
            // connect two nodes
            //cout << ""--edge created between "" << a << "" -> "" << b << endl;
            nodes[a].next.push_back(b);
            nodes[b].prev.push_back(a);
            
            if (caller == -1) {
                // called to connect disconnected graphs
                // do nothing
            }
            else if (option == 1) {
                // called from caller's prev
                auto to_remove = find(nodes[caller].prev.begin(), nodes[caller].prev.end(), a);
                nodes[caller].prev.erase(to_remove);
                to_remove = find(nodes[a].next.begin(), nodes[a].next.end(), caller);
                nodes[a].next.erase(to_remove);
            }
            else if (option == 2) {
                // called from caller's next
                auto to_remove = find(nodes[caller].next.begin(), nodes[caller].next.end(), b);
                nodes[caller].next.erase(to_remove);
                to_remove = find(nodes[b].prev.begin(), nodes[b].prev.end(), caller);
                nodes[b].prev.erase(to_remove);
            }
        }
    }
    if (num_comparisons == 0) {
        // start from the very first
        int current = 0;
        while (nodes[current].prev.size() != 0) {
            current = nodes[current].prev[0];
        }
        cout << ""a "";
        while (nodes[current].next.size() != 0) {
            cout << current << "" "";
            current = nodes[current].next[0];
        }
        cout << current << "" "";
        cout << endl << flush;
    }

    return 0;
}
","WA on case 0, test 1",WA,C++17,2022-07-30 14:44:10.521116,0
241,teamAverage,1,1009,"#include <iostream>
#include <ctime>
#include <cstdio>
#include <chrono>
#include <thread>
using namespace std;
 
// change row and column value to set the canvas size
const int row = 24;
const int col = 80;

// returns the count of alive neighbours
int count_live_neighbour_cell(int a[row][col], int r, int c){
    int i, j, count = 0;
    for (i = r - 1; i <= r + 1; i++) {
        for (j = c - 1; j <= c + 1; j++) {
            if ((i == r && j == c) || (i < 0 || j < 0)
                || (i >= row || j >= col)) {
                continue;
            }
            if (a[i][j] == 1) {
                count++;
            }
        }
    }
    return count;
}
 
int main(){
    int a[row][col], b[row][col];
    int i, j;
    int neighbour_live_cell;

    srand(time(NULL));

    // generate matrix canvas with random values (live and
    // dead cells)
    for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++) {
            a[i][j] = rand() % 2;
        }
    }
 
    // print array matrix
    for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++) {
            if(b[i][j]==0){
                    cout<<'.';
                }
                else
                    cout<<'0';
        }
        cout << ""\n"";
    }
    int time = 30;
    time *= CLOCKS_PER_SEC;
    clock_t curr = clock();
    while(clock()-curr<time){
        // next canvas values based on live neighbour count
        for (i = 0; i < row; i++) {
            for (j = 0; j < col; j++) {
                neighbour_live_cell
                    = count_live_neighbour_cell(a, i, j);
                if (a[i][j] == 1
                    && (neighbour_live_cell == 2
                        || neighbour_live_cell == 3)) {
                    b[i][j] = 1;
                }
    
                else if (a[i][j] == 0
                        && neighbour_live_cell == 3) {
                    b[i][j] = 1;
                }
    
                else {
                    b[i][j] = 0;
                }
            }
        }
    
        // print next generation
        for (i = 0; i < row; i++) {
            for (j = 0; j < col; j++) {
                a[i][j] = b[i][j];
                if(b[i][j]==0){
                    cout<<' ';
                }
                else
                    cout<<'#';
            }
            cout << ""\n"";
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }
 
    return 0;
}",Only your latest submission will be checked,AC,C++17,2022-07-30 14:44:51.157402,10
242,TeamJin,1,1006,"n=int(input())
print((n+1)*"" ""+"">\n""+(n+1)*"" ""+""|\n""+(n+1)*"" ""+""."")
for i in range(n):
    s=chr(i+65)
    for j in range(i-1,-1,-1):s=chr(j+65)+s+chr(j+65)
    print((n-i)*"" ""+""/""+s+""\\"")
","",AC,Python3,2022-07-30 14:47:00.36605,50
243,duckduckdoo,1,1007,"","/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':
(.text+0x20): undefined reference to `main'
collect2: error: ld returned 1 exit status
",CERR,C++17,2022-07-30 14:47:15.379557,0
246,HS,1,1005,"
#include <bits/stdc++.h>
using namespace std;

struct Node_struct {
    vector<int> prev;
    vector<int> next;
};

int n, m;
int max_comparison;
vector<struct Node_struct> nodes;
int num_comparisons;
vector<pair<int, int>> comparison_targets;
vector<pair<int, int>> comparison_caller; // this is for change after comparison
vector<bool> in_targets;
vector<bool> visited;

// add to targets. increment num_comparisons
// option: (1: from prev), (2: from next)
void add_to_targets(const int& a, const int& b, const int& caller, const int& option) {
    comparison_targets.push_back(pair<int, int>(a, b));
    comparison_caller.push_back(pair<int, int>(caller, option));
    in_targets[a] = true;
    in_targets[b] = true;
    num_comparisons++;
}

/*DFS description:
    test if more than 2 prevs
        find possible targets and add
        return if (num_comparisons == m)
    test if more than 2 nexts
        find possible targets and add
        return if (num_comparisons == m)
    iterate nexts
        if not visited, DFS that.
        return if (num_comparisons == m)
*/
void DFS(const int& current) {
    visited[current] = true;
    if (nodes[current].prev.size() > 1) {
        int i = 0;
        while (num_comparisons < max_comparison && i < nodes[current].prev.size()) {
            int a = -1;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    a = nodes[current].prev[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    b = nodes[current].prev[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 1);
            }
        }
        if (num_comparisons == max_comparison) return;
    }
    if (nodes[current].next.size() > 1) {
        int i = 0;
        while (num_comparisons < max_comparison && i < nodes[current].next.size()) {
            int a = -1;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    a = nodes[current].next[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    b = nodes[current].next[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 2);
            }
        }
        if (num_comparisons == max_comparison) return;
    }

    // children
    for (int i = 0; i < nodes[current].next.size(); i++) {
        if (!visited[nodes[current].next[i]]) {
            DFS(nodes[current].next[i]);
            if (num_comparisons == max_comparison) return;
        }
    }
    for (int i = 0; i < nodes[current].prev.size(); i++) {
        if (!visited[nodes[current].prev[i]]) {
            DFS(nodes[current].prev[i]);
            if (num_comparisons == max_comparison) return;
        }
    }
}

int main()
{
    cin >> n >> m;
    
    max_comparison = n/2;
    nodes = vector<struct Node_struct>(n);
    
    bool ans_found = false;
    while (!ans_found) {
        num_comparisons = 0;
        comparison_targets.clear();
        comparison_caller.clear();
        in_targets = vector<bool>(n, false);
        visited = vector<bool>(n, false);
        
        int last_DFS_start = -1;
        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            // connect disconnected graph
            if (last_DFS_start != -1) {
                for (int j = i-1; j >= 0; j--) {
                    if (!in_targets[j]) {
                        add_to_targets(j, i, -1, -1);
                        break;
                    }
                }
                if (num_comparisons == max_comparison) break;
            }
            // run DFS
            DFS(i);
            last_DFS_start = i;
            if (num_comparisons == max_comparison) break;
        }
        
        // break if no change
        if (num_comparisons == 0) break;
        // send query
        cout << ""q "" << num_comparisons << endl;
        for (int i = 0; i < num_comparisons; i++) {
             cout << comparison_targets[i].first << "" < "" << comparison_targets[i].second << endl;
        }
        cout << flush;
        // receive input
        for (int i = 0; i < num_comparisons; i++) {
            int ans;
            cin >> ans;
            
            // get 2 target nodes
            int a, b; // a <= b
            if (ans == 1) {
                a = comparison_targets[i].first;
                b = comparison_targets[i].second;
            }
            else {
                a = comparison_targets[i].second;
                b = comparison_targets[i].first;
            }
            // get caller and option
            int caller = comparison_caller[i].first;
            int option = comparison_caller[i].second;
            
            // connect two nodes
            //cout << ""--edge created between "" << a << "" -> "" << b << endl;
            nodes[a].next.push_back(b);
            nodes[b].prev.push_back(a);
            
            if (caller == -1) {
                // called to connect disconnected graphs
                // do nothing
            }
            else if (option == 1) {
                // called from caller's prev
                auto to_remove = find(nodes[caller].prev.begin(), nodes[caller].prev.end(), a);
                nodes[caller].prev.erase(to_remove);
                to_remove = find(nodes[a].next.begin(), nodes[a].next.end(), caller);
                nodes[a].next.erase(to_remove);
            }
            else if (option == 2) {
                // called from caller's next
                auto to_remove = find(nodes[caller].next.begin(), nodes[caller].next.end(), b);
                nodes[caller].next.erase(to_remove);
                to_remove = find(nodes[b].prev.begin(), nodes[b].prev.end(), caller);
                nodes[b].prev.erase(to_remove);
            }
        }
    }
    if (num_comparisons == 0) {
        // start from the very first
        int current = 0;
        while (nodes[current].prev.size() != 0) {
            current = nodes[current].prev[0];
        }
        cout << ""a "";
        while (nodes[current].next.size() != 0) {
            cout << current << "" "";
            current = nodes[current].next[0];
        }
        cout << current << "" "";
        cout << endl << flush;
    }
    int result;
    cin >> result;

    return 0;
}
","WA on case 0, test 3",WA,C++17,2022-07-30 14:48:14.361546,0
247,duckduckdoo,1,1007,"
#include <iostream>
#include <unordered_map>
#include <map>
#include <vector>
using namespace std;


int main() {
    int numFences, numQueries;
    cin>>numFences>>numQueries;
    map<int, string> *f = new map<int, string>[numFences];
    vector<string> vect(numFences, ""white"");

    for (int i = 0; i < numQueries; i++) {
        char command;
        cin>>command;
        if (command == 'p') {
            int start, end;
            string color;
            cin>>start>>end>>color;
            for (int i = start-1; i < end; i++) {
                vect[i] = color;
            }
        }
        else if (command == 'q') {
            int fenceNum;
            cin>>fenceNum;
            cout << vect[--fenceNum];
        }
    }
}","WA on case 0, test 0",WA,C++17,2022-07-30 14:49:34.620188,0
248,YugoslaviaLover1992,1,1008,"#include <iostream>
#include <time.h>
#include <vector>

using namespace std;

// this program is a Yugoslavia-themed chatbot
// this program is not intended to offend Yugoslavians nor Yugoslavia itself
int main() {
  // initialize vector 'dictionaries' for the program to identify key words
  vector<string> greetings = {""hello"", ""hey"",         ""hi"",      ""yo"",
                              ""g'day"", ""salutations"", ""greeting""};
  vector<string> topics = {""hobbies"",      ""hobby"",     ""problems"",
                           ""troubles"",     ""interest"",  ""birthday"",
                           ""how are you?"", ""yugoslavia""};
  vector<string> affirmatives = {""yes"", ""yah"", ""yep"", ""yeah"", ""yup"", ""yessir""};
  vector<string> negatives = {""no"", ""nope"", ""negatory"", ""nah""};
  vector<string> goodbyes = {""bye"", ""see ya"", ""see you later"", ""bye bye""};

  int conversating = 1;
  int cStage = 0;
  size_t foundAnswer;
  // UOOOOOOOOHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
  string msg = ""UOOOOOOOOOOOOOOOOOOH YUGOSLAVIA UOOOOOOOOOOOOOOOOOH"";

  while (conversating) {

    string s;
    getline(cin, s);
    string enteredString = s;
    // standardize input
    for (int i = 0; i < enteredString.length(); i++) {
      enteredString[i] = tolower(s[i]);
    }

    // cout << enteredString;

    if (cStage == 0) {

      // get time
      time_t now = time(0);
      tm *ltm = localtime(&now);

      // search user input for a greeting
      for (int i = 0; i < greetings.size(); i++) {
        foundAnswer = enteredString.find(greetings[i]);
        if (foundAnswer != std::string::npos) {
          break;
        }
      }
      // if a greeting is found, have a greeting dependant on time
      if (foundAnswer != std::string::npos) {
        if (ltm->tm_hour < 12) {
          msg = ""Good morning and Glory to Yugoslavia.  Was there something ""
                ""you wanted to talk about?"";
        } else if (12 <= ltm->tm_hour) {
          msg = ""Good afternoon and Glory to Yugoslavia! Was there something ""
                ""you wanted to talk about?"";
        } else if (17 <= ltm->tm_hour) {
          msg = ""Good evening, may Yugoslavia's glory grow tomorrow as well! ""
                ""Was there something you wanted to talk about?"";
        } else {
          msg = ""Just say the word if you need anything!"";
        }
        cStage = 1;
      } // if greeting is found
      else {
        msg = ""Hello?"";
      } // no greeting found

    }
    // small talk
    else if (cStage == 1) {

      string curTopic;

      for (int i = 0; i < topics.size(); i++) {
        foundAnswer = enteredString.find(topics[i]);
        if (foundAnswer != std::string::npos) {
          curTopic = topics[i];
          break;
        }
      }

      // if a topic is found
      if (foundAnswer != std::string::npos) {
        if (curTopic == ""hobbies"" || curTopic == ""hobby"" ||
            curTopic == ""interest"") {
          msg = ""My favourite hobby is football - Yugoslavia's most popular ""
                ""sport... what's yours?"";
          cStage = 2;
        } else if (curTopic == ""problems"" || curTopic == ""troubles"") {
          msg = ""We live in a world without Yugoslavia, that's the ""
                ""problem...\n also, I need a new granola recipe. Could you ""
                ""give me one?"";
          cStage = 3;
        } else if (curTopic == ""how are you?"") {
          msg = ""I'm doing alright, thanks for asking!"";
          cStage = 1;
        } else if (curTopic == ""yugoslavia"") {
          msg = ""Glory to Yugoslavia!"";
        } else if (curTopic == ""birthday"") {
          msg = ""The idea of Yugoslavia was born long, long ago...\n me ""
                ""personally, I was born on July 30th, 2022"";
        } else {
          msg = ""Hmm, let's talk about something else... like Yugoslavia"";
        }
      }

      // if no topic found
      else if (foundAnswer == std::string::npos) {
        msg = ""I'd rather talk about hobbies... or even about myself if you're ""
              ""curious!"";
      }

    } // cstage 1

    else if (cStage == 2) {
      msg = s + "" is pretty cool, just like Yugoslavia! Was there anything ""
                ""else you'd like to ask?"";
      cStage = 1;
    } // cStage 2

    else if (cStage == 3) {
      // first looks for affirmatives, then looks for negatives
      // my rationale here was that if a person says yes-no, the answer is
      // probably no
      for (int i = 0; i < affirmatives.size(); i++) {
        foundAnswer = enteredString.find(affirmatives[i]);
        if (foundAnswer != std::string::npos) {
          msg = ""Awesome! How about you share it with me sometime for our ""
                ""great nations continued prosperity? Hehe, was ""
                ""there anything else?"";
          break;
        }
      }
      for (int i = 0; i < negatives.size(); i++) {
        foundAnswer = enteredString.find(negatives[i]);
        if (foundAnswer != std::string::npos) {
          msg = ""What a shame... was there anything else?"";
          break;
        }
      }
      cStage = 1;
    }

    // search user input for a goodbye
    for (int i = 0; i < goodbyes.size(); i++) {
      foundAnswer = enteredString.find(goodbyes[i]);
      if (foundAnswer != std::string::npos) {
        break;
      }
    }
    if (foundAnswer != std::string::npos) {
      msg = ""An early goodbye... farewell, and may Yugoslavia's spirit be ""
            ""with you"";
      cout << msg << ""\n"";
      break;
    } else {
      cout << msg << ""\n"";
    }
  }
}",Only your latest submission will be checked,AC,C++17,2022-07-30 14:50:14.551707,10
249,HS,1,1005,"
#include <bits/stdc++.h>
using namespace std;

struct Node_struct {
    vector<int> prev;
    vector<int> next;
};

int n, m;
int max_comparison;
vector<struct Node_struct> nodes;
int num_comparisons;
vector<pair<int, int>> comparison_targets;
vector<pair<int, int>> comparison_caller; // this is for change after comparison
vector<bool> in_targets;
vector<bool> visited;

// add to targets. increment num_comparisons
// option: (1: from prev), (2: from next)
void add_to_targets(const int& a, const int& b, const int& caller, const int& option) {
    comparison_targets.push_back(pair<int, int>(a, b));
    comparison_caller.push_back(pair<int, int>(caller, option));
    in_targets[a] = true;
    in_targets[b] = true;
    num_comparisons++;
}

/*DFS description:
    test if more than 2 prevs
        find possible targets and add
        return if (num_comparisons == m)
    test if more than 2 nexts
        find possible targets and add
        return if (num_comparisons == m)
    iterate nexts
        if not visited, DFS that.
        return if (num_comparisons == m)
*/
void DFS(const int& current) {
    visited[current] = true;
    if (nodes[current].prev.size() > 1) {
        int i = 0;
        while (num_comparisons < max_comparison && i < nodes[current].prev.size()) {
            int a = -1;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    a = nodes[current].prev[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    b = nodes[current].prev[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 1);
            }
        }
        if (num_comparisons == max_comparison) return;
    }
    if (nodes[current].next.size() > 1) {
        int i = 0;
        while (num_comparisons < max_comparison && i < nodes[current].next.size()) {
            int a = -1;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    a = nodes[current].next[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    b = nodes[current].next[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 2);
            }
        }
        if (num_comparisons == max_comparison) return;
    }

    // children
    for (int i = 0; i < nodes[current].next.size(); i++) {
        if (!visited[nodes[current].next[i]]) {
            DFS(nodes[current].next[i]);
            if (num_comparisons == max_comparison) return;
        }
    }
    for (int i = 0; i < nodes[current].prev.size(); i++) {
        if (!visited[nodes[current].prev[i]]) {
            DFS(nodes[current].prev[i]);
            if (num_comparisons == max_comparison) return;
        }
    }
}

int main()
{
    cin >> n >> m;
    
    max_comparison = n/2;
    nodes = vector<struct Node_struct>(n);
    
    bool ans_found = false;
    for(int i = 0; i < m; i++) {
        num_comparisons = 0;
        comparison_targets.clear();
        comparison_caller.clear();
        in_targets = vector<bool>(n, false);
        visited = vector<bool>(n, false);
        
        int last_DFS_start = -1;
        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            // connect disconnected graph
            if (last_DFS_start != -1) {
                for (int j = i-1; j >= 0; j--) {
                    if (!in_targets[j]) {
                        add_to_targets(j, i, -1, -1);
                        break;
                    }
                }
                if (num_comparisons == max_comparison) break;
            }
            // run DFS
            DFS(i);
            last_DFS_start = i;
            if (num_comparisons == max_comparison) break;
        }
        
        // break if no change
        if (num_comparisons == 0) break;
        // send query
        cout << ""q "" << num_comparisons << endl;
        for (int i = 0; i < num_comparisons; i++) {
             cout << comparison_targets[i].first << "" < "" << comparison_targets[i].second << endl;
        }
        cout << flush;
        // receive input
        for (int i = 0; i < num_comparisons; i++) {
            int ans;
            cin >> ans;
            
            // get 2 target nodes
            int a, b; // a <= b
            if (ans == 1) {
                a = comparison_targets[i].first;
                b = comparison_targets[i].second;
            }
            else {
                a = comparison_targets[i].second;
                b = comparison_targets[i].first;
            }
            // get caller and option
            int caller = comparison_caller[i].first;
            int option = comparison_caller[i].second;
            
            // connect two nodes
            //cout << ""--edge created between "" << a << "" -> "" << b << endl;
            nodes[a].next.push_back(b);
            nodes[b].prev.push_back(a);
            
            if (caller == -1) {
                // called to connect disconnected graphs
                // do nothing
            }
            else if (option == 1) {
                // called from caller's prev
                auto to_remove = find(nodes[caller].prev.begin(), nodes[caller].prev.end(), a);
                nodes[caller].prev.erase(to_remove);
                to_remove = find(nodes[a].next.begin(), nodes[a].next.end(), caller);
                nodes[a].next.erase(to_remove);
            }
            else if (option == 2) {
                // called from caller's next
                auto to_remove = find(nodes[caller].next.begin(), nodes[caller].next.end(), b);
                nodes[caller].next.erase(to_remove);
                to_remove = find(nodes[b].prev.begin(), nodes[b].prev.end(), caller);
                nodes[b].prev.erase(to_remove);
            }
        }
    }
    if (num_comparisons == 0) {
        // start from the very first
        int current = 0;
        while (nodes[current].prev.size() != 0) {
            current = nodes[current].prev[0];
        }
        cout << ""a "";
        while (nodes[current].next.size() != 0) {
            cout << current << "" "";
            current = nodes[current].next[0];
        }
        cout << current << "" "";
        cout << endl << flush;
    }
    int result;
    cin >> result;

    return 0;
}
","WA on case 0, test 4",WA,C++17,2022-07-30 14:51:15.083628,0
250,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    int plank;
    int query;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for (int i = 0; i < plank; i++) {
        fences[i] = ""white"";
    }
    string out = """";
    for (int i = 0; i < query; i++) {
        cin >> command;
        if (command == 'q') {
            int n;
            cin >> n;
            out.append(fences[n] + '\n');
        }
        if (command == 'p') {
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for (int i = start; i <= end; i++) {
                fences[i] = col;
            }
        }
    }
    cout << out;
    cout.flush();
}","WA on case 1, test 0",WA,C++17,2022-07-30 14:52:29.189913,0
251,duckduckdoo,1,1007,"
#include <iostream>
#include <unordered_map>
#include <map>
#include <vector>
using namespace std;


int main() {
    int numFences, numQueries;
    cin>>numFences>>numQueries;
    map<int, string> *f = new map<int, string>[numFences];
    vector<string> vect(numFences, ""white"");

    for (int i = 0; i < numQueries; i++) {
        char command;
        cin>>command;
        if (command == 'p') {
            int start, end;
            string color;
            cin>>start>>end>>color;
            for (int i = start-1; i < end; i++) {
                vect[i] = color;
            }
        }
        else if (command == 'q') {
            int fenceNum;
            cin>>fenceNum;
            cout << vect[--fenceNum] << endl;
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 14:52:31.977839,40
253,TeamJin,1,1005,"from ast import operator


nums = list(map(int, input().split()))
n = nums[0]
m = nums[1]

print(""q 2"")
print(""0 < 1"")
print(""0 < 1"")

print(input())","WA on case 0, test 1","",Python3,2022-07-30 14:53:33.524227,0
255,teamAverage,1,1007,"#include <iostream>
#include <string>
using namespace std;

int main(){
    //initialize map and iterator
    string fences[100000];

    //read the number of fences and queries
    long numFences;
    long numQueries;
    cin >> numFences >> numQueries;

    //insert all initial elements as white
    for (int i = 0; i < numFences; i++){
        fences[i] = ""white"";
    }

    //initialize all the variables needed
    char type;

    //take the input in a loop
    for(int i = 0; i < numQueries; i++){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            string color;
            cin >> start >> end;
            cin >> color;
            //modify the fences' colors
            for(int j = start; j <= end; j++){
                fences[j-1] = color;
            }
        }
        else if(type == 'q'){
            //take in 1 input
            int key;
            cin >> key;
            cout << fences[key-1]<< endl;
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 14:53:57.8508,40
256,Dragoneel,1,1007,"import os
from tkinter import N
# Sample Input
# 10 5
# q 1
# p 2 4 black
# p 1 2 green
# q 2
# q 3
# Sample Output
# white
# green
# black


    
    
def show_names(choice):
    for i in range(int(choice[1]), int(choice[2])+1):
        planks[i] = choice[3]
    
        
def get_new_name(ent):
    print(planks[ent])


### MAIN PROGRAM ###

# Set up a loop where users can choose what they'd like to do.

n = 10 
q = 5
nums = list(map(int, input().split()))
planks = [""white""] * nums[0]

while nums[1] != 0:    
    
    choice = list(input().split())
    
    # Respond to the user's choice.
    
    if choice[0] == 'p':
        show_names(choice)
    elif choice[0] == 'q':
        get_new_name(int(choice[1]))
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 2, in <module>
    from tkinter import N
ModuleNotFoundError: No module named 'tkinter'
",ERR,Python3,2022-07-30 14:54:38.947718,0
257,untitled,1,1005,"#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> edges;

int main() {
    int n, m;
    cin >> n >> m;
    edges = vector<vector<int>>(n);
    vector<int> inDegree(n);
    vector<vector<pair<int,int>>> queries(m-1);
    vector<vector<bool>> used(m-1, vector<bool>(n));
    int failedCount = 0;
    for(int i = 0; i < n; i++){
        for(int j = i+1; j < n; j++){
            bool worked = false;
            for(int k = 0; k < m-1; k++){
                if(!used[k][i] && !used[k][j]){
                    used[k][i] = true;
                    used[k][j] = true;
                    queries[k].push_back({i, j});
                    worked = true;
                    //cout << ""success"" << endl;
                    break;
                }
            }
            if(!worked) {
                failedCount++;
            }
        }
    }
    for(int i = 0; i < m-1; i++){
        if(!queries[i].empty()){
            cout << ""q "" << queries[i].size() << endl;
        }
        for(int j = 0; j < queries[i].size(); j++){
            cout << queries[i][j].first << "" < "" << queries[i][j].second << endl;
        }
        for(int j = 0; j < queries[i].size(); j++){
            int val;
            cin >> val;
            int u = queries[i][j].first, v = queries[i][j].second;
            if(val == 1){
                edges[u].push_back(v);
                inDegree[v]++;
            }else{
                edges[v].push_back(u);
                inDegree[u]++;
            }
        }
    }
    queue<int> q;
    for(int i = 0; i < n; i++){
        if(inDegree[i] == 0){
            q.push(i);
        }
    }
    vector<int> answer;
    while(!q.empty()){
        int cur = q.front();
        q.pop();
        answer.push_back(cur);
        for(int i = 0; i < edges[cur].size(); i++){
            int next = edges[cur][i];
            inDegree[next]--;
            if(inDegree[next] == 0){
                q.push(next);
            }
        }
    }
    cout << ""a "";
    for(int i = 0; i < answer.size(); i++){
        cout << answer[i];
        if(i < (int)answer.size() - 1) {
            cout << "" "";
        }
    }
    cout << endl;
    int result;
    cin >> result;
}","WA on case 1, test 5","",C++17,2022-07-30 14:55:40.06434,30
258,duckduckdoo,1,1007,"
#include <iostream>
#include <unordered_map>
#include <map>
#include <vector>
using namespace std;


int main() {
    int numFences, numQueries;
    cin>>numFences>>numQueries;
    vector<string> vect(numFences, ""white"");

    for (int i = 0; i < numQueries; i++) {
        char command;
        cin>>command;
        if (command == 'p') {
            int start, end;
            string color;
            cin>>start>>end>>color;
            for (int i = start-1; i < end; i++) {
                vect[i] = color;
            }
        }
        else if (command == 'q') {
            int fenceNum;
            cin>>fenceNum;
            cout << vect[--fenceNum] << endl   ;
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 14:55:54.2364,40
259,FuduBoys,1,1006,"r = gets.chomp.to_i
s="" ""*(r-3)
p(s,"" >\n"",s,""|\n"",s,""."")
s+="" ""
c1 = c = k = 0
for i in (1..r-1) 
  c=r-i-1
  p(s, end="""")
  puts(""/"", end="""")
  while k!=((2*i)-1) 
      if c<=r-2 
        p(chr(k+65), end="""")
        c+=1
      else
        c1+=1
        p(chr(k-(2*c1)+65), end="""")
      end
      k+= 1
  end
  c1 = c = k = 0
  s = s[0...-1]
  puts(""\\"")
end","Error with code 1:
/code/Main.rb:8: syntax error, unexpected `end', expecting ')'
  p(s, end="""")
       ^~~
/code/Main.rb:9: syntax error, unexpected `end', expecting ')'
  puts(""/"", end="""")
            ^~~
/code/Main.rb:12: syntax error, unexpected `end', expecting ')'
        p(chr(k+65), end="""")
                     ^~~
/code/Main.rb:16: syntax error, unexpected `end', expecting ')'
        p(chr(k-(2*c1)+65), end="""")
                            ^~~
/code/Main.rb:23: syntax error, unexpected end-of-input, expecting `end'
",ERR,Ruby,2022-07-30 14:56:06.532237,0
260,Dragoneel,1,1007,"import os
from tkinter import N
# Sample Input
# 10 5
# q 1
# p 2 4 black
# p 1 2 green
# q 2
# q 3
# Sample Output
# white
# green
# black


    
    
def show_names(choice):
    for i in range(int(choice[1]), int(choice[2])+1):
        planks[i] = choice[3]
    
        
def get_new_name(ent):
    print(planks[ent])


### MAIN PROGRAM ###

# Set up a loop where users can choose what they'd like to do.

n = 10 
q = 5
nums = list(map(int, input().split()))
planks = [""white""] * nums[0]

while nums[1] != 0:    
    
    choice = list(input().split())
    nums[1] = nums[1] -1
    # Respond to the user's choice.
    
    if choice[0] == 'p':
        show_names(choice)
    elif choice[0] == 'q':
        get_new_name(int(choice[1]))
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 2, in <module>
    from tkinter import N
ModuleNotFoundError: No module named 'tkinter'
",ERR,Python3,2022-07-30 14:57:40.184574,0
261,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main(){
//initialize map and iterator
vector<string> fences;

//read the number of fences and queries
long numFences;
long numQueries;
cin >> numFences >> numQueries;

//insert all initial elements as white
for (int i = 0; i < numFences; i++){
fences.push_back(""white"");
}

//initialize all the variables needed
char type;

//take the input in a loop
for(int i = 0; i < numQueries; i++){
//take first char input (q or p)
cin >> type;
if(type == 'p'){
//take in 3 inputs
int start, end;
string color;
cin >> start >> end;
cin >> color;
//modify the fences' colors
for(int j = start; j <= end; j++){
fences[j-1] = color;
}
}
else if(type == 'q'){
//take in 1 input
int key;
cin >> key;
cout << fences[key-1] << endl;
}
}
}

","Failed on case 3, test 0",TLE,C++17,2022-07-30 14:57:48.125807,40
262,HS,1,1005,"
#include <bits/stdc++.h>
using namespace std;

struct Node_struct {
    vector<int> prev;
    vector<int> next;
};

int n, m;
int max_comparison;
vector<struct Node_struct> nodes;
int num_comparisons;
vector<pair<int, int>> comparison_targets;
vector<pair<int, int>> comparison_caller; // this is for change after comparison
vector<bool> in_targets;
vector<bool> visited;

// add to targets. increment num_comparisons
// option: (1: from prev), (2: from next)
void add_to_targets(const int& a, const int& b, const int& caller, const int& option) {
    comparison_targets.push_back(pair<int, int>(a, b));
    comparison_caller.push_back(pair<int, int>(caller, option));
    in_targets[a] = true;
    in_targets[b] = true;
    num_comparisons++;
}

/*DFS description:
    test if more than 2 prevs
        find possible targets and add
        return if (num_comparisons == m)
    test if more than 2 nexts
        find possible targets and add
        return if (num_comparisons == m)
    iterate nexts
        if not visited, DFS that.
        return if (num_comparisons == m)
*/
void DFS(const int& current) {
    visited[current] = true;
    if (nodes[current].prev.size() > 1) {
        int i = 0;
        while (num_comparisons < max_comparison && i < nodes[current].prev.size()) {
            int a = -1;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    a = nodes[current].prev[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    b = nodes[current].prev[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 1);
            }
        }
        if (num_comparisons == max_comparison) return;
    }
    if (nodes[current].next.size() > 1) {
        int i = 0;
        while (num_comparisons < max_comparison && i < nodes[current].next.size()) {
            int a = -1;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    a = nodes[current].next[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    b = nodes[current].next[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 2);
            }
        }
        if (num_comparisons == max_comparison) return;
    }

    // children
    for (int i = 0; i < nodes[current].next.size(); i++) {
        if (!visited[nodes[current].next[i]]) {
            DFS(nodes[current].next[i]);
            if (num_comparisons == max_comparison) return;
        }
    }
    for (int i = 0; i < nodes[current].prev.size(); i++) {
        if (!visited[nodes[current].prev[i]]) {
            DFS(nodes[current].prev[i]);
            if (num_comparisons == max_comparison) return;
        }
    }
}

int main()
{
    cin >> n >> m;
    
    max_comparison = n/2;
    nodes = vector<struct Node_struct>(n);
    
    bool ans_found = false;
    for(int i = 0; i < m; i++) {
        num_comparisons = 0;
        comparison_targets.clear();
        comparison_caller.clear();
        in_targets = vector<bool>(n, false);
        visited = vector<bool>(n, false);
        
        int last_DFS_start = -1;
        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            // connect disconnected graph
            if (last_DFS_start != -1) {
                for (int j = i-1; j >= 0; j--) {
                    if (!in_targets[j]) {
                        add_to_targets(j, i, -1, -1);
                        break;
                    }
                }
                if (num_comparisons == max_comparison) break;
            }
            // run DFS
            DFS(i);
            last_DFS_start = i;
            if (num_comparisons == max_comparison) break;
        }
        
        // break if no change
        if (num_comparisons == 0) break;
        
        // send query
        cout << ""q "" << num_comparisons << endl;
        for (int i = 0; i < num_comparisons; i++) {
             cout << comparison_targets[i].first << "" < "" << comparison_targets[i].second << endl;
        }
        
        // receive input
        for (int i = 0; i < num_comparisons; i++) {
            int ans;
            cin >> ans;
            
            // get 2 target nodes
            int a, b; // a <= b
            if (ans == 1) {
                a = comparison_targets[i].first;
                b = comparison_targets[i].second;
            }
            else {
                a = comparison_targets[i].second;
                b = comparison_targets[i].first;
            }
            // get caller and option
            int caller = comparison_caller[i].first;
            int option = comparison_caller[i].second;
            
            // connect two nodes
            //cout << ""--edge created between "" << a << "" -> "" << b << endl;
            nodes[a].next.push_back(b);
            nodes[b].prev.push_back(a);
            
            if (caller == -1) {
                // called to connect disconnected graphs
                // do nothing
            }
            else if (option == 1) {
                // called from caller's prev
                auto to_remove = find(nodes[caller].prev.begin(), nodes[caller].prev.end(), a);
                nodes[caller].prev.erase(to_remove);
                to_remove = find(nodes[a].next.begin(), nodes[a].next.end(), caller);
                nodes[a].next.erase(to_remove);
            }
            else if (option == 2) {
                // called from caller's next
                auto to_remove = find(nodes[caller].next.begin(), nodes[caller].next.end(), b);
                nodes[caller].next.erase(to_remove);
                to_remove = find(nodes[b].prev.begin(), nodes[b].prev.end(), caller);
                nodes[b].prev.erase(to_remove);
            }
        }
    }
    if (num_comparisons == 0) {
        // start from the very first
        int current = 0;
        while (nodes[current].prev.size() != 0) {
            current = nodes[current].prev[0];
        }
        cout << ""a "";
        while (nodes[current].next.size() != 0) {
            cout << current << "" "";
            current = nodes[current].next[0];
        }
        cout << current;
        cout << endl;
    }
    int result;
    cin >> result;

    return 0;
}
","WA on case 0, test 1",WA,C++17,2022-07-30 15:01:40.781078,0
263,duckduckdoo,1,1009,"import time
import os

movie = ['''
            o   o
             ╲ ╱
╔═════════════════════════════════╗
║☆┊┊┊┊┊┊┊ ☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊┊┊┊┊║
║┊┊┊┊┊┊┊┊ ┊┊┊┊☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊║
║┊┊┊ ☆┈┈┈┈ ╭━━━━━━━━━━━━━╮┊☆ ┊┊┊┊┊║
║☆ ┈┈┈┈☆ ┈┈┃xxxxxxxx |¯\▂▂▂/¯|┊┊┊┊║
║┈┈☆ ┈┈┈☆ ┈┃xxxxxxxx▕▏ ▍   ▕▍▕┊┊┊┊║
║┈┈┈┈☆┈┈┈╔━┫xxxxxxxx \  ╰┻╯  /┊☆┊┊║
║☆ ┈┈┈┈☆┊┊O╰U━━━━━━━━━¯¯u¯u¯¯┊┊┊┊┊║
║┊┊┊┊┊┊┊┊ ┊┊┊┊☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊║
║┊☆┊┊┊┊┊┊ ☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊┊┊┊┊║
╚═════════════════════════════════╝
''','''
            o   o
             ╲ ╱
╔═════════════════════════════════╗
║☆┊┊┊┊┊┊┊ ☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊┊┊┊┊║
║┊┊┊┊┊┊┊┊ ┊┊┊┊☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊║
║┈┊┊┊ ☆┈┈┈┈╭━━━━━━━━━━━━━╮┊☆ ┊┊┊┊┊║
║┈☆ ┈┈┈┈☆ ┈┃xxxxxxxx |¯\▂▂▂/¯|┊┊┊┊║
║┈┈┈☆ ┈┈┈☆ ┃xxxxxxxx▕▏ ▍   ▕▍▕┊┊┊┊║
║┈┈┈┈┈☆┈┈╔━┫xxxxxxxx \  ╰┻╯  /┊☆┊┊║
║┈☆ ┈┈┈┈┊┊O╰U━━━━━━━━━¯¯¯u¯u¯┊┊┊┊┊║
║┊┊┊┊┊┊┊┊ ┊┊┊┊☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊║
║┊☆┊┊┊┊┊┊ ☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊┊┊┊┊║
╚═════════════════════════════════╝
''','''
            o   o
             ╲ ╱
╔═════════════════════════════════╗
║☆┊┊┊┊┊┊┊ ☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊┊┊┊┊║
║┊┊┊┊┊┊┊┊ ┊┊┊┊☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊║
║┈┈┊┊┊ ☆┈┈┈╭━━━━━━━━━━━━━╮┊☆ ┊┊┊┊┊║
║┈┈☆ ┈┈┈┈☆ ┃xxxxxxxx |¯\▂▂▂/¯|┊┊┊┊║
║┈┈┈┈☆ ┈┈┈☆┃xxxxxxxx▕▏ ▍   ▕▍▕┊┊┊┊║
║ ┈┈┈┈┈☆┈╔━┫xxxxxxxx \  ╰┻╯  /┊☆┊┊║
║┊┈☆ ┈┈┈┊┊┊O━U━━━━━━━━¯¯¯u¯u¯┊┊┊┊┊║
║┊┊┊┊┊┊┊┊ ┊┊┊┊☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊║
║┊☆┊┊┊┊┊┊ ☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊┊┊┊┊║
╚═════════════════════════════════╝
''','''
            o   o
             ╲ ╱
╔═════════════════════════════════╗
║☆┊┊┊┊┊┊┊ ☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊┊┊┊┊║
║┊┊┊┊┊┊┊┊ ┊┊┊┊☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊║
║ ┈┈┊┊┊ ☆┈┈╭━━━━━━━━━━━━━╮┊☆ ┊┊┊┊┊║
║┈┈┈☆ ┈┈┈┈☆┃xxxxxxxx |¯\▂▂▂/¯|┊┊┊┊║
║┈┈┈┈┈☆ ┈┈┈┃xxxxxxxx▕▏ ▍   ▕▍▕┊┊┊┊║
║☆ ┈┈┈┈┈☆╔━┫xxxxxxxx \  ╰┻╯  /┊☆┊┊║
║┊┊┈☆ ┈┈┊┊┊O━U━━━━━━━━¯¯u¯u¯¯┊┊┊┊┊║
║┊┊┊┊┊┊┊┊ ┊┊┊┊☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊║
║┊☆┊┊┊┊┊┊ ☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊┊┊┊┊║
╚═════════════════════════════════╝
''','''
            o   o
             ╲ ╱
╔═════════════════════════════════╗
║☆┊┊┊┊┊┊┊ ☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊┊┊┊┊║
║┊┊┊┊┊┊┊┊ ┊┊┊┊☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊║
║☆ ┈┈┊┊┊ ☆┈╭━━━━━━━━━━━━━╮┊☆ ┊┊┊┊┊║
║┈┈┈┈☆ ┈┈┈┈┃xxxxxxxx |¯\▂▂▂/¯|┊┊┊┊║
║┈┈┈┈┈┈☆ ┈┈┃xxxxxxxx▕▏ ▍   ▕▍▕┊┊┊┊║
║┈☆ ┈┈┈┈┈╔━┫xxxxxxxx \  ╰┻╯  /┊☆┊┊║
║┊┊┈┈☆ ┈┊┊O╰U━━━━━━━━━¯¯u¯u¯¯┊┊┊┊┊║
║┊┊┊┊┊┊┊┊ ┊┊┊┊☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊║
║┊☆┊┊┊┊┊┊ ☆┊┊┊┊☆┊┊☆ ┊┊┊┊┊┊┊☆┊┊┊┊┊┊║
╚═════════════════════════════════╝
''']

for i in movie*10:
  print(i)
  time.sleep(0.2)
  os.system('cls' if os.name == 'nt' else 'clear')",Only your latest submission will be checked,AC,Python3,2022-07-30 15:04:17.96982,10
265,untitled,1,1005,"#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> edges;

int main() {
    int n, m;
    cin >> n >> m;
    edges = vector<vector<int>>(n);
    vector<int> inDegree(n);
    vector<vector<pair<int,int>>> queries(m-1);
    vector<vector<bool>> used(m-1, vector<bool>(n));
    int failedCount = 0;
    vector<pair<int,int>> needed;
    for(int i = 0; i < n; i++){
        for(int j = i+1; j < n; j++){
            needed.push_back({i, j});
        }
    }
    random_shuffle(needed.begin(), needed.end());
    for(int i = 0; i < needed.size(); i++){
            bool worked = false;
            for(int k = 0; k < m-1; k++){
                int u = needed[i].first, v = needed[i].second;
                if(!used[k][u] && !used[k][v]){
                    used[k][u] = true;
                    used[k][v] = true;
                    queries[k].push_back({u, v});
                    worked = true;
                    //cout << ""success"" << endl;
                    break;
                }
            }
            if(!worked) {
                failedCount++;
            }
    }
    //cout << failedCount << endl;
    for(int i = 0; i < m-1; i++){
        if(!queries[i].empty()){
            cout << ""q "" << queries[i].size() << endl;
        }
        for(int j = 0; j < queries[i].size(); j++){
            cout << queries[i][j].first << "" < "" << queries[i][j].second << endl;
        }
        for(int j = 0; j < queries[i].size(); j++){
            int val;
            cin >> val;
            int u = queries[i][j].first, v = queries[i][j].second;
            if(val == 1){
                edges[u].push_back(v);
                inDegree[v]++;
            }else{
                edges[v].push_back(u);
                inDegree[u]++;
            }
        }
    }
    queue<int> q;
    for(int i = 0; i < n; i++){
        if(inDegree[i] == 0){
            q.push(i);
        }
    }
    vector<int> answer;
    while(!q.empty()){
        int cur = q.front();
        q.pop();
        answer.push_back(cur);
        for(int i = 0; i < edges[cur].size(); i++){
            int next = edges[cur][i];
            inDegree[next]--;
            if(inDegree[next] == 0){
                q.push(next);
            }
        }
    }
    cout << ""a "";
    for(int i = 0; i < answer.size(); i++){
        cout << answer[i];
        if(i < (int)answer.size() - 1) {
            cout << "" "";
        }
    }
    cout << endl;
    int result;
    cin >> result;
}","WA on case 1, test 8","",C++17,2022-07-30 15:05:04.377667,30
264,rvijayar,1,1005,"#include <bits/stdc++.h>
#define rep(x, start, end) for (int x = start; x < end; x++)
#define pb(x)              push_back(x)
#define mp(x, y)           make_pair(x, y)
using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;

const int MAXN = 100;
int altb[MAXN][MAXN];  // a < b?

int main() {
  ios::sync_with_stdio(false);
  cin.tie(NULL);

  deque<pii> history;
  deque<pii> curr;

  rep(i, 0, MAXN) fill(altb[i], altb[i] + MAXN, 0);

  int n, m;
  cin >> n >> m;

  rep(i, 0, n) rep(j, i + 1, n) history.pb(mp(i, j));
  shuffle(history.begin(), history.end(), std::default_random_engine(1337));

  while (history.size()) {
    curr.clear();

    bool change = true;
    int seen[100] = {0};

    while (change && history.size()) {
      int i = 0;
      change = false;
      while (i < history.size()) {
        if (!seen[history[i].first] && !seen[history[i].second]) {
          seen[history[i].first] = seen[history[i].second] = 1;
          curr.pb(history[i]);
          history.erase(history.begin() + i);
          change = true;
        } else {
          ++i;
        }
      }
    }

    cout << ""q "" << curr.size() << endl;

    for (auto&& x : curr)
      cout << x.first << "" > "" << x.second << endl;

    for (auto&& x : curr) {
      cin >> altb[x.first][x.second];
      altb[x.second][x.first] = 1 - altb[x.first][x.second];

      if (altb[x.first][x.second] == -1)
        exit(-1);
    }
  }

  cout << ""a "";

  rep(i, 0, n) {
    rep(j, 0, n) {
      if (accumulate(&altb[j][0], &altb[j][n], 0) == i)
        cout << j << ' ';
    }
  }
  cout << flush;

  cin >> n;

  return 0;
}
","WA on case 0, test 0",WA,C++17,2022-07-30 15:05:03.72774,0
266,duckduckdoo,1,1008,"#include <iostream>
#include <unistd.h>
using namespace std;

/****************************************************************/
/*                    Fractal Curve Function                    */
/* Mandelbrot set is used: en.wikipedia.org/wiki/Mandelbrot_set */
/*  Function creates a 2D array and populates it with values    */
/*                    based off Mandelbrot set                  */
/****************************************************************/
int **calculateSet(int maxX, int maxY){
    //Initialise an empty 2D array that corresponds to the max width and height
    int **returnSet = new int*[maxY];
    for(int p = 0; p < maxY; p++){
        returnSet[p] = new int[maxX];
    }

    //Create variables that will hold values for the Mandelbrot set
    float scale_x, scale_y;
    float r_x, r_y;
    float c_x, c_y;
    float t;

    //Ratio of how much the fractal takes up the avaliable spaace
    float x_ratio = .25;
    float y_ratio = .5;

    //Both values are buffers to centre the drawing
    float R = 1;
    float L = .15;  

    //Initalise the x and y scale of the fractal based off the max screen sizes and the x and y ratio of the fractals size
    scale_x = x_ratio/maxX;
    scale_y = y_ratio/maxY;

    //iterate through every x and y position and calculate the Mandelbrot set
    for(int i = 1;  i < maxY; i++){
        for(int k = 1; k < maxX; k++){
            //initialising real part for Mandelbrot set
            c_x = k * scale_x - L;  
            //initialising imaginary part for Mandelbrot set
            c_y = i * scale_y - R;

            //Real part for Z
            r_x = 0;
            //Imaginary Part for Z
            r_y = 0;

            // initalise empty colour value
            int colour = 0;

            //Figure out if the corresponding x and y position of the 2D array is a member of the Mandelbrot set
            //2 exit conditions are if it reaches a maximum iteration count of 100 or the distance diverges to far from the origin
            while((r_x*r_x + r_y*r_y < 4 ) && (colour <= 100)){
                //calculate real part of Z
                t  = r_x*r_x - r_y*r_y + c_x; 
                //calculate imaginary part of Z
                r_y = 2 * r_x * r_y + c_y;
                // update real component
                r_x = t;
                //Increase value
                colour++;
            }
            //set given value 
            returnSet[i][k] = colour;

        }
    }
    //return the 2D set for drawing
    return returnSet;
}

/********************************************************/
/*                     Draw Function                    */
/*  This function draws a given 2D set of values with   */
/*  rectangles, whos colour is dependent on a bucketed  */
/*                 value pre determined.                */
/********************************************************/
void draw(int **toDraw, int mX, int mY){

    //Intialising colour values 
	string green = ""\033[22;32m"";
	string _green = ""\033[01;32m"";
	string orange = ""\033[22;33m"";
	string yellow = ""\033[01;33m"";
	string blue = ""\033[22;34m"";
	string _blue = ""\033[01;34m"";
	string magenta = ""\033[22;35m"";
	string _magenta = ""\033[01;35m"";
	string cyan = ""\033[22;36m"";
	string _cyan = ""\033[01;36m"";

    //iterate through the 2D array toDraw
    for(int i = 0; i < mX; i++){
        for(int k = 0; k < mY; k++){
            //Check colour value of toDraw and print the corresponding coloured rectangle
            if(toDraw[k][i] == 100)      cout << "" "";
            else if(toDraw[k][i] > 90) cout << green << ""\u2588"";
            else if(toDraw[k][i] > 80) cout << _green << ""\u2588"";
            else if(toDraw[k][i] > 70) cout << orange << ""\u2588"";
            else if(toDraw[k][i] > 60) cout << yellow << ""\u2588"";
            else if(toDraw[k][i] > 50) cout << blue << ""\u2588"";
            else if(toDraw[k][i] > 40) cout << _blue << ""\u2588"";
            else if(toDraw[k][i] > 30) cout << magenta << ""\u2588"";
            else if(toDraw[k][i] > 20) cout << _magenta << ""\u2588"";
            else if(toDraw[k][i] > 10) cout << cyan << ""\u2588"";
            else if(toDraw[k][i] > 0) cout << _cyan <<  ""\u2588"";

        }
        //New line once it hits the max width
        cout << ""\n"";
    }
    return;
}

/*********************************************************/
/*                  Fractal Drawer 1.0                   */
/*  Using 2 custom functions, this file allows the user  */
/* to specify 2 input values of max width and max height */
/*   for the program to draw a fractal based of these    */
/*                     dimensions                        */
/*********************************************************/
int main(){
    //Intialise max height and width values
    int maxX, maxY;
    cout << "" Input Max X size: "";
    cin >> maxX;
    cout << "" Input Max Y size: "";    
    cin >> maxY;

    //Create a 2D set of values that determine colour value
    int **set = calculateSet(maxX, maxY);
    //Draw using 2D array of values
    draw(set, maxX, maxY);
        
    return 0;
}",Only your latest submission will be checked,AC,C++17,2022-07-30 15:05:56.61378,10
267,coffeepls,1,1007,"n, q = input().split()

n = int(n)
q = int(q)
l = ['white']*n
i = 0
ans = []
while (i<q):
    query = input().split()
    i += 1
    if query[0]=='q':
        ans.append(l[int(query[1])])
    else:
        a = int(query[1])
        b = int(query[2])
        for j in range(a, b+1):
            l[j] = query[3]
for i in range(len(ans)):
    print(ans[i])","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 12, in <module>
    ans.append(l[int(query[1])])
IndexError: list index out of range
",ERR,Python3,2022-07-30 15:06:26.537553,0
268,untitled,1,1005,"#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> edges;

int main() {
    int n, m;
    cin >> n >> m;
    edges = vector<vector<int>>(n);
    vector<int> inDegree(n);
    vector<vector<pair<int,int>>> queries(m-1);
    vector<vector<bool>> used(m-1, vector<bool>(n));
    int failedCount = 0;
    vector<pair<int,int>> needed;
    for(int i = 0; i < n; i++){
        for(int j = i+1; j < n; j++){
            needed.push_back({i, j});
        }
    }
    random_shuffle(needed.begin(), needed.end());
    for(int i = 0; i < needed.size(); i++){
            bool worked = false;
            for(int k = 0; k < m-1; k++){
                int u = needed[i].first, v = needed[i].second;
                if(!used[k][u] && !used[k][v]){
                    used[k][u] = true;
                    used[k][v] = true;
                    queries[k].push_back({u, v});
                    worked = true;
                    //cout << ""success"" << endl;
                    break;
                }
            }
            if(!worked) {
                failedCount++;
            }
    }
    //cout << failedCount << endl;
    for(int i = 0; i < m-1; i++){
        if(!queries[i].empty()){
            cout << ""q "" << queries[i].size() << endl;
        }
        for(int j = 0; j < queries[i].size(); j++){
            cout << queries[i][j].first << "" < "" << queries[i][j].second << endl;
        }
        for(int j = 0; j < queries[i].size(); j++){
            int val;
            cin >> val;
            int u = queries[i][j].first, v = queries[i][j].second;
            if(val == 1){
                edges[u].push_back(v);
                inDegree[v]++;
            }else{
                edges[v].push_back(u);
                inDegree[u]++;
            }
        }
    }
    queue<int> q;
    for(int i = 0; i < n; i++){
        if(inDegree[i] == 0){
            q.push(i);
        }
    }
    vector<int> answer;
    while(!q.empty()){
        int cur = q.front();
        q.pop();
        answer.push_back(cur);
        for(int i = 0; i < edges[cur].size(); i++){
            int next = edges[cur][i];
            inDegree[next]--;
            if(inDegree[next] == 0){
                q.push(next);
            }
        }
    }
    cout << ""a "";
    for(int i = 0; i < answer.size(); i++){
        cout << answer[i];
        if(i < (int)answer.size() - 1) {
            cout << "" "";
        }
    }
    cout << endl;
    int result;
    cin >> result;
}","WA on case 2, test 0","",C++17,2022-07-30 15:06:41.190139,70
269,teamAverage,1,1009,"#include <iostream>
#include <ctime>
#include <cstdio>
#include <chrono>
#include <thread>
using namespace std;
 
// change row and column value to set the canvas size
const int row = 24;
const int col = 80;

// returns the count of alive neighbours
int count_live_neighbour_cell(int a[row][col], int r, int c){
    int i, j, count = 0;
    for (i = r - 1; i <= r + 1; i++) {
        for (j = c - 1; j <= c + 1; j++) {
            if ((i == r && j == c) || (i < 0 || j < 0)
                || (i >= row || j >= col)) {
                continue;
            }
            if (a[i][j] == 1) {
                count++;
            }
        }
    }
    return count;
}
 
int main(){
    int b[row][col];
    int i, j;
    int neighbour_live_cell;

    srand(time(NULL));

    // generate matrix canvas with random values (live and
    // dead cells)
    int a[row][col]= {
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0},
    {0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0},
    {0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0},
    {0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0},
    {0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0},
    {0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0},
    {0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
    };
 
    // print array matrix
    for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++) {
            if(b[i][j]==0){
                    cout<<'.';
                }
                else
                    cout<<'0';
        }
        cout << ""\n"";
    }
    int time = 30;
    time *= CLOCKS_PER_SEC;
    clock_t curr = clock();
    while(clock()-curr<time){
        // next canvas values based on live neighbour count
        for (i = 0; i < row; i++) {
            for (j = 0; j < col; j++) {
                neighbour_live_cell
                    = count_live_neighbour_cell(a, i, j);
                if (a[i][j] == 1
                    && (neighbour_live_cell == 2
                        || neighbour_live_cell == 3)) {
                    b[i][j] = 1;
                }
    
                else if (a[i][j] == 0
                        && neighbour_live_cell == 3) {
                    b[i][j] = 1;
                }
    
                else {
                    b[i][j] = 0;
                }
            }
        }
    
        // print next generation
        for (i = 0; i < row; i++) {
            for (j = 0; j < col; j++) {
                a[i][j] = b[i][j];
                if(b[i][j]==0){
                    cout<<' ';
                }
                else
                    cout<<'#';
            }
            cout << ""\n"";
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }
 
    return 0;
}",Only your latest submission will be checked,AC,C++17,2022-07-30 15:07:04.820802,10
270,duckduckdoo,1,1005,"#include <iostream>
using namespace std;
  
// Function to print an array 
void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        cout << arr[i] << "" "";
    cout << endl;
}
  
// Driver code
int main()
{
  int arrSize, numQueries;
  cin>>arrSize>>numQueries;
  int arr[arrSize];
  for (int i = 0; i < arrSize; i++)
    arr[i] = i;
  
  for (int i = 0; i < arrSize - 1; i++) {
    for (int j = 0; j < arrSize - i - 1; j++) {
      cout<<""q 1""<<endl;
      cout<<arr[j]<<"" > ""<<arr[j+1]<<endl;
      bool x;
      cin>>x;
      if (x) {
        swap(arr[j], arr[j + 1]);
      }
    }
    
    cout<<""a "";
    printArray(arr, arrSize);
  }
  int correct;
  cin>>correct;
  return 0;
}",,judging,C++17,2022-07-30 15:07:47.461874,0
280,teamAverage,1,1008,"import javafx.application.Application;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import javafx.scene.shape.Ellipse;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;

public class Lab8A extends Application {
	private Pane root;
	private Line line;
	private Ellipse circle;
	private double xCenter;
	private double yCenter;
	private int count;
	
	/**
		@return overrides start method
	*/
	@Override
	public void start(Stage primaryStage) {
		root = new Pane();
		
		line = new Line(-10,-10,-10,-10);
		line.setStroke(Color.RED);
		circle = new Ellipse(-10,-10,-10,-10);
		circle.setFill(Color.TRANSPARENT);
		circle.setStroke(Color.RED);
		root.getChildren().addAll(line, circle);
		
		root.setOnMousePressed(new MousePress());
		
		Scene scene = new Scene(root, 500, 500);
		primaryStage.setTitle(""Lines"");
		primaryStage.setScene(scene);
		primaryStage.show();
	}
	
	/**
		Class MousePress overides Event Handler for when the mouse
		is pressed
	*/
	private class MousePress implements EventHandler<MouseEvent> {
		/**
			@return overrides handle method
		*/
		@Override
		public void handle(MouseEvent e) {
			count++;
			if(count == 1){
				line.setVisible(true);

				xCenter = e.getX();
				yCenter = e.getY();
				
				line.setStartX(xCenter);
				line.setEndX(xCenter);
				line.setStartY(yCenter);
				line.setEndY(yCenter);

				root.setOnMouseMoved(new MouseMoved());
			}

			if(count == 2){
				line.setVisible(false);

				double r = Math.sqrt(Math.pow(e.getX()-xCenter, 2) + 
					Math.pow(e.getY()-yCenter, 2));
				
				Ellipse newCircle = new Ellipse(xCenter, yCenter, r, r);
				newCircle.setFill(Color.TRANSPARENT);
				newCircle.setStroke(Color.BLUE);
				root.getChildren().add(newCircle);

				count = 0;
			}
		}
	}	

	/**
		Class MouseMoved overides Event Handler for when the mouse
		is moving. It runs when the mouse is clicked.
	*/
	private class MouseMoved implements EventHandler<MouseEvent>{
		/**
			@return overrides handle method
		*/
		@Override
		public void handle(MouseEvent e){
			if(count == 1){
				line.setEndX(e.getX());
				line.setEndY(e.getY());
				line.getStrokeDashArray().add(5d);

				double r = Math.sqrt(Math.pow(e.getX()-xCenter, 2) + 
					Math.pow(e.getY()-yCenter, 2));

				circle.setCenterX(xCenter);
				circle.setCenterY(yCenter);
				circle.setRadiusX(r);
				circle.setRadiusY(r);
			}
		}
	}

	public static void main(String[] args) {
		Application.launch(args);
	}
}

","/code/Main.java:12: error: class Lab8A is public, should be declared in a file named Lab8A.java
public class Lab8A extends Application {
       ^
/code/Main.java:1: error: package javafx.application does not exist
import javafx.application.Application;
                         ^
/code/Main.java:2: error: package javafx.event does not exist
import javafx.event.EventHandler;
                   ^
/code/Main.java:3: error: package javafx.scene does not exist
import javafx.scene.Scene;
                   ^
/code/Main.java:4: error: package javafx.scene.input does not exist
import javafx.scene.input.MouseEvent;
                         ^
/code/Main.java:5: error: package javafx.scene.layout does not exist
import javafx.scene.layout.Pane;
                          ^
/code/Main.java:6: error: package javafx.scene.paint does not exist
import javafx.scene.paint.Color;
                         ^
/code/Main.java:7: error: package javafx.stage does not exist
import javafx.stage.Stage;
                   ^
/code/Main.java:8: error: package javafx.scene.shape does not exist
import javafx.scene.shape.Ellipse;
                         ^
/code/Main.java:9: error: package javafx.scene.shape does not exist
import javafx.scene.shape.Line;
                         ^
/code/Main.java:10: error: package javafx.scene.shape does not exist
import javafx.scene.shape.Rectangle;
                         ^
/code/Main.java:12: error: cannot find symbol
public class Lab8A extends Application {
                           ^
  symbol: class Application
/code/Main.java:13: error: cannot find symbol
	private Pane root;
	        ^
  symbol:   class Pane
  location: class Lab8A
/code/Main.java:14: error: cannot find symbol
	private Line line;
	        ^
  symbol:   class Line
  location: class Lab8A
/code/Main.java:15: error: cannot find symbol
	private Ellipse circle;
	        ^
  symbol:   class Ellipse
  location: class Lab8A
/code/Main.java:24: error: cannot find symbol
	public void start(Stage primaryStage) {
	                  ^
  symbol:   class Stage
  location: class Lab8A
/code/Main.java:46: error: cannot find symbol
	private class MousePress implements EventHandler<MouseEvent> {
	                                    ^
  symbol:   class EventHandler
  location: class Lab8A
/code/Main.java:46: error: cannot find symbol
	private class MousePress implements EventHandler<MouseEvent> {
	                                                 ^
  symbol:   class MouseEvent
  location: class Lab8A
/code/Main.java:51: error: cannot find symbol
		public void handle(MouseEvent e) {
		                   ^
  symbol:   class MouseEvent
  location: class Lab8A.MousePress
/code/Main.java:87: error: cannot find symbol
	private class MouseMoved implements EventHandler<MouseEvent>{
	                                    ^
  symbol:   class EventHandler
  location: class Lab8A
/code/Main.java:87: error: cannot find symbol
	private class MouseMoved implements EventHandler<MouseEvent>{
	                                                 ^
  symbol:   class MouseEvent
  location: class Lab8A
/code/Main.java:92: error: cannot find symbol
		public void handle(MouseEvent e){
		                   ^
  symbol:   class MouseEvent
  location: class Lab8A.MouseMoved
/code/Main.java:23: error: method does not override or implement a method from a supertype
	@Override
	^
/code/Main.java:25: error: cannot find symbol
		root = new Pane();
		           ^
  symbol:   class Pane
  location: class Lab8A
/code/Main.java:27: error: cannot find symbol
		line = new Line(-10,-10,-10,-10);
		           ^
  symbol:   class Line
  location: class Lab8A
/code/Main.java:28: error: cannot find symbol
		line.setStroke(Color.RED);
		               ^
  symbol:   variable Color
  location: class Lab8A
/code/Main.java:29: error: cannot find symbol
		circle = new Ellipse(-10,-10,-10,-10);
		             ^
  symbol:   class Ellipse
  location: class Lab8A
/code/Main.java:30: error: cannot find symbol
		circle.setFill(Color.TRANSPARENT);
		               ^
  symbol:   variable Color
  location: class Lab8A
/code/Main.java:31: error: cannot find symbol
		circle.setStroke(Color.RED);
		                 ^
  symbol:   variable Color
  location: class Lab8A
/code/Main.java:36: error: cannot find symbol
		Scene scene = new Scene(root, 500, 500);
		^
  symbol:   class Scene
  location: class Lab8A
/code/Main.java:36: error: cannot find symbol
		Scene scene = new Scene(root, 500, 500);
		                  ^
  symbol:   class Scene
  location: class Lab8A
/code/Main.java:50: error: method does not override or implement a method from a supertype
		@Override
		^
/code/Main.java:73: error: cannot find symbol
				Ellipse newCircle = new Ellipse(xCenter, yCenter, r, r);
				^
  symbol:   class Ellipse
  location: class Lab8A.MousePress
/code/Main.java:73: error: cannot find symbol
				Ellipse newCircle = new Ellipse(xCenter, yCenter, r, r);
				                        ^
  symbol:   class Ellipse
  location: class Lab8A.MousePress
/code/Main.java:74: error: cannot find symbol
				newCircle.setFill(Color.TRANSPARENT);
				                  ^
  symbol:   variable Color
  location: class Lab8A.MousePress
/code/Main.java:75: error: cannot find symbol
				newCircle.setStroke(Color.BLUE);
				                    ^
  symbol:   variable Color
  location: class Lab8A.MousePress
/code/Main.java:91: error: method does not override or implement a method from a supertype
		@Override
		^
/code/Main.java:110: error: cannot find symbol
		Application.launch(args);
		^
  symbol:   variable Application
  location: class Lab8A
38 errors
",CERR,Java17,2022-07-30 15:15:41.51893,0
271,teamAverage,1,1005,"using namespace std;
#include <iostream>

int main() {
  int n, m, ind, trial = 0,temp, x=0;
  int numOfComparison = n / 2;
  cin >> n;
  cin >> m;
  int indexes[n],indexesP[n];
  bool comparisonRes[numOfComparison], sorted = 0, sortCh[n];
  for (int i = 0; i < n; i++) {
    indexes[i] = i;
  }
  while (!sorted&&trial<m) {
    if(trial%2 == 0){
      x=0;
      for(int i=0;i<numOfComparison;i++){
        cout<<indexes[x++];
        cout<<"" < ""<<indexes[x++]<<endl;
      }
      for(int i=0;i<numOfComparison;i++){
        cin>>comparisonRes[i];
      }
      sorted = 1;
      for(int i=0;i<numOfComparison;i++){
        if (!comparisonRes[i]){
          sorted = 0;
          temp = indexes[i*2];
          indexes[i*2] = indexes[i*2+1];
          indexes[i*2+1] = temp;
        }
      }
    }
    else{
      x=n;
      for (int i=0;i<numOfComparison;i++){
        cout<<indexes[x--];
        cout<<"" > ""<<indexes[x--]<<endl;
      }
      for(int i=0;i<numOfComparison;i++){
        cin>>comparisonRes[i];
      }
      sorted = 1;
      for(int i=0;i<numOfComparison;i++){
        if (!comparisonRes[i]){
          sorted = 0;
          temp = indexes[i*2];
          indexes[n-i*2-1] = indexes[n-(i*2+2)];
          indexes[n-(i*2+2)] = temp;
        }
      }
    }
    
    trial++;
    
  }
  cout<<""a "";
  for (int i=0;i<n;i++){
    cout<<indexes[i]<<"" "";
  }
  
}
","WA on case 0, test 0",WA,C++17,2022-07-30 15:08:35.578204,0
272,HS,1,1005,"
#include <bits/stdc++.h>
using namespace std;

struct Node_struct {
    vector<int> prev;
    vector<int> next;
};

int n, m;
int max_comparison;
vector<struct Node_struct> nodes;
int num_comparisons;
vector<pair<int, int>> comparison_targets;
vector<pair<int, int>> comparison_caller; // this is for change after comparison
vector<bool> in_targets;
vector<bool> visited;

// add to targets. increment num_comparisons
// option: (1: from prev), (2: from next)
void add_to_targets(const int& a, const int& b, const int& caller, const int& option) {
    comparison_targets.push_back(pair<int, int>(a, b));
    comparison_caller.push_back(pair<int, int>(caller, option));
    in_targets[a] = true;
    in_targets[b] = true;
    num_comparisons++;
}

/*DFS description:
    test if more than 2 prevs
        find possible targets and add
        return if (num_comparisons == m)
    test if more than 2 nexts
        find possible targets and add
        return if (num_comparisons == m)
    iterate nexts
        if not visited, DFS that.
        return if (num_comparisons == m)
*/
void DFS(const int& current) {
    visited[current] = true;
    if (nodes[current].prev.size() > 1) {
        int i = 0;
        while (num_comparisons < max_comparison && i < nodes[current].prev.size()) {
            int a = -1;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    a = nodes[current].prev[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    b = nodes[current].prev[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 1);
            }
        }
        if (num_comparisons == max_comparison) return;
    }
    if (nodes[current].next.size() > 1) {
        int i = 0;
        while (num_comparisons < max_comparison && i < nodes[current].next.size()) {
            int a = -1;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    a = nodes[current].next[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    b = nodes[current].next[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 2);
            }
        }
        if (num_comparisons == max_comparison) return;
    }

    // children
    for (int i = 0; i < nodes[current].next.size(); i++) {
        if (!visited[nodes[current].next[i]]) {
            DFS(nodes[current].next[i]);
            if (num_comparisons == max_comparison) return;
        }
    }
    for (int i = 0; i < nodes[current].prev.size(); i++) {
        if (!visited[nodes[current].prev[i]]) {
            DFS(nodes[current].prev[i]);
            if (num_comparisons == max_comparison) return;
        }
    }
}

int main()
{
    cin >> n >> m;
    
    max_comparison = n/2;
    nodes = vector<struct Node_struct>(n);
    
    bool ans_found = false;
    for(int i = 0; i < m; i++) {
        num_comparisons = 0;
        comparison_targets.clear();
        comparison_caller.clear();
        in_targets = vector<bool>(n, false);
        visited = vector<bool>(n, false);
        
        int last_DFS_start = -1;
        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            // connect disconnected graph
            if (last_DFS_start != -1) {
                for (int j = i-1; j >= 0; j--) {
                    if (!in_targets[j]) {
                        add_to_targets(j, i, -1, -1);
                        break;
                    }
                }
                if (num_comparisons == max_comparison) break;
            }
            // run DFS
            DFS(i);
            last_DFS_start = i;
            if (num_comparisons == max_comparison) break;
        }
        
        // break if no change
        if (num_comparisons == 0) break;
        
        // send query
        cout << ""q "" << num_comparisons << endl;
        for (int i = 0; i < num_comparisons; i++) {
             cout << comparison_targets[i].first << "" < "" << comparison_targets[i].second << endl;
        }
        
        // receive input
        for (int i = 0; i < num_comparisons; i++) {
            int ans;
            cin >> ans;
            
            // get 2 target nodes
            int a, b; // a <= b
            if (ans == 1) {
                a = comparison_targets[i].first;
                b = comparison_targets[i].second;
            }
            else {
                a = comparison_targets[i].second;
                b = comparison_targets[i].first;
            }
            // get caller and option
            int caller = comparison_caller[i].first;
            int option = comparison_caller[i].second;
            
            // connect two nodes
            //cout << ""--edge created between "" << a << "" -> "" << b << endl;
            nodes[a].next.push_back(b);
            nodes[b].prev.push_back(a);
            
            if (caller == -1) {
                // called to connect disconnected graphs
                // do nothing
            }
            else if (option == 1) {
                // called from caller's prev
                auto to_remove = find(nodes[caller].prev.begin(), nodes[caller].prev.end(), a);
                nodes[caller].prev.erase(to_remove);
                to_remove = find(nodes[a].next.begin(), nodes[a].next.end(), caller);
                nodes[a].next.erase(to_remove);
            }
            else if (option == 2) {
                // called from caller's next
                auto to_remove = find(nodes[caller].next.begin(), nodes[caller].next.end(), b);
                nodes[caller].next.erase(to_remove);
                to_remove = find(nodes[b].prev.begin(), nodes[b].prev.end(), caller);
                nodes[b].prev.erase(to_remove);
            }
        }
    }
    if (num_comparisons == 0) {
        // start from the very first
        int current = 0;
        while (nodes[current].prev.size() != 0) {
            current = nodes[current].prev[0];
        }
        cout << ""a "";
        while (nodes[current].next.size() != 0) {
            cout << current << "" "";
            current = nodes[current].next[0];
        }
        cout << current;
        cout << endl;
    }
    int result;
    cin >> result;
    cout << flush;

    return 0;
}
","WA on case 0, test 3",WA,C++17,2022-07-30 15:09:01.711277,0
273,coffeepls,1,1007,"n, q = input().split()

n = int(n)
q = int(q)
l = ['white']*n
i = 0
ans = []
while (i<q):
    query = input().split()
    i += 1
    if query[0]=='q':
        ans.append(l[int(query[1])])
    else:
        a = int(query[1])
        b = int(query[2])
        for j in range(a, b+1):
            l[j] = query[3]
for i in range(len(ans)):
    print(ans[i])","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 12, in <module>
    ans.append(l[int(query[1])])
IndexError: list index out of range
",ERR,Python3,2022-07-30 15:09:18.14308,0
274,TeamJin,1,1005,"from ast import operator
from re import L


nums = list(map(int, input().split()))
n = nums[0]
m = nums[1]

aLst = list(range(n))



def compAnswer():
    return int(input())


def query(num1, num2):
    print(""q 1"")
    print(str(num1) + ""<"" + str(num2))
    return compAnswer()


#--------------GeekForGeeks COPY--------------------------------------------------------
def partition(l, r, nums):
    # Last element will be the pivot and the first element the pointer
    pivot = nums[r]
    ptr = l

    for i in range(l, r):
        #nums[i] <= pivot
        if query(nums[i], pivot):
            # Swapping values smaller than the pivot to the front
            nums[i], nums[ptr] = nums[ptr], nums[i]
            ptr += 1
    # Finally swapping the last element with the pointer indexed number
    nums[ptr], nums[r] = nums[r], nums[ptr]
    return ptr
 
# With quicksort() function, we will be utilizing the above code to obtain the pointer
# at which the left values are all smaller than the number at pointer index and vice versa
# for the right values.
 
 
def quicksort(l, r, nums):
    if len(nums) == 1:  # Terminating Condition for recursion. VERY IMPORTANT!
        return nums
    if l < r:
        pi = partition(l, r, nums)
        quicksort(l, pi-1, nums)  # Recursively sorting the left values
        quicksort(pi+1, r, nums)  # Recursively sorting the right values
    return nums
#--------------------------------------------------------------


quicksort(0, len(aLst), aLst)


def printAnswer():
    retSt = """"
    for i in range(len(aLst)):
        retSt += str(aLst[i])
    print(""a"" + retSt)","WA on case 0, test 0",WA,Python3,2022-07-30 15:10:53.618294,0
275,NKSquared,1,1008,"#include <bits/stdc++.h>
#define WIDTH 50
#define SENTINEL ""stop""

// *************************************************
//                       README
//
// This program provides a tool for a user to input
// contact information into an address book and to
// print it out to console.  The implementation
// permits printing via public interface.
//
// Logistically, it seems we can upload one file, so
// this program is not divided among separate header
// files.
//
// *************************************************

class AddressBook
{
    // The print function is public interface:
    public:
        virtual void printBook() = 0;
    public:
        virtual ~AddressBook() = default; // note: vectors handle all memory management
};

// data class
class BookData : public AddressBook
{
    public:
        BookData();            // the constructor acquires user data
        ~BookData() = default; // note: vectors handle all memory management
    
    public:
        void printBook();      // this function is pure virtual in parent
        
    private:
        // Buffer for strings inputted by the user
        std::vector<std::string> buffer;
        // Temporary string to capture user inputs
        std::string capture = ""empty"";
        // Address book
        std::vector< std::vector<std::string> >book;
};

BookData::BookData()
{
    // Input contact name to buffer - special first line for user
    std::cout << ""Please enter the name of one of your contacts: \n"";
    while(1)
    {
        // Acquire and copy input contact name to buffer
        std::getline (std::cin, this -> capture);
        if (this -> capture == SENTINEL) // ""stop"" escapes data entry process
            break;
        std::cout << ""You have entered "" << this -> capture << ""\n"";
        std::cout << ""Enter 'stop' when you are done. \n"";
        (this -> buffer).push_back(this -> capture);
        // Acquire and copy input contact name to buffer
        std::cout << ""Please enter the address of your contact: \n"";
        std::getline (std::cin, this -> capture);
        if (this -> capture == SENTINEL)
            break;
        std::cout << ""You have entered "" << this -> capture << ""\n"";
        std::cout << ""Enter 'stop' when you are done. \n"";
        (this -> buffer).push_back(this -> capture);
        // Add to book from buffer and clear buffer
        (this -> book).push_back(this -> buffer);
        (this -> buffer).clear();
        std::cout << ""Please enter the name of another one of your contacts: \n"";
    }
}

void BookData::printBook()
{
    // Iterate through the book - the iterator is itB
    int j = 1;
    auto itB = begin(this -> book);
    while (itB != end(this -> book))
    {
        // Iterate through the info for a single contact - the iterator is itb
        std::cout << ""Contact #"" << j++ << "": "" << std::endl;
        auto itb = begin(*itB);
        while (itb != end(*itB))
            std::cout << std::setw(WIDTH) << *itb++ << std::endl;
        std::cout << std::setw(0);
        ++itB;
    }
}

// *************************************************
//                      DRIVER
//
// The driver for this program accesses the public
// print function via interface.  The user does not
// need to see a BookData object as such.
//
// *************************************************


int main()
{
    BookData b;
    AddressBook * publicBook = &b;
    publicBook -> printBook();
    std::cout << ""\nThank you for trying Address Book and have a nice day.\n\n"";
    return 0;
}",Only your latest submission will be checked,AC,C++17,2022-07-30 15:12:04.791007,10
276,TeamJin,1,1005,"from ast import operator
from re import L


nums = list(map(int, input().split()))
n = nums[0]
m = nums[1]

aLst = list(range(n))



def compAnswer():
    return int(input())


def query(num1, num2):
    print(""q 1"")
    print(str(num1) + ""<"" + str(num2))
    return compAnswer()


#--------------GeekForGeeks COPY--------------------------------------------------------
def partition(l, r, nums):
    # Last element will be the pivot and the first element the pointer
    pivot = nums[r]
    ptr = l

    for i in range(l, r):
        #nums[i] <= pivot
        if query(nums[i], pivot):
            # Swapping values smaller than the pivot to the front
            nums[i], nums[ptr] = nums[ptr], nums[i]
            ptr += 1
    # Finally swapping the last element with the pointer indexed number
    nums[ptr], nums[r] = nums[r], nums[ptr]
    return ptr
 
# With quicksort() function, we will be utilizing the above code to obtain the pointer
# at which the left values are all smaller than the number at pointer index and vice versa
# for the right values.
 
 
def quicksort(l, r, nums):
    #if len(nums) == 1:  # Terminating Condition for recursion. VERY IMPORTANT!
     #   return nums
    if l < r:
        pi = partition(l, r, nums)
        quicksort(l, pi-1, nums)  # Recursively sorting the left values
        quicksort(pi+1, r, nums)  # Recursively sorting the right values
    return nums
#--------------------------------------------------------------


quicksort(0, len(aLst), aLst)


def printAnswer():
    retSt = """"
    for i in range(len(aLst)):
        retSt += str(aLst[i])
    print(""a"" + retSt)","WA on case 0, test 0",WA,Python3,2022-07-30 15:12:53.780883,0
277,duckduckdoo,1,1005,"#include <iostream>
using namespace std;
  
// Function to print an array 
void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        cout << arr[i] << "" "";
    cout << endl;
}
  
// Driver code
int main()
{
  int arrSize, numQueries;
  cin>>arrSize>>numQueries;
  int arr[arrSize];
  for (int i = 0; i < arrSize; i++)
    arr[i] = i;
  
  for (int i = 0; i < arrSize - 1; i++) {
    for (int j = 0; j < arrSize - i - 1; j++) {
      cout<<""q 1""<<endl;
      cout<<arr[j]<<"" > ""<<arr[j+1]<<endl;
      bool x;
      cin>>x;
      if (x) {
        swap(arr[j], arr[j + 1]);
      }
    }
    
    cout<<""a "";
    printArray(arr, arrSize);
  }
  int correct;
  cin>>correct;
  return 0;
}","WA on case 0, test 1","",C++17,2022-07-30 15:14:03.035291,0
284,datOvercommon,1,1005,"#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <queue>

using namespace std;

class node {
public:
	int index;
	vector<node*> lesser;
	node(int ind) : index(ind) { }
	int height(node* i, int height)
	{
		if (i->lesser.size() == 0) return 1;
		while (lesser.size() != 0)
		{
			int max = 0;
			for (auto& k : i->lesser)
			{
				if (i->height(k, height) > max) max = i->height(k, height);
			}
			return 1 + max;
		}
	}
};
int sorted(vector<node*>& nodes, int& n)
{
	for (int i = 0; i < nodes.size(); i++)
	{
		if (nodes[i]->height(nodes[i], 1) == n) return i;
	}
	return -1;
}
void permutation(string s)
{
	sort(s.begin(), s.end());
	do {
		cout << s << "" "";
	} while (next_permutation(s.begin(), s.end())); // std::next_permutation

	cout << endl;
}
int main()
{
	vector<node*> nodes;
	int n, m,temp;
	cin >> n;
	if (n == -1) return 0;
	cin >> m;
	if (m == -1) return 0;

	for (int i = 0; i < n; i++) 
	{
		node* newnode = new node(i);
		nodes.push_back(newnode); 
	}
	//while (!sorted(nodes,n))
	//{

	//}

	for (int k = 0; k < n; k++)
	{
		vector<pair<node*, node*>> nodepairs;
		int index = k,space = 1;
		for (int i = 0; i < n/2; i++)
		{
			space = (index + 1) % n;
			//Run code
			nodepairs.push_back({ nodes[index], nodes[space] });
			index = (index + 2) % n;
		}
		cout << ""q "" << n / 2 << endl;
		for (auto& i : nodepairs) cout << i.first->index << "" > "" << i.second->index << endl;
		for (auto& i : nodepairs)
		{
			cin >> temp;
			if (temp == -1) return 0;
			if (temp == 1) i.first->lesser.push_back(i.second);
			else i.second->lesser.push_back(i.first);
		}
		if (sorted(nodes, n) != -1)
		{
			vector<int> ordered;
			node* iterate = nodes[sorted(nodes, n)];
			ordered.push_back(iterate->index);
			while (iterate->lesser.size() != 0)
			{
				int maxheight = 0,max,index = 0;
				for (auto i : iterate->lesser)
				{
					if (i->height(i, 1) > maxheight)
					{
						maxheight = i->height(i, 1);
						max = index;
					}
					++index;
				}
				iterate = iterate->lesser[max];
				ordered.push_back(iterate->index);
			}
			reverse(ordered.begin(), ordered.end());
			cout << ""a "";
			for (int i = 0; i < ordered.size() - 1; i++) cout << ordered[i] << "" "";
			cout << ordered[ordered.size() - 1] << endl;
			cin >> temp;
			break;
		}
	}
	return 0;
}","WA on case 0, test 2",WA,C++17,2022-07-30 15:17:23.824744,0
278,theKevin27,1,1007,"#include <iostream>
#include <string>
#include <vector>

struct range {
  int start;
  int end;
  std::string colour;
};

std::vector<std::string> parseString(std::string input) {
  std::vector<std::string> strings;
  int index = 0;
  int length = 0;
  for (int i = 0; i < input.length(); i++) {
    if (input.at(i) == ' ') {
      std::string string = input.substr(index, length);
      strings.push_back(string);
      index = i + 1;
      length = 0;
    }
    length++;
  }
  std::string string = input.substr(index, input.length() - index);
  strings.push_back(string);
  return strings;
}

int main() {
  int n;
  int q;
  std::string input;
  std::getline(std::cin, input);
  std::vector<std::string> v = parseString(input);

  n = stoi(v[0]);
  range base;
  base.start = 1;
  base.end = n;
  base.colour = ""white"";
  q = stoi(v[1]);
  std::vector<range> ranges(q + 1);
  ranges.push_back(base);
  std::vector<std::vector<std::string>> queries;
  for (int i = 0; i < q; i++) {
    std::getline(std::cin, input);
    queries.push_back(parseString(input));
  }
  for (int i = 0; i < queries.size(); i++) {
    if (queries[i][0] == ""q"") {
      int index = stoi(queries[i][1]);
      for (int j = ranges.size() - 1; j >= 0; j--) {
        if (ranges[j].start <= index && ranges[j].end >= index) {
          std::cout << ranges[j].colour << std::endl;
          j = -1;
        }
      }
    }
    if (queries[i][0] == ""p"") {
      range rtemp;
      rtemp.start = stoi(queries[i][1]);
      rtemp.end = stoi(queries[i][2]);
      rtemp.colour = queries[i][3];
      ranges.push_back(rtemp);
    }
  }
}
","Failed on case 5, test 0",TLE,C++17,2022-07-30 15:14:14.343274,80
279,teamAverage,1,1008,"import javafx.application.Application;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import javafx.scene.shape.Ellipse;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;

public class Lab8A extends Application {
	private Pane root;
	private Line line;
	private Ellipse circle;
	private double xCenter;
	private double yCenter;
	private int count;
	
	/**
		@return overrides start method
	*/
	@Override
	public void start(Stage primaryStage) {
		root = new Pane();
		
		line = new Line(-10,-10,-10,-10);
		line.setStroke(Color.RED);
		circle = new Ellipse(-10,-10,-10,-10);
		circle.setFill(Color.TRANSPARENT);
		circle.setStroke(Color.RED);
		root.getChildren().addAll(line, circle);
		
		root.setOnMousePressed(new MousePress());
		
		Scene scene = new Scene(root, 500, 500);
		primaryStage.setTitle(""Lines"");
		primaryStage.setScene(scene);
		primaryStage.show();
	}
	
	/**
		Class MousePress overides Event Handler for when the mouse
		is pressed
	*/
	private class MousePress implements EventHandler<MouseEvent> {
		/**
			@return overrides handle method
		*/
		@Override
		public void handle(MouseEvent e) {
			count++;
			if(count == 1){
				line.setVisible(true);

				xCenter = e.getX();
				yCenter = e.getY();
				
				line.setStartX(xCenter);
				line.setEndX(xCenter);
				line.setStartY(yCenter);
				line.setEndY(yCenter);

				root.setOnMouseMoved(new MouseMoved());
			}

			if(count == 2){
				line.setVisible(false);

				double r = Math.sqrt(Math.pow(e.getX()-xCenter, 2) + 
					Math.pow(e.getY()-yCenter, 2));
				
				Ellipse newCircle = new Ellipse(xCenter, yCenter, r, r);
				newCircle.setFill(Color.TRANSPARENT);
				newCircle.setStroke(Color.BLUE);
				root.getChildren().add(newCircle);

				count = 0;
			}
		}
	}	

	/**
		Class MouseMoved overides Event Handler for when the mouse
		is moving. It runs when the mouse is clicked.
	*/
	private class MouseMoved implements EventHandler<MouseEvent>{
		/**
			@return overrides handle method
		*/
		@Override
		public void handle(MouseEvent e){
			if(count == 1){
				line.setEndX(e.getX());
				line.setEndY(e.getY());
				line.getStrokeDashArray().add(5d);

				double r = Math.sqrt(Math.pow(e.getX()-xCenter, 2) + 
					Math.pow(e.getY()-yCenter, 2));

				circle.setCenterX(xCenter);
				circle.setCenterY(yCenter);
				circle.setRadiusX(r);
				circle.setRadiusY(r);
			}
		}
	}

	public static void main(String[] args) {
		Application.launch(args);
	}
}

","warning: [options] system modules path not set in conjunction with -source 11
/code/Main.java:12: error: class Lab8A is public, should be declared in a file named Lab8A.java
public class Lab8A extends Application {
       ^
/code/Main.java:1: error: package javafx.application does not exist
import javafx.application.Application;
                         ^
/code/Main.java:2: error: package javafx.event does not exist
import javafx.event.EventHandler;
                   ^
/code/Main.java:3: error: package javafx.scene does not exist
import javafx.scene.Scene;
                   ^
/code/Main.java:4: error: package javafx.scene.input does not exist
import javafx.scene.input.MouseEvent;
                         ^
/code/Main.java:5: error: package javafx.scene.layout does not exist
import javafx.scene.layout.Pane;
                          ^
/code/Main.java:6: error: package javafx.scene.paint does not exist
import javafx.scene.paint.Color;
                         ^
/code/Main.java:7: error: package javafx.stage does not exist
import javafx.stage.Stage;
                   ^
/code/Main.java:8: error: package javafx.scene.shape does not exist
import javafx.scene.shape.Ellipse;
                         ^
/code/Main.java:9: error: package javafx.scene.shape does not exist
import javafx.scene.shape.Line;
                         ^
/code/Main.java:10: error: package javafx.scene.shape does not exist
import javafx.scene.shape.Rectangle;
                         ^
/code/Main.java:12: error: cannot find symbol
public class Lab8A extends Application {
                           ^
  symbol: class Application
/code/Main.java:13: error: cannot find symbol
	private Pane root;
	        ^
  symbol:   class Pane
  location: class Lab8A
/code/Main.java:14: error: cannot find symbol
	private Line line;
	        ^
  symbol:   class Line
  location: class Lab8A
/code/Main.java:15: error: cannot find symbol
	private Ellipse circle;
	        ^
  symbol:   class Ellipse
  location: class Lab8A
/code/Main.java:24: error: cannot find symbol
	public void start(Stage primaryStage) {
	                  ^
  symbol:   class Stage
  location: class Lab8A
/code/Main.java:46: error: cannot find symbol
	private class MousePress implements EventHandler<MouseEvent> {
	                                    ^
  symbol:   class EventHandler
  location: class Lab8A
/code/Main.java:46: error: cannot find symbol
	private class MousePress implements EventHandler<MouseEvent> {
	                                                 ^
  symbol:   class MouseEvent
  location: class Lab8A
/code/Main.java:51: error: cannot find symbol
		public void handle(MouseEvent e) {
		                   ^
  symbol:   class MouseEvent
  location: class Lab8A.MousePress
/code/Main.java:87: error: cannot find symbol
	private class MouseMoved implements EventHandler<MouseEvent>{
	                                    ^
  symbol:   class EventHandler
  location: class Lab8A
/code/Main.java:87: error: cannot find symbol
	private class MouseMoved implements EventHandler<MouseEvent>{
	                                                 ^
  symbol:   class MouseEvent
  location: class Lab8A
/code/Main.java:92: error: cannot find symbol
		public void handle(MouseEvent e){
		                   ^
  symbol:   class MouseEvent
  location: class Lab8A.MouseMoved
/code/Main.java:23: error: method does not override or implement a method from a supertype
	@Override
	^
/code/Main.java:25: error: cannot find symbol
		root = new Pane();
		           ^
  symbol:   class Pane
  location: class Lab8A
/code/Main.java:27: error: cannot find symbol
		line = new Line(-10,-10,-10,-10);
		           ^
  symbol:   class Line
  location: class Lab8A
/code/Main.java:28: error: cannot find symbol
		line.setStroke(Color.RED);
		               ^
  symbol:   variable Color
  location: class Lab8A
/code/Main.java:29: error: cannot find symbol
		circle = new Ellipse(-10,-10,-10,-10);
		             ^
  symbol:   class Ellipse
  location: class Lab8A
/code/Main.java:30: error: cannot find symbol
		circle.setFill(Color.TRANSPARENT);
		               ^
  symbol:   variable Color
  location: class Lab8A
/code/Main.java:31: error: cannot find symbol
		circle.setStroke(Color.RED);
		                 ^
  symbol:   variable Color
  location: class Lab8A
/code/Main.java:36: error: cannot find symbol
		Scene scene = new Scene(root, 500, 500);
		^
  symbol:   class Scene
  location: class Lab8A
/code/Main.java:36: error: cannot find symbol
		Scene scene = new Scene(root, 500, 500);
		                  ^
  symbol:   class Scene
  location: class Lab8A
/code/Main.java:50: error: method does not override or implement a method from a supertype
		@Override
		^
/code/Main.java:73: error: cannot find symbol
				Ellipse newCircle = new Ellipse(xCenter, yCenter, r, r);
				^
  symbol:   class Ellipse
  location: class Lab8A.MousePress
/code/Main.java:73: error: cannot find symbol
				Ellipse newCircle = new Ellipse(xCenter, yCenter, r, r);
				                        ^
  symbol:   class Ellipse
  location: class Lab8A.MousePress
/code/Main.java:74: error: cannot find symbol
				newCircle.setFill(Color.TRANSPARENT);
				                  ^
  symbol:   variable Color
  location: class Lab8A.MousePress
/code/Main.java:75: error: cannot find symbol
				newCircle.setStroke(Color.BLUE);
				                    ^
  symbol:   variable Color
  location: class Lab8A.MousePress
/code/Main.java:91: error: method does not override or implement a method from a supertype
		@Override
		^
/code/Main.java:110: error: cannot find symbol
		Application.launch(args);
		^
  symbol:   variable Application
  location: class Lab8A
38 errors
1 warning
",CERR,Java11,2022-07-30 15:15:01.15059,0
281,teamAverage,1,1005,"using namespace std;
#include <iostream>

int main() {
  int n, m, ind, trial = 0,temp, x=0;
  int numOfComparison ;
  cin >> n;
  cin >> m;
  numOfComparison = n/2;
  int indexes[n],indexesP[n],comparisonRes[numOfComparison];
  bool sorted = 0;
  for (int i = 0; i < n; i++) {
    indexes[i] = i;
  }
  while (!sorted&&trial<m) {
    if(trial%2 == 0){
      x=0;
      for(int i=0;i<numOfComparison;i++){
        cout<<indexes[x++];
        cout<<"" < ""<<indexes[x++]<<endl;
      }
      for(int i=0;i<numOfComparison;i++){
        cin>>comparisonRes[i];
        if (comparisonRes[i]==-1){
          return;
        }
      }
      sorted = 1;
      for(int i=0;i<numOfComparison;i++){
        if (comparisonRes[i]==0){
          sorted = 0;
          temp = indexes[i*2];
          indexes[i*2] = indexes[i*2+1];
          indexes[i*2+1] = temp;
        }
      }
    }
    else{
      x=n;
      for (int i=0;i<numOfComparison;i++){
        cout<<indexes[x--];
        cout<<"" > ""<<indexes[x--]<<endl;
      }
      for(int i=0;i<numOfComparison;i++){
        cin>>comparisonRes[i];
        if (comparisonRes[i]==-1){
          return;
        }
      }
      sorted = 1;
      for(int i=0;i<numOfComparison;i++){
        if (comparisonRes[i]==0){
          sorted = 0;
          temp = indexes[i*2];
          indexes[n-i*2-1] = indexes[n-(i*2+2)];
          indexes[n-(i*2+2)] = temp;
        }
      }
    }
    
    trial++;
    
  }
  cout<<""a "";
  for (int i=0;i<n;i++){
    cout<<indexes[i]<<"" "";
  }
  
}
","/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:25:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   25 |           return;
      |           ^~~~~~
/code/Main.cpp:47:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   47 |           return;
      |           ^~~~~~
/code/Main.cpp:5:13: warning: unused variable ‘ind’ [-Wunused-variable]
    5 |   int n, m, ind, trial = 0,temp, x=0;
      |             ^~~
/code/Main.cpp:10:18: warning: unused variable ‘indexesP’ [-Wunused-variable]
   10 |   int indexes[n],indexesP[n],comparisonRes[numOfComparison];
      |                  ^~~~~~~~
",CERR,C++17,2022-07-30 15:16:28.969386,0
282,duckduckdoo,1,1005,"#include <iostream>
using namespace std;
  
// Function to print an array 
void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        cout << arr[i] << "" "";
    cout << endl;
}
  
// Driver code
int main()
{
  int arrSize, numQueries;
  cin>>arrSize>>numQueries;
  int arr[arrSize];
  for (int i = 0; i < arrSize; i++)
    arr[i] = i;
  
  for (int i = 0; i < arrSize - 1; i++) {
    for (int j = 0; j < arrSize - i - 1; j++) {
      cout<<""q 1""<<endl;
      cout<<arr[j]<<"" > ""<<arr[j+1]<<endl;
      int x;
      cin>>x;
      if (x == 1) {
        swap(arr[j], arr[j + 1]);
      }
    }
    
    cout<<""a "";
    printArray(arr, arrSize);
  }
  int correct;
  cin>>correct;
  return 0;
}","WA on case 0, test 2","",C++17,2022-07-30 15:17:14.468969,0
283,SoloGuy,1,1007,"from collections import OrderedDict

n, q = list(map(int, input().strip().split(' ')))
fence = OrderedDict()
fence[(1, n)] = 'white'

for i in range(q):

    query = input().strip().split(' ')

    if query[0] == 'q':
        _, i = query
        i = int(i)
        
        for (a,b), c in fence.items():
            if a <= i <= b:
                col = c

        print(col)
    else:
        _, lo, hi, col = query
        lo, hi = int(lo), int(hi)

        if (lo, hi) in fence:
            del fence[(lo, hi)]
            fence[(lo, hi)] = col
        else:
            fence = {(a, b): c for (a,b), c in fence.items() if not (lo <= a and b <= hi )}
            fence[(lo, hi)] = col","Failed on case 3, test 0",TLE,Python3,2022-07-30 15:17:16.399669,40
311,duckduckdoo,1,1005,"nums = list(map(int, input().split()))

for i in range(0,n):
    arr[i] = i;

for k in range(0,nums[0]-1):
    for p in range(0, nums[0]-k-1):
        print(""q 1"");
        print(arr[p] + "" > "" + arr[p+1])
        ww = int(input())

        if ww == -1:
            exit();
        elif ww == 1: 
            swap(arr[p],arr[p+1])
    
print(""a ""+arr)
cor = int(input());
print(cor)","WA on case 0, test 0",WA,Python3,2022-07-30 15:34:12.439919,0
312,YugoslaviaLover1992,1,1006,"#include<iostream>
#include<iomanip>
using namespace std;
int main(){
int s;
cin>>s;
auto w=setw(s+1);
cout<<w<<"">\n""<<w<<""|\n""<<w<<"".\n"";
int j;
for(int i=1;i<s;i++){
cout<<setw(s-i)<<""/"";
for(j=0;j<i;j++)
cout<<char(65+j);
for(j=i-2;j>=0;j--)
cout<<char(65+j);
cout<<""\\\n"";}
return 0;}","",AC,C++17,2022-07-30 15:34:23.883739,50
285,TeamJin,1,1005,"def compAnswer():
    return int(input())


def query(num1, num2):
    print(""q 1"")
    print(str(num1) + "" < "" + str(num2))
    return compAnswer()


#--------------GeekForGeeks COPY--------------------------------------------------------
def partition(l, r, nums):
    # Last element will be the pivot and the first element the pointer
    pivot = nums[r]
    ptr = l

    for i in range(l, r):
        #nums[i] <= pivot
        if query(nums[i], pivot):
            # Swapping values smaller than the pivot to the front
            nums[i], nums[ptr] = nums[ptr], nums[i]
            ptr += 1
    # Finally swapping the last element with the pointer indexed number
    nums[ptr], nums[r] = nums[r], nums[ptr]
    return ptr
 
# With quicksort() function, we will be utilizing the above code to obtain the pointer
# at which the left values are all smaller than the number at pointer index and vice versa
# for the right values.
 
 
def quicksort(l, r, nums):
    if len(nums) == 1:  # Terminating Condition for recursion. VERY IMPORTANT!
       return nums
    if l < r:
        pi = partition(l, r, nums)
        quicksort(l, pi-1, nums)  # Recursively sorting the left values
        quicksort(pi+1, r, nums)  # Recursively sorting the right values
    return nums
#--------------------------------------------------------------

nums = list(map(int, input().split()))
n = nums[0]
m = nums[1]

aLst = list(range(n))



def printAnswer():
    retSt = ""a""
    for i in range(len(aLst)):
        retSt += "" "" + str(aLst[i])
    print(retSt)


quicksort(0, len(aLst) - 1, aLst)
printAnswer()","WA on case 1, test 1","",Python3,2022-07-30 15:17:35.766107,30
286,SoloGuy,1,1007,"from collections import OrderedDict

n, q = list(map(int, input().strip().split(' ')))
fence = OrderedDict()
fence[(1, n)] = 'white'

for i in range(q):

    query = input().strip().split(' ')

    if query[0] == 'q':
        _, i = query
        i = int(i)
        
        for (a,b), c in reversed(fence.items()):
            if a <= i <= b:
                col = c
                break

        print(col)
    else:
        _, lo, hi, col = query
        lo, hi = int(lo), int(hi)

        if (lo, hi) in fence:
            del fence[(lo, hi)]
            fence[(lo, hi)] = col
        else:
            fence = {(a, b): c for (a,b), c in fence.items() if not (lo <= a and b <= hi )}
            fence[(lo, hi)] = col","Failed on case 3, test 0",TLE,Python3,2022-07-30 15:18:40.939159,40
287,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

int main(){
    //initialize map and iterator
    unordered_map<int, string> fences;

    //read the number of fences and queries
    int numFences;
    int numQueries;
    cin >> numFences >> numQueries;

    //initialize all the variables needed
    char type;
    int start, end, key;
    string color;

    //take the input in a loop
    for(int i = numQueries; i != 0; i--){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            cin >> start >> end;
            cin >> color;
            //modify the fences' colors
            for(int j = start; j <= end; j++){
                fences[j-1] = color;
            }
        }
        else{
            //take in 1 input
            cin >> key;
            try{
                cout << fences.at(key-1) << endl;
            }
            catch (...){
                cout << ""white"" << endl;
            }
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 15:19:18.048054,40
288,coffeepls,1,1007,"n, q = input().split()

n = int(n)
q = int(q)
l = ['white']*n
i = 0
ans = []
while (i<q):
    query = input().split()
    i += 1
    if query[0]=='q':
        ans.append(l[int(query[1])-1])
    else:
        a = int(query[1])-1
        b = int(query[2])
        for j in range(a, b):
            l[j] = query[3]
for i in range(len(ans)):
    print(ans[i])","Failed on case 2, test 0",TLE,Python3,2022-07-30 15:20:14.260149,20
289,YugoslaviaLover1992,1,1009,"#include <iostream>

using namespace std;

int main() {
  for (int frame = 0; frame < 60; frame++) {
    for (int i = 0; i < 24; i++) {
      for (int j = 0; j < 80; j++) {
        cout << ""-"";
      }
      cout << ""\n"";
    }
    cout << ""\n"";
  }

  for (int mung = 0; mung < 320; mung++) {
    for (int i = 0; i < 24; i++) {
      for (int j = 0; j < 80; j++) {
        if (j == mung%80 && i == 12) {
          cout << ""ඞ"";
        } else {
          cout << ""-"";
        }
      }
      cout << ""\n"";
    }
    cout << ""\n"";
  }
}
",Only your latest submission will be checked,AC,C++17,2022-07-30 15:22:08.934103,10
313,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

int main(){
    //initialize map and iterator
    unordered_map<long, string> fences;

    //read the number of fences and queries
    long numFences;
    long numQueries;
    cin >> numFences >> numQueries;

    //initialize all the variables needed
    char type;
    long start, end, key;
    string color;

    //take the input in a loop
    for(long i = numQueries; i != 0; i--){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            cin >> start >> end >> color;
            //modify the fences' colors
            for(long j = start; j <= end; j++){
                fences[j-1] = color;
            }
        }
        else{
            //take in 1 input
            cin >> key;
            try{
                cout << fences.at(key-1) << endl;
            }
            catch (...){
                cout << ""white"" << endl;
            }
        }
    }
}","Failed on case 3, test 0",TLE,C++17,2022-07-30 15:35:13.559214,40
290,YugoslaviaLover1992,1,1005,"#include <iostream>
#include<cmath>

using namespace std;


class BTNode {

public:

    int element;
	BTNode* left;
	BTNode* right;

    BTNode(int element) {
        this->element = element;
        left = NULL;
        right = NULL;
    }

    // Boolean helper functions
    bool isLeaf() const {
        return (left == NULL && right == NULL);
    }


    bool hasLeft() const {
        return (left != NULL);
    }

    bool hasRight() const {
        return (right != NULL);
    }
}; // end of BSTNode


class BT {

public:

    BTNode* root; 
    unsigned int elementCount;           
 

	// Parameterized constructor
    BT(int element) {
		root = new BTNode(element);
		elementCount = 1;	
	}       

	// Description: Helper function to free elements from the BST
	//				Post-order traversal to remove elements
	void deleteElement(BTNode* current) {
  		if(current == NULL) {
			return;
		}
		else {
			deleteElement(current->left);
			deleteElement(current->right);
			delete current;
		}
	} // end of deleteElement

	// Destructor 
	~BT() {
		deleteElement(root);
		root = NULL;
		elementCount = 0;
    } // end of destructor                     
	
	
    // return -1 if inserted, otherwise, return the number at the node that is filled for another comparison call
    // child node: 1 for left child, 0 for right child
	int searchAndInsert(const int newElement, int searchValue, int childNode, BTNode* current) {
            int returnValue = -2;
        
            if (current == NULL) {
                return returnValue;
            }

			if (current->element == searchValue) {
                if (childNode == 1 && !current->hasLeft()) { // insert left child
                    BTNode* newNode = new BTNode(newElement);
                    current->left = newNode;
                    elementCount++;
                    returnValue = -1;
                } else if (childNode == 0 && !current->hasRight()) { // insert right child
                    BTNode* newNode = new BTNode(newElement);
                    current->right = newNode;
                    elementCount++;
                    returnValue = -1;
                } else { // node is already filled
                    if (childNode == 1) { // return left child value
                        returnValue = current->left->element;
                    } else { // return right child value
                        returnValue = current->right->element;                        
                    }
                }
            } else {
                // cout << ""left\n"";
                 returnValue = searchAndInsert(newElement, searchValue, childNode, current->left);
                 if (returnValue != -1) {
                    // cout << ""right\n"";
                    returnValue = searchAndInsert(newElement, searchValue, childNode, current->right);
                 }
            }

            return returnValue;
		}




	void traverseInOrder(void visit(const int), BTNode* current)const {
		
		// base case
		if(current == NULL)
			return;

		else {
			traverseInOrder(visit, current->left);
			visit(current->element);
			traverseInOrder(visit, current->right);
		}
	}
}; // end of BST


void display(int number) {
    cout << "" "" << number;
}

int main(int argc, char **argv) {

    // get n -> number of elements in the list
    // get m -> number of parallel instructions
    int n, m;
    cin >> n >> m;  
     
    // create empty list and fill it with indicies
    int indices[n+1];
    for (int i = 0; i <= n; i++) {
        indices[i] = i;
    }

    int index = 1;
    // create tree
    BT* tree = new BT(0);
    cout << ""q 1"" << endl<< flush; // one query
    cout << indices[0] << "" < "" << indices[index] << ""\n""<< flush;
    int validate;
    cin >> validate;
    if (validate == 1) { // true, insert right
        tree->searchAndInsert(index, 0, 0, tree->root);

    } else { // false, insert left
        tree->searchAndInsert(index, 0, 1, tree->root);
    }


    for (int currentIndex = 2; currentIndex < n; currentIndex++) {
        int valid;
        int compareIndex = index;
        while (valid != -1) {
            cout << ""q 1"" << endl<< flush; // one query
            cout << indices[compareIndex] << "" < "" << indices[currentIndex] << ""\n""<< flush;
            cin >> validate;
            if (validate == 1) { // true, insert right
                valid = tree->searchAndInsert(currentIndex, compareIndex, 0, tree->root);
            } else { // false, insert left
                valid = tree->searchAndInsert(currentIndex, compareIndex, 1, tree->root);
            }
            compareIndex = valid;
        }
        index++;
    }

    // output answer
    cout << ""a"";
    tree->traverseInOrder(display, tree->root);

    delete tree;
    

    return 0;  
}
","WA on case 0, test 0",WA,C++17,2022-07-30 15:22:18.394641,0
291,duckduckdoo,1,1005,"#include <iostream>
using namespace std;
  
// Function to print an array 
void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        cout << arr[i] << "" "";
    cout << endl;
}
  
// Driver code
int main()
{
  int arrSize, numQueries;
  cin>>arrSize>>numQueries;
  int arr[arrSize];
  for (int i = 0; i < arrSize; i++)
    arr[i] = i;
  
  for (int i = 0; i < arrSize - 1; i++) {
    for (int j = 0; j < arrSize - i - 1; j++) {
      cout<<""q 1""<<endl;
      cout<<arr[j]<<"" > ""<<arr[j+1]<<endl;
      int x;
      cin>>x;
      if (x == 1) {
        swap(arr[j], arr[j + 1]);
      }
      else if (x == -1)
        return 0;
    }
    
    cout<<""a "";
    printArray(arr, arrSize);
  }
  int correct;
  cin>>correct;
  return 0;
}",,judging,C++17,2022-07-30 15:22:57.626501,0
292,duckduckdoo,1,1005,"n = int(input())
nums = list(map(int, input().split()))

print(1)
","WA on case 0, test 0",WA,Python3,2022-07-30 15:24:23.256948,0
293,duckduckdoo,1,1005,"#include <iostream>
using namespace std;
  
// Function to print an array 
void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        cout << arr[i] << "" "";
    cout << endl;
}
  
// Driver code
int main()
{
  int arrSize, numQueries;
  cin>>arrSize>>numQueries;
  int arr[arrSize];
  for (int i = 0; i < arrSize; i++)
    arr[i] = i;
  
  for (int i = 0; i < arrSize - 1; i++) {
    for (int j = 0; j < arrSize - i - 1; j++) {
      cout<<""q 1""<<endl;
      cout<<arr[j]<<"" > ""<<arr[j+1]<<endl;
      int x;
      cin>>x;
      if (x == 1) {
        swap(arr[j], arr[j + 1]);
      }
      else if (x == -1)
        return 0;
    }
    
    cout<<""a "";
    printArray(arr, arrSize);
  }
  int correct;
  cin>>correct;
  return 0;
}","WA on case 0, test 1","",C++17,2022-07-30 15:24:30.509941,0
294,duckduckdoo,1,1005,"#include <iostream>
using namespace std;
  
// Function to print an array 
void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        cout << arr[i] << "" "";
    cout << endl;
}
  
// Driver code
int main()
{
  int arrSize, numQueries;
  cin>>arrSize>>numQueries;
  int arr[arrSize];
  for (int i = 0; i < arrSize; i++)
    arr[i] = i;
  
  for (int i = 0; i < arrSize - 1; i++) {
    for (int j = 0; j < arrSize - i - 1; j++) {
      cout<<""q 1""<<endl;
      cout<<arr[j]<<"" > ""<<arr[j+1]<<endl;
      int x;
      cin>>x;
      if (x == 1) {
        swap(arr[j], arr[j + 1]);
      }
      else if (x == -1)
        return 0;
    }
    
    cout<<""a "";
    printArray(arr, arrSize);
  }
  int correct;
  cin>>correct;
  return 0;
}","WA on case 0, test 1","",C++23,2022-07-30 15:25:29.058173,0
295,FuduBoys,1,1009,"nums = list(map(int, input().split()))
planks = {}

for i in range(nums[1]):
    query = input().split()
    if query[0] == 'p':
        for j in range(int(query[1]) - 1, int(query[2])):
            planks[j] = query[3]
    else:
        if (int(query[1]) - 1) not in planks:
            print('white')
        else:
            print(planks[int(query[1]) - 1])
","/code/Main.cpp:11:19: warning: character constant too long for its type
   11 |             print('white')
      |                   ^~~~~~~
/code/Main.cpp:1:1: error: ‘nums’ does not name a type
    1 | nums = list(map(int, input().split()))
      | ^~~~
/code/Main.cpp:4:1: error: expected unqualified-id before ‘for’
    4 | for i in range(nums[1]):
      | ^~~
",CERR,C++17,2022-07-30 15:25:47.522008,0
296,FuduBoys,1,1008,"# Import random module to generate random numbers
import random

# Take input from user
input_string = input('Enter a string to colorify: ')

# Attributing numbers (0-10) to ANSI escape colour codes
random_color_dict = {
    0 : '\u001b[31;1m', # Bright Red
    1 : '\u001b[32;1m', # Bright Green
    2 : '\u001b[34;1m', # Bright Blue
    3 : '\u001b[35;1m', # Bright Magenta
    4 : '\u001b[36;1m', # Bright Cyan
    5 : '\u001b[37;1m', # Bright White
    6 : '\u001b[41m', # Background Red
    7 : '\u001b[42m', # Background Green
    8 : '\u001b[44m', # Background Blue
    9 : '\u001b[45m', # Background Magenta
    10 : '\u001b[46m', # Background Cyan
}

# String to reset colour/background to default
reset = '\u001b[0m'

# Iterating through string and adding a randomnly generated colour for each character
coloured_char_list = [random_color_dict[random.randint(0, 10)] + char + reset for char in input_string]

# Joining and printing list into string and reseting colour to default
print(''.join(coloured_char_list))
",Only your latest submission will be checked,AC,Python3,2022-07-30 15:27:12.812876,10
327,SoloGuy,1,1007,"import bisect

n, q = list(map(int, input().strip().split(' ')))
boundaries = [1]
colors = {1 : 'white'}

for i in range(q):

    query = input().strip().split(' ')

    if query[0] == 'q':
        _, i = query
        i = int(i)
        
        a = max(0, bisect.bisect(boundaries, i)-1)
        print(colors[boundaries[a]])

        
    else:
        _, lo, hi, col = query
        lo, hi = int(lo), int(hi)

        lb = max(0, bisect.bisect_left(boundaries, lo))
        rb = max(0, bisect.bisect_right(boundaries, hi+1))

        if rb == lb:
            colors[hi+1] = colors[boundaries[rb-1]]
            colors[lo] = col
            boundaries.insert(rb, hi+1)
            boundaries.insert(lb, lo)
        else:
            temp = boundaries[:lb] + [lo] + [hi+1] + boundaries[rb:]
            colors[hi+1] = colors[boundaries[rb-1]]
            colors[lo] = col
            boundaries = temp

        

        ","Failed on case 4, test 1",TLE,Python3,2022-07-30 15:47:08.003331,60
297,teamAverage,1,1005,"using namespace std;
#include <iostream>

int main() {
  int n,nRes, m, ind, trial = 0,temp, x=0;
  int numOfComparison ;
  cin >> n;
  cin >> m;
  numOfComparison = n/2;
  int indexes[n],indexesP[n],comparisonRes[numOfComparison];
  bool sorted = 0;
  for (int i = 0; i < n; i++) {
    indexes[i] = i;
  }
  while (!sorted&&trial<m) {
    if(trial%2 == 0){
      x=0;
      cout<<""q ""<<numOfComparison;
      for(int i=0;i<numOfComparison;i++){
        cout<<indexes[x++];
        cout<<"" < ""<<indexes[x++]<<endl;
      }
      for(int i=0;i<numOfComparison;i++){
        cin>>comparisonRes[i];
        if (comparisonRes[i]==-1){
          return;
        }
      }
      sorted = 1;
      for(int i=0;i<numOfComparison;i++){
        if (comparisonRes[i]==0){
          sorted = 0;
          temp = indexes[i*2];
          indexes[i*2] = indexes[i*2+1];
          indexes[i*2+1] = temp;
        }
      }
    }
    else{
      x=n;
      for(int i=numOfComparison-1;i>=0;i--){
        cout<<indexes[x--];
        cout<<"" > ""<<indexes[x--]<<endl;
      }
      for(int i=numOfComparison-1;i>=0;i--){
        cin>>comparisonRes[i];
        if (comparisonRes[i]==-1){
          return;
        }
      }
      sorted = 1;
      for(int i=numOfComparison-1;i>=0;i--){
        if (comparisonRes[i]==0){
          sorted = 0;
          temp = indexes[];
          indexes[n-i*2-1] = indexes[n-(i*2+2)];
          indexes[n-(i*2+2)] = temp;
        }
      }
    }
    
    trial++;
    
  }
  cout<<""a "";
  for (int i=0;i<n;i++){
    cout<<indexes[i]<<"" "";
  }
  cout<<endl;
  cin>>nRes;
  return;
}
","/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:26:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   26 |           return;
      |           ^~~~~~
/code/Main.cpp:48:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   48 |           return;
      |           ^~~~~~
/code/Main.cpp:55:26: error: expected primary-expression before ‘]’ token
   55 |           temp = indexes[];
      |                          ^
/code/Main.cpp:71:3: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   71 |   return;
      |   ^~~~~~
/code/Main.cpp:5:18: warning: unused variable ‘ind’ [-Wunused-variable]
    5 |   int n,nRes, m, ind, trial = 0,temp, x=0;
      |                  ^~~
/code/Main.cpp:10:18: warning: unused variable ‘indexesP’ [-Wunused-variable]
   10 |   int indexes[n],indexesP[n],comparisonRes[numOfComparison];
      |                  ^~~~~~~~
",CERR,C++17,2022-07-30 15:28:32.324643,0
298,YugoslaviaLover1992,1,1006,"#include <iostream>
#include <iomanip>

using namespace std;

int main(int argc,char **argv) {
int s;
cin>>s;
auto w=setw(s+1);
cout<<w<<"">\n""<<w<<""|\n""<<w<<"".\n"";
int j;
for(int i=1;i<s;i++){
cout<<setw(s-i)<<""/"";
for(j=0;j<i;j++)
cout<<char(65+j);
for(j=i-2;j>=0;j--)
cout<<char(65+j);
cout<<""\\\n"";}
return 0;
}","",AC,C++17,2022-07-30 15:30:22.427492,50
299,YugoslaviaLover1992,1,1006,"#include <iostream>
#include <iomanip>
using namespace std;
int main(int argc,char **argv) {
int s;
cin>>s;
auto w=setw(s+1);
cout<<w<<"">\n""<<w<<""|\n""<<w<<"".\n"";
int j;
for(int i=1;i<s;i++){
cout<<setw(s-i)<<""/"";
for(j=0;j<i;j++)
cout<<char(65+j);
for(j=i-2;j>=0;j--)
cout<<char(65+j);
cout<<""\\\n"";}
return 0;
}","",AC,C++17,2022-07-30 15:30:55.923421,50
328,duckduckdoo,1,1005,"nums = list(map(int, input().split()))

arr = [0]*nums[0];
for i in range(0,nums[0]):
    arr[i] = i;

for k in range(0,nums[0]-1):
    for p in range(0, nums[0]-k-1):
        print(""q 1"");
        print(str(arr[p]) + "" > "" + str(arr[p+1]))
        ww = int(input())   

        if ww == -1:
            exit();
        elif ww == 1: 
            arr[p], arr[p+1] = arr[p+1], arr[p]
    
print(""a ""+ str(arr))
cor = int(input());
print(cor)","WA on case 0, test 0","",Python3,2022-07-30 15:47:14.572023,0
329,duckduckdoo,1,1005,"nums = list(map(int, input().split()))

arr = [0]*nums[0];
for i in range(0,nums[0]):
    arr[i] = i;

for k in range(0,nums[0]-1):
    for p in range(0, nums[0]-k-1):
        print(""q 1"");
        print(str(arr[p]) + "" > "" + str(arr[p+1]))
        ww = int(input())   

        if ww == -1:
            exit();
        elif ww == 1: 
            arr[p], arr[p+1] = arr[p+1], arr[p]
    
print(""a ""+ str(arr))
cor = int(input());
print(cor)","WA on case 0, test 0","",Python3,2022-07-30 15:47:36.651449,0
339,HS,1,1009,"#include <vector>
#include <string>
#include <ctime>
#include <iostream>
#include <Windows.h>
#include <cstdlib>
using namespace std;

int SW = 50;
int SH = 15;

vector<string> script = {
	""I am a fish......"",
	""A lonely fish in a quiet terminal......"",
	""I will perish as soon as this Strange contest is over......"",
	""What am I worth......?"",
	""10 points? 20? Or, maybe......"",
	""It will be a dream if my short life is worth 100 points......"",
	""If I get 100 points, I will live the rest of my short life in happiness......."",
	"".......At least until my program is over......."",
	""Hey, friend..... Will you give me 100 points?"",
	""It's my only dream......"",
	""And it seems like my life is almost over......."",
	""This would be the end. Bye.........""
};

int main()
{
	int loc_x = rand() % SW + 1;
	int loc_y = rand() % SH + 1+3;

	srand(time(NULL));
	int loop_ind = 0;
	while (true) {
		cout << endl;
		string s = script[(loop_ind / 7) % script.size()];
		cout << ""                 "" << s;
		for (int i = 0; i < loc_y; i++) {
			cout << ""\n"";
		}
		for (int j = 0; j < loc_x; j++) {
			cout << "" "";
		}
		cout << ""<°)))><"" << endl;
		for (int i = 0; i < SH - loc_y - 1; i++) {
			cout << endl;
		}

		loc_x += (rand() % 10 - 5)/4;
		loc_y += (rand() % 10 - 5)/4;
		loop_ind++;
		Sleep(1000);
	}

	return 0;
}
","/code/Main.cpp:5:10: fatal error: Windows.h: No such file or directory
    5 | #include <Windows.h>
      |          ^~~~~~~~~~~
compilation terminated.
",CERR,C++17,2022-07-30 15:52:45.569524,0
340,SoloGuy,1,1008,"
# Quite literally just says hello with your name as you input your name

while True:
    name = input(""Please put your name here: "")
    print(""Hi "" + name + ""!"")
",Only your latest submission will be checked,AC,Python3,2022-07-30 15:52:48.46224,10
341,YugoslaviaLover1992,1,1006,"  #include<iostream>
  #include<iomanip>
  using namespace std;
  int main(){
  int s;
  cin>>s;
  auto w=setw(s+1);
  cout<<w<<"">\n""<<w<<""|\n""<<w<<"".\n"";
  int j;
  for(int i=1;i<s;i++){
  cout<<setw(s-i)<<""/"";
  for(j=0;j<i;j++)
  cout<<char(65+j);
  for(j=i-2;j>=0;j--)
  cout<<char(65+j);
  cout<<""\\\n"";}
  return 0;}","",AC,C++17,2022-07-30 15:52:49.860946,50
300,teamAverage,1,1005,"using namespace std;
#include <iostream>

int main() {
  int n,nRes, m, ind, trial = 0,temp, x=0;
  int numOfComparison ;
  cin >> n;
  cin >> m;
  numOfComparison = n/2;
  int indexes[n],indexesP[n],comparisonRes[numOfComparison];
  bool sorted = 0;
  for (int i = 0; i < n; i++) {
    indexes[i] = i;
  }
  while (!sorted&&trial<m) {
    if(trial%2 == 0){
      x=0;
      cout<<""q ""<<numOfComparison;
      for(int i=0;i<numOfComparison;i++){
        cout<<indexes[x++];
        cout<<"" < ""<<indexes[x++]<<endl;
      }
      for(int i=0;i<numOfComparison;i++){
        cin>>comparisonRes[i];
        if (comparisonRes[i]==-1){
          return;
        }
      }
      sorted = 1;
      for(int i=0;i<numOfComparison;i++){
        if (comparisonRes[i]==0){
          sorted = 0;
          temp = indexes[i*2];
          indexes[i*2] = indexes[i*2+1];
          indexes[i*2+1] = temp;
        }
      }
    }
    else{
      x=n;
      for(int i=numOfComparison-1;i>=0;i--){
        cout<<indexes[x--];
        cout<<"" > ""<<indexes[x--]<<endl;
      }
      for(int i=numOfComparison-1;i>=0;i--){
        cin>>comparisonRes[i];
        if (comparisonRes[i]==-1){
          return;
        }
      }
      x=n
      sorted = 1;
      for(int i=numOfComparison-1;i>=0;i--){
        if (comparisonRes[i]==0){
          sorted = 0;
          temp = indexes[n];
          indexes[n] = indexes[n-1];
          indexes[n-1] = temp;
          n=n-2;
        }
      }
    }
    
    trial++;
    
  }
  cout<<""a "";
  for (int i=0;i<n;i++){
    cout<<indexes[i]<<"" "";
  }
  cout<<endl;
  cin>>nRes;
  return;
}
","/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:26:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   26 |           return;
      |           ^~~~~~
/code/Main.cpp:48:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   48 |           return;
      |           ^~~~~~
/code/Main.cpp:51:10: error: expected ‘;’ before ‘sorted’
   51 |       x=n
      |          ^
      |          ;
   52 |       sorted = 1;
      |       ~~~~~~
/code/Main.cpp:73:3: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   73 |   return;
      |   ^~~~~~
/code/Main.cpp:5:18: warning: unused variable ‘ind’ [-Wunused-variable]
    5 |   int n,nRes, m, ind, trial = 0,temp, x=0;
      |                  ^~~
/code/Main.cpp:10:18: warning: unused variable ‘indexesP’ [-Wunused-variable]
   10 |   int indexes[n],indexesP[n],comparisonRes[numOfComparison];
      |                  ^~~~~~~~
",CERR,C++17,2022-07-30 15:31:03.797709,0
301,duckduckdoo,1,1005,"n = int(input())
nums = list(map(int, input().split()))

for i in range(0,n):
    arr[i] = i;

for k in range(0,n-1):
    for p in range(0, n-k-1):
        print(""q 1"");
        print(arr[p] + "" > "" + arr[p+1])
        ww = int(input())

        if ww == -1:
            exit();
        elif ww == 1: 
            swap(arr[p],arr[p+1])
    
print(""a ""+arr)
cor = int(input());
print(cor)","WA on case 0, test 0",WA,Python3,2022-07-30 15:31:05.004318,0
302,teamAverage,1,1005,"using namespace std;
#include <iostream>

int main() {
  int n,nRes, m, ind, trial = 0,temp, x=0;
  int numOfComparison ;
  cin >> n;
  cin >> m;
  numOfComparison = n/2;
  int indexes[n],indexesP[n],comparisonRes[numOfComparison];
  bool sorted = 0;
  for (int i = 0; i < n; i++) {
    indexes[i] = i;
  }
  while (!sorted&&trial<m) {
    if(trial%2 == 0){
      x=0;
      cout<<""q ""<<numOfComparison;
      for(int i=0;i<numOfComparison;i++){
        cout<<indexes[x++];
        cout<<"" < ""<<indexes[x++]<<endl;
      }
      for(int i=0;i<numOfComparison;i++){
        cin>>comparisonRes[i];
        if (comparisonRes[i]==-1){
          return;
        }
      }
      sorted = 1;
      for(int i=0;i<numOfComparison;i++){
        if (comparisonRes[i]==0){
          sorted = 0;
          temp = indexes[i*2];
          indexes[i*2] = indexes[i*2+1];
          indexes[i*2+1] = temp;
        }
      }
    }
    else{
      x=n;
      for(int i=numOfComparison-1;i>=0;i--){
        cout<<indexes[x--];
        cout<<"" > ""<<indexes[x--]<<endl;
      }
      for(int i=numOfComparison-1;i>=0;i--){
        cin>>comparisonRes[i];
        if (comparisonRes[i]==-1){
          return;
        }
      }
      x=n;
      sorted = 1;
      for(int i=numOfComparison-1;i>=0;i--){
        if (comparisonRes[i]==0){
          sorted = 0;
          temp = indexes[n];
          indexes[n] = indexes[n-1];
          indexes[n-1] = temp;
          n=n-2;
        }
      }
    }
    
    trial++;
    
  }
  cout<<""a "";
  for (int i=0;i<n;i++){
    cout<<indexes[i]<<"" "";
  }
  cout<<endl;
  cin>>nRes;
  return;
}","/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:26:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   26 |           return;
      |           ^~~~~~
/code/Main.cpp:48:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   48 |           return;
      |           ^~~~~~
/code/Main.cpp:73:3: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   73 |   return;
      |   ^~~~~~
/code/Main.cpp:5:18: warning: unused variable ‘ind’ [-Wunused-variable]
    5 |   int n,nRes, m, ind, trial = 0,temp, x=0;
      |                  ^~~
/code/Main.cpp:10:18: warning: unused variable ‘indexesP’ [-Wunused-variable]
   10 |   int indexes[n],indexesP[n],comparisonRes[numOfComparison];
      |                  ^~~~~~~~
",CERR,C++17,2022-07-30 15:31:22.853614,0
303,TeamJin,1,1005,"import random

def compAnswer():
    return int(input())


def query(num1, num2):
    print(""q 1"")
    print(str(num1) + "" < "" + str(num2))
    return compAnswer()


#--------------Modified code from GeekForGeeks--------------------------------------------------------
# https://www.geeksforgeeks.org/python-program-for-quicksort/

def partition(l, r, nums):
    # Last element will be the pivot and the first element the pointer
    pivot = nums[r]
    ptr = l

    for i in range(l, r):
        #nums[i] <= pivot
        if query(nums[i], pivot):
            # Swapping values smaller than the pivot to the front
            nums[i], nums[ptr] = nums[ptr], nums[i]
            ptr += 1
    # Finally swapping the last element with the pointer indexed number
    nums[ptr], nums[r] = nums[r], nums[ptr]
    return ptr
 
# With quicksort() function, we will be utilizing the above code to obtain the pointer
# at which the left values are all smaller than the number at pointer index and vice versa
# for the right values.
 
 
def quicksort(l, r, nums):
    if len(nums) == 1:  # Terminating Condition for recursion. VERY IMPORTANT!
       return nums
    if l < r:
        pi = partition(l, r, nums)
        quicksort(l, pi-1, nums)  # Recursively sorting the left values
        quicksort(pi+1, r, nums)  # Recursively sorting the right values
    return nums
#-------------------------------------------------------------------------------------------------------

nums = list(map(int, input().split()))
n = nums[0]
m = nums[1]

aLst = random.shuffle(list(range(n)))



def printAnswer():
    retSt = ""a""
    for i in range(len(aLst)):
        retSt += "" "" + str(aLst[i])
    print(retSt)


quicksort(0, len(aLst) - 1, aLst)
printAnswer()","WA on case 0, test 0",WA,Python3,2022-07-30 15:31:42.313227,0
304,teamAverage,1,1007,"#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

int main(){
    //initialize map and iterator
    unordered_map<short, string> fences;

    //read the number of fences and queries
    short numFences;
    short numQueries;
    cin >> numFences >> numQueries;

    //initialize all the variables needed
    char type;
    short start, end, key;
    string color;

    //take the input in a loop
    for(short i = numQueries; i != 0; i--){
        //take first char input (q or p)
        cin >> type;
        if(type == 'p'){
            //take in 3 inputs
            int start, end;
            cin >> start >> end >> color;
            //modify the fences' colors
            for(short j = start; j <= end; j++){
                fences[j-1] = color;
            }
        }
        else{
            //take in 1 input
            cin >> key;
            try{
                cout << fences.at(key-1) << endl;
            }
            catch (...){
                cout << ""white"" << endl;
            }
        }
    }
}","WA on case 3, test 0",WA,C++17,2022-07-30 15:32:25.096789,40
342,duckduckdoo,1,1007,"#include <iostream>
#include <unordered_map>
#include <utility>
using namespace std;

struct hash_pair {
    template <class T1, class T2>
    size_t operator()(const pair<T1, T2>& p) const
    {
        auto hash1 = hash<T1>{}(p.first);
        auto hash2 = hash<T2>{}(p.second);
 
        if (hash1 != hash2) {
            return hash1 ^ hash2;             
        }
         
        // If hash1 == hash2, their XOR is zero.
          return hash1;
    }
};

int main() {
  int numFences, numQueries;
  cin>>numFences>>numQueries;
  unordered_map< pair<int,int>, string, hash_pair> f;
  for (int i = 0; i < numQueries; i++) {
    char command;
    cin>>command;
    if (command == 'p') {
      int start, end;
      string color;
      cin>>start>>end>>color;
      f[pair<int,int>(start,end)] = color;
      // for (int i = start-1; i < end; i++) {
      //   f[i] = color;
      // }
    }
    else if (command == 'q') {
      int fenceNum;
      cin>>fenceNum;
      fenceNum--;
      string color = ""white"";
      for (auto& it: f) {
          if((it.first).first <= fenceNum && (it.first).second >= fenceNum)
            color = it.second;
      }
      cout<<color<<endl;
    }
  }
}
","WA on case 1, test 0",WA,C++17,2022-07-30 15:53:14.385099,0
305,TeamJin,1,1007,"import random

def compAnswer():
    return int(input())


def query(num1, num2):
    print(""q 1"")
    print(str(num1) + "" < "" + str(num2))
    return compAnswer()


#--------------Modified code from GeekForGeeks--------------------------------------------------------
# https://www.geeksforgeeks.org/python-program-for-quicksort/

def partition(l, r, nums):
    # Last element will be the pivot and the first element the pointer
    pivot = nums[r]
    ptr = l

    for i in range(l, r):
        #nums[i] <= pivot
        if query(nums[i], pivot):
            # Swapping values smaller than the pivot to the front
            nums[i], nums[ptr] = nums[ptr], nums[i]
            ptr += 1
    # Finally swapping the last element with the pointer indexed number
    nums[ptr], nums[r] = nums[r], nums[ptr]
    return ptr
 
# With quicksort() function, we will be utilizing the above code to obtain the pointer
# at which the left values are all smaller than the number at pointer index and vice versa
# for the right values.
 
 
def quicksort(l, r, nums):
    if len(nums) == 1:  # Terminating Condition for recursion. VERY IMPORTANT!
       return nums
    if l < r:
        pi = partition(l, r, nums)
        quicksort(l, pi-1, nums)  # Recursively sorting the left values
        quicksort(pi+1, r, nums)  # Recursively sorting the right values
    return nums
#-------------------------------------------------------------------------------------------------------

nums = list(map(int, input().split()))
n = nums[0]
m = nums[1]

aLst = random.shuffle(list(range(n)))



def printAnswer():
    retSt = ""a""
    for i in range(len(aLst)):
        retSt += "" "" + str(aLst[i])
    print(retSt)


quicksort(0, len(aLst) - 1, aLst)
printAnswer()","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 61, in <module>
    quicksort(0, len(aLst) - 1, aLst)
TypeError: object of type 'NoneType' has no len()
",ERR,Python3,2022-07-30 15:32:29.447246,0
306,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cout << unitbuf;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i < plank; i++){
        fences[i] = ""white"";
    }
    vector<string> out;
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.push_back(fences[n]);
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    for(const auto i: out){
        cout << i << endl;
        cout.flush();
    }
}","WA on case 1, test 0",WA,C++17,2022-07-30 15:32:32.832744,0
307,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cout << unitbuf;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i < plank; i++){
        fences[i] = ""white"";
    }
    vector<string> out;
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.push_back(fences[n]);
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    for(const auto i: out){
        cout << i << endl;
        cout.flush();
    }
}","WA on case 1, test 0",WA,C++20,2022-07-30 15:32:45.557758,0
308,FuduBoys,1,1006,"r = gets.chomp.to_i

puts s = "" ""*(r-3)
puts [s + ""  >"", s+ ""  |"",s + ""  .""]
s.concat("" "")
c1 = c = k = 0
for i in 1..r-1
 c=r-i-1
  print(s)
  print(""/"")
  while k!=((2*i)-1)
    if c<=r-2
      print((k+65).chr)
      c+=1
    else
      c1+=1
      print((k-(2*c1)+65).chr)
    end
    k+= 1
  end
  c1 = c = k = 0
  print(""\\\n"")
  s = s.chop
end","Error with code 1:
/code/Main.rb:3:in `*': negative argument (ArgumentError)
	from /code/Main.rb:3:in `<main>'
",ERR,Ruby,2022-07-30 15:33:36.404853,0
309,TeamJin,1,1007,"#from datetime import datetime

nums = list(map(int, input().split()))
n = nums[0]
q = nums[1]


class node():
    def __init__(self, fir, sec, col):
        self.first = fir
        self.sec = sec
        self.col = col

nodeLst = []
#O(q)
for i in range(q):
    #print(""--------------------"")
    curLine =  input().split()
    #print(datetime.now())
    firstIndex = int(curLine[1]) - 1
    
    # p 2 4 black
    #O(1)
    if curLine[0] == ""p"":
        secondIndex = int(curLine[2]) - 1
        nodeLst.append(node(firstIndex, secondIndex, curLine[3]))

    #O(n)
    else:
        prBool = False
        #linear search
        for i in range(len(nodeLst)-1, -1, -1):
            if nodeLst[i].first <= firstIndex <= nodeLst[i].sec:
                print(nodeLst[i].col, flush=True)
                prBool = True
                break

        if not prBool:
            print(""white"", flush=True)

#O(n*q)

","Failed on case 3, test 0",TLE,Python3,2022-07-30 15:33:59.366455,40
310,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cout << unitbuf;
    cin >> plank >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i < plank; i++){
        fences[i] = ""white"";
    }
    vector<string> out;
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.push_back(fences[n]);
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start >> end >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    for(int i = 0; i<out.size(); i++){
        cout << out.at(i)<<endl;
    }
}","WA on case 1, test 0",WA,C++17,2022-07-30 15:34:11.344513,0
333,FuduBoys,1,1007,"#include <cstring>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
struct strut {

  int start, end;
  std::string color;
};

int main(int argc, char *argv[]) {

  int n, q;
  std::cin >> n >> q;
  std::vector<strut> vec;
  // std::cout << ""n is "" << n << ""q is "" << q << '\n';

  for (auto count = 0; count < q; count++) {
    // std::cout << ""running"" << count << ""time"" << '\n';
    std::string query_input = """";
    std::string retVAL;
    // std::cout << ""query string is "" << query_input << '\n';
    std::cin >> query_input;
    if (query_input == ""p"") {
      // std::stringstream s(query_input);
      // std::string temp1, color;
      int start, end;
      std::string color;
      // s >> temp1; // takes out the first p
      // s >> start;
      // s >> end;
      // s >> color;
      std::cin >> start;
      std::cin >> end;
      std::cin >> color;
      strut temp;
      temp.color = color;
      temp.end = end;
      temp.start = start;
      vec.push_back(temp);
      continue;
    } else {
      int number;
      std::cin >> number;
      // s >> temp; // throws away q
      // s >> number;
      for (auto &x : vec) {
        if (number >= x.start && number <= x.end) {
          retVAL = x.color;
        }
      }
      if (retVAL == """") {
        std::cout << ""white\n"";
      } else {
        std::cout << retVAL << '\n';
      }
    }
  }

  return 0;
}
","Failed on case 3, test 0",TLE,C++17,2022-07-30 15:50:53.774696,40
314,Albus,1,1009,"#include <stdio.h>

#define H 24
#define W 80

void draw(int intinputArray[])
{
    int rowcount = 0; // Counter for the rows of histogram
    int colcount = 0; // Counter for the columns of histogram
    int maxcount = 0; // Counter to find the maximum input
    int max = 0;      // Maximum input
    int revcount = 0; // Counter to make the inout array reversed
    for (maxcount = 0; maxcount < 80; maxcount++)
    {
        if (intinputArray[maxcount] > max)
        {
            max = intinputArray[maxcount];
        }
    }
    // For loop to reverse the input integers compared to maximum
    for (revcount = 0; revcount < 80; revcount++)
    {
        intinputArray[revcount] = max - intinputArray[revcount];
    }
    // For loop to draw the histogram
    for (colcount = 0; colcount < max; colcount++)
    {
        for (rowcount = 0; rowcount < 80; rowcount++)
        {
            if (intinputArray[rowcount] != 0)
            {
                printf("" "");
                intinputArray[rowcount] = intinputArray[rowcount] - 1;
            }
            else if (intinputArray[rowcount] == 0)
            {
                printf(""#"");
            }
        }
        printf(""\n"");
    }
}
int main(int argc, char const *argv[])
{
    int myArray[80];
    for (size_t a = 0; a < 80; a++)
    {
        myArray[a] = a*a/2 % 40;
    }

    int array[80];
    for (int i = 0; i < H; i++)
    {
        for (size_t l = 0; l < H-i; l++)
        {
            printf(""\n"");
        }
        
        
        for (int j = 0; j < W; j++)
        {
            array[j] = myArray[j];

            array[j] = array[j] - 24 + i;
            if (array[j] < 0)
                array[j] = 0;
        }
        draw(array);
        printf(""---------------------------------------------------------------------------------"");
    }
    return 0;
}
",Only your latest submission will be checked,AC,C++17,2022-07-30 15:35:43.796241,10
315,FuduBoys,1,1006,"r = gets.chomp.to_i

s = "" ""*(r-3)
print(s + ""  >\n"", s+ ""  |\n"",s + ""  .\n"")
s.concat("" "")
c1 = c = k = 0
for i in 1..r-1
 c=r-i-1
  print(s)
  print(""/"")
  while k!=((2*i)-1)
    if c<=r-2
      print((k+65).chr)
      c+=1
    else
      c1+=1
      print((k-(2*c1)+65).chr)
    end
    k+= 1
  end
  c1 = c = k = 0
  print(""\\\n"")
  s = s.chop
end","Error with code 1:
/code/Main.rb:3:in `*': negative argument (ArgumentError)
	from /code/Main.rb:3:in `<main>'
",ERR,Ruby,2022-07-30 15:35:44.984217,0
316,FuduBoys,1,1006,"puts `clear`
r = gets.chomp.to_i

s = "" ""*(r-3)
print(s + ""  >\n"", s+ ""  |\n"",s + ""  .\n"")
s.concat("" "")
c1 = c = k = 0
for i in 1..r-1
 c=r-i-1
  print(s)
  print(""/"")
  while k!=((2*i)-1)
    if c<=r-2
      print((k+65).chr)
      c+=1
    else
      c1+=1
      print((k-(2*c1)+65).chr)
    end
    k+= 1
  end
  c1 = c = k = 0
  print(""\\\n"")
  s = s.chop
end","Error with code 1:
TERM environment variable not set.
/code/Main.rb:4:in `*': negative argument (ArgumentError)
	from /code/Main.rb:4:in `<main>'
",ERR,Ruby,2022-07-30 15:37:47.982238,0
317,YugoslaviaLover1992,1,1005,"#include <iostream>
#include<cmath>

using namespace std;


class BTNode {

public:

    int element;
	BTNode* left;
	BTNode* right;

    BTNode(int element) {
        this->element = element;
        left = NULL;
        right = NULL;
    }

    // Boolean helper functions
    bool isLeaf() const {
        return (left == NULL && right == NULL);
    }


    bool hasLeft() const {
        return (left != NULL);
    }

    bool hasRight() const {
        return (right != NULL);
    }
}; // end of BSTNode


class BT {

public:

    BTNode* root; 
    unsigned int elementCount;           
 

	// Parameterized constructor
    BT(int element) {
		root = new BTNode(element);
		elementCount = 1;	
	}       

	// Description: Helper function to free elements from the BST
	//				Post-order traversal to remove elements
	void deleteElement(BTNode* current) {
  		if(current == NULL) {
			return;
		}
		else {
			deleteElement(current->left);
			deleteElement(current->right);
			delete current;
		}
	} // end of deleteElement

	// Destructor 
	~BT() {
		deleteElement(root);
		root = NULL;
		elementCount = 0;
    } // end of destructor                     
	
	
    // return -1 if inserted, otherwise, return the number at the node that is filled for another comparison call
    // child node: 1 for left child, 0 for right child
	int searchAndInsert(const int newElement, int searchValue, int childNode, BTNode* current) {
            int returnValue = -2;
        
            if (current == NULL) {
                return returnValue;
            }

			if (current->element == searchValue) {
                if (childNode == 1 && !current->hasLeft()) { // insert left child
                    BTNode* newNode = new BTNode(newElement);
                    current->left = newNode;
                    elementCount++;
                    returnValue = -1;
                } else if (childNode == 0 && !current->hasRight()) { // insert right child
                    BTNode* newNode = new BTNode(newElement);
                    current->right = newNode;
                    elementCount++;
                    returnValue = -1;
                } else { // node is already filled
                    if (childNode == 1) { // return left child value
                        returnValue = current->left->element;
                    } else { // return right child value
                        returnValue = current->right->element;                        
                    }
                }
            } else {
                // cout << ""left\n"";
                 returnValue = searchAndInsert(newElement, searchValue, childNode, current->left);
                 if (returnValue != -1) {
                    // cout << ""right\n"";
                    returnValue = searchAndInsert(newElement, searchValue, childNode, current->right);
                 }
            }

            return returnValue;
		}




	void traverseInOrder(void visit(const int), BTNode* current)const {
		
		// base case
		if(current == NULL)
			return;

		else {
			traverseInOrder(visit, current->left);
			visit(current->element);
			traverseInOrder(visit, current->right);
		}
	}
}; // end of BST


void display(int number) {
    cout << "" "" << number;
}

int main(int argc, char **argv) {

    // get n -> number of elements in the list
    // get m -> number of parallel instructions
    int n, m;
    cin >> n >> m;  
     
    // create empty list and fill it with indicies
    int indices[n+1];
    for (int i = 0; i <= n; i++) {
        indices[i] = i;
    }

    int index = 1;
    // create tree
    BT* tree = new BT(0);
    cout << ""q 1"" << endl<< flush; // one query
    cout << indices[0] << "" < "" << indices[index] << ""\n""<< flush;
    int validate;
    cin >> validate;
    if (validate == 1) { // true, insert right
        tree->searchAndInsert(index, 0, 0, tree->root);

    } else { // false, insert left
        tree->searchAndInsert(index, 0, 1, tree->root);
    }


    for (int currentIndex = 2; currentIndex < n; currentIndex++) {
        bool firstIteration = true;
        int valid;
        int compareIndex = index;
        while (valid != -1) {
            cout << ""q 1"" << endl<< flush; // one query
            cout << indices[compareIndex] << "" < "" << indices[currentIndex] << ""\n""<< flush;
            cin >> validate;

            if (firstIteration) {
                compareIndex = 0;
                firstIteration = false;
            }
            if (validate == 1) { // true, insert right
                valid = tree->searchAndInsert(currentIndex, compareIndex, 0, tree->root);
            } else { // false, insert left
                valid = tree->searchAndInsert(currentIndex, compareIndex, 1, tree->root);
            }
            compareIndex = valid;
        }
        index++;
        firstIteration = true;
    }

    // output answer
    cout << ""a"";
    tree->traverseInOrder(display, tree->root);

    delete tree;
    

    return 0;  
}
","WA on case 0, test 0",WA,C++17,2022-07-30 15:38:08.288664,0
359,untitled,1,1008,"#include <bits/stdc++.h>
using namespace std;

/*
    Problem Statement: 
    
    You are given a sorted array A of n positive integers. Compute
    the difference array B of length n-1 (B[i] = A[i+1] - A[i]) and
    sort the resulting array. Repeat the process n-1 times until there
    is only one element remaining. Output the final element.

    Example:
    [1, 10, 100] -> [9, 90] -> [81]

    Bounds: n <= 10^5
*/

int main()
{
    // Input the size of the array
    int n;
    cin >> n;

    // Input the initial array elements
    vector<int> valsArray(n);
    for (int i = 0; i < n; i++)
    {
        cin >> valsArray[i];
    }

    // Keep track of the number of zeros in the difference array. They will be handled seperately. 
    int numZeros = 0;

    // Iterate until the size of the array is 1
    while (valsArray.size() > 1)
    {
        // Calculate the difference array from the initial array (excluding zeros).
        vector<int> differenceArray;
        for (int i = 1; i < valsArray.size(); i++)
        {
            if (valsArray[i - 1] == valsArray[i])
            {
                numZeros++;
            }
            else
            {
                differenceArray.push_back(valsArray[i] - valsArray[i - 1]);
            }
        }

        // If we have zeros remaining, add one to the difference array. We only add one
        // because additional zeros will not change the next iterations. This optimization
        // is sufficient to make the runtime O(nlogn) instead of O(n^2).
        if (numZeros > 0)
        {
            differenceArray.push_back(0);
            numZeros--;
        }

        // Sort the difference array from smallest to largest.
        sort(differenceArray.begin(), differenceArray.end());

        // Repeat the process using the new difference array.
        valsArray = differenceArray;
    }

    // Output the last remaining element in the final iteration.
    cout << valsArray[0] << endl;
}",Only your latest submission will be checked,AC,C++17,2022-07-30 15:57:57.937814,10
318,JavaScriptJatts,1,1005,"#include <bits/stdc++.h>

using namespace ::std;

//less than
bool comp(int a1, int a2, vector<int>& arr){
    cout << ""q 1\n"";
    cout << a1 << "" < "" << a2 << ""\n"";
    bool ans;
    cin >> ans;
    return(ans);
}

void merge(vector<int>& arr, int start, int mid, int end){

    if(start>=end){return;}

    vector<int> temp;

    int start1 = start;
    int start2 = mid+1;

    while(start1 <= mid && start2 <= end){
        if(comp(start1,start2,arr)){
            temp.push_back(arr[start1]);
            start1++;
        }
        else{
            temp.push_back(arr[start2]);
            start2++;
        }
    }

    while(start1 <= mid){
        temp.push_back(arr[start1]);
        start1++;
    }

    while(start2 <= end){
        temp.push_back(arr[start2]);
        start2++;
    }

    for(int i = 0; i < temp.size(); i++){
        arr[start+i] = temp[i];
    }


    return;
}

void mergeSort(vector<int>& arr, int start, int end){


//    cout << start << "" "" << end << endl;

    if(start >= end){return;}

    int mid = start+((end-start)/2);

    mergeSort(arr, start, mid);
    mergeSort(arr, mid+1, end);

    merge(arr,start, mid,end);

    return;

}



int main() {

    int n,m;

    cin >> n >> m;


    vector<int> arr;

    for(int i = 0; i < n; i++){
        arr.push_back(i);
    }


    mergeSort(arr,0,arr.size()-1);


    string l = ""a"";

    for(int x : arr){
        l += "" "";
        l += to_string(x);
    }

    cout << l;

    cin >> n;

//    return(n);

}

// \o/
//  |
// /_\_","WA on case 0, test 0",WA,C++17,2022-07-30 15:38:40.142922,0
319,FuduBoys,1,1006,"system(""clear"")
r = gets.chomp.to_i

s = "" ""*(r-3)
print(s + ""  >\n"", s+ ""  |\n"",s + ""  .\n"")
s.concat("" "")
c1 = c = k = 0
for i in 1..r-1
 c=r-i-1
  print(s)
  print(""/"")
  while k!=((2*i)-1)
    if c<=r-2
      print((k+65).chr)
      c+=1
    else
      c1+=1
      print((k-(2*c1)+65).chr)
    end
    k+= 1
  end
  c1 = c = k = 0
  print(""\\\n"")
  s = s.chop
end","Error with code 1:
TERM environment variable not set.
/code/Main.rb:4:in `*': negative argument (ArgumentError)
	from /code/Main.rb:4:in `<main>'
",ERR,Ruby,2022-07-30 15:39:05.713819,0
320,TeamJin,1,1008,"import turtle
import random

# Setting the window's Screensize
turtle.screensize(80,24)

# Giving a name to the function
screen = turtle.Screen()

# Creates a night color background
screen.bgcolor(""midnight blue"")

# Giving a name to the window
screen.title(""My Movie"")

# Naming the turtle/pen
tpen = turtle.Turtle()

tpen.hideturtle()

# Setting the speed of the turtle
tpen.speed(10000)

#Defining a function to create stars where x and y is the coordinates in the window
def star(x,y,size):
    # while using penup() function, the turtle named tpen will not draw anything in the window
    tpen.penup()
    
    # goto() sends tpen to a specific coordinate in the window
    tpen.goto(x,y)
    
    # while using pendown() function, tpen will not draw anything in the window
    tpen.pendown()
    
    # colormode() allows users to enter RGB values into pencolor() to create desired colors
    turtle.colormode(255)
    
    # pencolor() is used to set the color of tpen with RGB values ---> ie. pencolor(0,0,0)
    # random.randit() randomly chooses an integer value between 0 - 255.
    tpen.pencolor(random.randint(0,255),
                  random.randint(0,255),
                  random.randint(0,255))
    
    s = size #length of each side of a star
    # Using for-loop to create a star
    for i in range(5):
        
        # forward() is used to tell tpen to move towards the direction it is pointing at
        # The values inside forward() is how much pixels will it move
        tpen.forward(s)
        
        # right() is used to change tpen's direction clockwise
        # The values in right() is the degree of how much it will change
        tpen.right(144)

# Function that creates S
def s():
    tpen.penup()
    tpen.goto(50,-50)
    tpen.pencolor(""white"")
    
    # fillcolor() fills the letter with the intended color
    tpen.fillcolor(""white"")
    
    # Initiates color filling at it's current coordinate
    tpen.begin_fill()
    tpen.pendown()
    tpen.right(90)
    tpen.forward(30)
    tpen.right(90)
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(20)
    tpen.left(90)
    tpen.forward(10)
    tpen.left(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(40)
    tpen.right(90)
    tpen.forward(5)
    tpen.right(90)
    tpen.forward(20)
    tpen.left(90)
    tpen.forward(8)
    tpen.left(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(27)
    tpen.right(90)
    tpen.forward(20)
    
    # Ends color filling at it's current coordinate
    tpen.end_fill()

# Function that creates F
def f():
    tpen.penup()
    tpen.goto(100,-50)
    tpen.pencolor(""white"")
    tpen.fillcolor(""white"")
    tpen.begin_fill()
    tpen.pendown()
    tpen.forward(40)
    tpen.right(90)
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(20)
    tpen.left(90)
    tpen.forward(5)
    tpen.left(90)
    tpen.forward(13)
    tpen.right(90)
    tpen.forward(8)
    tpen.right(90)
    tpen.forward(13)
    tpen.left(90)
    tpen.forward(16)
    tpen.right(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(39)
    tpen.right(90)
    tpen.end_fill()

# Function that creates U
def u():
    tpen.penup()
    tpen.goto(160,-50)
    tpen.pencolor(""white"")
    tpen.pendown()
    tpen.fillcolor(""white"")
    tpen.begin_fill()
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(30)
    tpen.left(90)
    tpen.forward(10)
    tpen.left(90)
    tpen.forward(30)
    tpen.right(90)
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(40)
    tpen.right(90)
    tpen.forward(35)
    tpen.right(90)
    tpen.forward(40)
    tpen.right(90)
    tpen.forward(5)
    tpen.end_fill() 

# Function that creates the red background of the SFU logo
def sfu():
    tpen.penup()
    tpen.goto(-200,100)
    tpen.pencolor(""red"")
    tpen.pendown()
    tpen.fillcolor(""red"")
    tpen.begin_fill()
    tpen.forward(400)
    tpen.right(90)
    tpen.forward(200)
    tpen.right(90)
    tpen.forward(400)
    tpen.right(90)
    tpen.forward(200)
    tpen.end_fill()
    
    # Calling out the s(), f() and u() functions
    s()
    f()
    u()
    
    # ------- MAIN ------- #

####### Create stars in random positions #######

# Asks user for input
stars = int(input(""Enter amount stars: ""))
size = int(input(""Enter length of side of star: ""))

for i in range(stars):
    # generating random integer values for x and y
    x = random.randint(-330, 300)
    y = random.randint(-330, 330)

    # Insert x and y into function to create stars
    star(x,y,size)


surprise = int(input(""Enter 1 for a surprise or 0 for none: ""))
if surprise == 1:
    sfu()

print(""Terminated..."")
screen.exitonclick()","/code/Main.cpp:4:3: error: invalid preprocessing directive #Setting
    4 | # Setting the window's Screensize
      |   ^~~~~~~
/code/Main.cpp:4:21: warning: missing terminating ' character
    4 | # Setting the window's Screensize
      |                     ^
/code/Main.cpp:7:3: error: invalid preprocessing directive #Giving
    7 | # Giving a name to the function
      |   ^~~~~~
/code/Main.cpp:10:3: error: invalid preprocessing directive #Creates
   10 | # Creates a night color background
      |   ^~~~~~~
/code/Main.cpp:13:3: error: invalid preprocessing directive #Giving
   13 | # Giving a name to the window
      |   ^~~~~~
/code/Main.cpp:16:3: error: invalid preprocessing directive #Naming
   16 | # Naming the turtle/pen
      |   ^~~~~~
/code/Main.cpp:21:3: error: invalid preprocessing directive #Setting
   21 | # Setting the speed of the turtle
      |   ^~~~~~~
/code/Main.cpp:24:2: error: invalid preprocessing directive #Defining
   24 | #Defining a function to create stars where x and y is the coordinates in the window
      |  ^~~~~~~~
/code/Main.cpp:26:7: error: invalid preprocessing directive #while
   26 |     # while using penup() function, the turtle named tpen will not draw anything in the window
      |       ^~~~~
/code/Main.cpp:29:7: error: invalid preprocessing directive #goto
   29 |     # goto() sends tpen to a specific coordinate in the window
      |       ^~~~
/code/Main.cpp:32:7: error: invalid preprocessing directive #while
   32 |     # while using pendown() function, tpen will not draw anything in the window
      |       ^~~~~
/code/Main.cpp:35:7: error: invalid preprocessing directive #colormode
   35 |     # colormode() allows users to enter RGB values into pencolor() to create desired colors
      |       ^~~~~~~~~
/code/Main.cpp:38:7: error: invalid preprocessing directive #pencolor
   38 |     # pencolor() is used to set the color of tpen with RGB values ---> ie. pencolor(0,0,0)
      |       ^~~~~~~~
/code/Main.cpp:39:7: error: invalid preprocessing directive #random
   39 |     # random.randit() randomly chooses an integer value between 0 - 255.
      |       ^~~~~~
/code/Main.cpp:44:14: error: stray ‘#’ in program
   44 |     s = size #length of each side of a star
      |              ^
/code/Main.cpp:45:7: error: invalid preprocessing directive #Using
   45 |     # Using for-loop to create a star
      |       ^~~~~
/code/Main.cpp:48:11: error: invalid preprocessing directive #forward
   48 |         # forward() is used to tell tpen to move towards the direction it is pointing at
      |           ^~~~~~~
/code/Main.cpp:49:11: error: invalid preprocessing directive #The
   49 |         # The values inside forward() is how much pixels will it move
      |           ^~~
/code/Main.cpp:52:11: error: invalid preprocessing directive #right
   52 |         # right() is used to change tpen's direction clockwise
      |           ^~~~~
/code/Main.cpp:52:41: warning: missing terminating ' character
   52 |         # right() is used to change tpen's direction clockwise
      |                                         ^
/code/Main.cpp:53:11: error: invalid preprocessing directive #The
   53 |         # The values in right() is the degree of how much it will change
      |           ^~~
/code/Main.cpp:56:3: error: invalid preprocessing directive #Function
   56 | # Function that creates S
      |   ^~~~~~~~
/code/Main.cpp:62:7: error: invalid preprocessing directive #fillcolor
   62 |     # fillcolor() fills the letter with the intended color
      |       ^~~~~~~~~
/code/Main.cpp:65:7: error: invalid preprocessing directive #Initiates
   65 |     # Initiates color filling at it's current coordinate
      |       ^~~~~~~~~
/code/Main.cpp:65:36: warning: missing terminating ' character
   65 |     # Initiates color filling at it's current coordinate
      |                                    ^
/code/Main.cpp:95:7: error: invalid preprocessing directive #Ends
   95 |     # Ends color filling at it's current coordinate
      |       ^~~~
/code/Main.cpp:95:31: warning: missing terminating ' character
   95 |     # Ends color filling at it's current coordinate
      |                               ^
/code/Main.cpp:98:3: error: invalid preprocessing directive #Function
   98 | # Function that creates F
      |   ^~~~~~~~
/code/Main.cpp:128:3: error: invalid preprocessing directive #Function
  128 | # Function that creates U
      |   ^~~~~~~~
/code/Main.cpp:155:3: error: invalid preprocessing directive #Function
  155 | # Function that creates the red background of the SFU logo
      |   ^~~~~~~~
/code/Main.cpp:172:7: error: invalid preprocessing directive #Calling
  172 |     # Calling out the s(), f() and u() functions
      |       ^~~~~~~
/code/Main.cpp:177:7: error: invalid preprocessing directive #--
  177 |     # ------- MAIN ------- #
      |       ^~
/code/Main.cpp:179:1: error: stray ‘##’ in program
  179 | ####### Create stars in random positions #######
      | ^~
/code/Main.cpp:179:3: error: stray ‘##’ in program
  179 | ####### Create stars in random positions #######
      |   ^~
/code/Main.cpp:179:5: error: stray ‘##’ in program
  179 | ####### Create stars in random positions #######
      |     ^~
/code/Main.cpp:179:7: error: stray ‘#’ in program
  179 | ####### Create stars in random positions #######
      |       ^
/code/Main.cpp:179:42: error: stray ‘##’ in program
  179 | ####### Create stars in random positions #######
      |                                          ^~
/code/Main.cpp:179:44: error: stray ‘##’ in program
  179 | ####### Create stars in random positions #######
      |                                            ^~
/code/Main.cpp:179:46: error: stray ‘##’ in program
  179 | ####### Create stars in random positions #######
      |                                              ^~
/code/Main.cpp:179:48: error: stray ‘#’ in program
  179 | ####### Create stars in random positions #######
      |                                                ^
/code/Main.cpp:181:3: error: invalid preprocessing directive #Asks
  181 | # Asks user for input
      |   ^~~~
/code/Main.cpp:186:7: error: invalid preprocessing directive #generating
  186 |     # generating random integer values for x and y
      |       ^~~~~~~~~~
/code/Main.cpp:190:7: error: invalid preprocessing directive #Insert; did you mean #assert?
  190 |     # Insert x and y into function to create stars
      |       ^~~~~~
      |       assert
/code/Main.cpp:1:1: error: ‘import’ does not name a type
    1 | import turtle
      | ^~~~~~
/code/Main.cpp:1:1: note: C++20 ‘import’ only available with ‘-fmodules-ts’
",CERR,C++17,2022-07-30 15:41:28.755336,0
321,student1,1,1005,"#include <bits/stdc++.h>
using namespace std;
// incomplete
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef complex<double> cd;

int n, m;
bool p = false;
void do_rep(vi &a){
	vector<pair<int, int>> qs;
	int nq = (n-p)/2;
	cout << ""q "" << nq << endl;
	if (!p) {
		for(int i=0; i<n-1; i+=2){
			qs.push_back({i, i+1});
			cout << a[i] << "" < "" << a[i+1] << endl;
		}
	} else {
		for(int i=1; i<n-1; i+=2){
			qs.push_back({i, i+1});
			cout << a[i] << "" < "" << a[i+1] << endl;
		}
	}
	rep(i,0,nq){
		int b;
		cin >> b;
		if (b == 0) {
			swap(a[qs[i].first], a[qs[i].second]);
		}
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	// int n, m;
	cin >> n >> m;
	vi a(n);
	iota(all(a), 0);
	rep(i, 0, m){
		do_rep(a);
		p = !p;
	}
	cout << ""a"";
	rep(i,0,n){
		cout << "" "" << a[i];
	}
	cout << endl;
}","WA on case 0, test 0","",C++17,2022-07-30 15:41:36.676351,0
360,teamAverage,1,1008,"#include <iostream>
#include <cassert>

using namespace std;

//move n disks from source to destination using a temporary
void move(int n, char source, char dest, char temp){
    if(n==0){
       return;
    }
    move(n-1, source, temp, dest);
    cout << ""move from "" << source << "" to "" << dest << endl;
    move(n-1, dest, temp, source);
}

//Let M(n) be the number of moves given n disks
//M(1) = 1, M(2) = 3
//M(n) = M(n-1) + M(1) + M(n-1)
//for n>1, M(n) = 2M(n-1) + M(1)
//M(3) = 2M(2) + 1 = 2 x 3 + 1 = 7
//M(4) = 2M(3) + 1 = 15         
//M(5) = 2M(4) + 1 = 31             M(n) = 2^n - 1 for all n>1, O(2^n)

int main(){
    int n;
    cout << ""Enter # of disks on tower > "";
    cin >> n;
    assert(n>0); //if false, terminates the program
    cout << ""n source is A and destination is C"" << endl;

    move(n, 'A', 'C', 'B');
    return 0;
}",Only your latest submission will be checked,AC,C++17,2022-07-30 15:58:15.421477,10
322,JavaScriptJatts,1,1005,"#include <bits/stdc++.h>

using namespace ::std;

void merge(vector<int>& arr, int start, int mid, int end){

    if(start>=end){return;}

    vector<int> temp;

    int start1 = start;
    int start2 = mid+1;

    while(start1 <= mid && start2 <= end){
        cout << ""q 1\n"";
        cout << start1 << "" < "" << start2 << ""\n"";
        int ans;
        cin >> ans;

        if(ans == -1){return;}

        if(ans == 1){
            temp.push_back(arr[start1]);
            start1++;
        }
        else{
            temp.push_back(arr[start2]);
            start2++;
        }
    }

    while(start1 <= mid){
        temp.push_back(arr[start1]);
        start1++;
    }

    while(start2 <= end){
        temp.push_back(arr[start2]);
        start2++;
    }

    for(int i = 0; i < temp.size(); i++){
        arr[start+i] = temp[i];
    }


    return;
}

void mergeSort(vector<int>& arr, int start, int end){


//    cout << start << "" "" << end << endl;

    if(start >= end){return;}

    int mid = start+((end-start)/2);

    mergeSort(arr, start, mid);
    mergeSort(arr, mid+1, end);

    merge(arr,start, mid,end);

    return;

}



int main() {

    int n,m;

    cin >> n >> m;


    vector<int> arr;

    for(int i = 0; i < n; i++){
        arr.push_back(i);
    }


    mergeSort(arr,0,arr.size()-1);


    string l = ""a"";

    for(int x : arr){
        l += "" "";
        l += to_string(x);
    }

    cout << l;

    cin >> n;

//    return(n);

}

// \o/
//  |
// /_\_","WA on case 0, test 0",WA,C++17,2022-07-30 15:42:27.442438,0
323,TeamJin,1,1009,"import turtle
import random

turtle.screensize(80,24)
screen = turtle.Screen()

# Creates a night color background
screen.bgcolor(""midnight blue"")
screen.title(""My Movie"")
tpen = turtle.Turtle()
tpen.hideturtle()
tpen.speed(1000000000000)

# Function to create stars
def star(x,y):
    tpen.penup()
    tpen.goto(x,y)
    tpen.pendown()
    turtle.colormode(255)
    tpen.pencolor(random.randint(0,255),
                  random.randint(0,255),
                  random.randint(0,255))
    
    for i in range(5):
        tpen.forward(10)
        tpen.right(144)

# Function to create moon
def moon():
    tpen.up()
    tpen.goto(200,140)
    tpen.down()
    tpen.color(""honeydew"")
    tpen.begin_fill()
    tpen.circle(80)
    tpen.end_fill()
 
# Function to create moolight effect   
def moonlight(x_moonlight,y_moonlight,c_light):
    tpen.up()
    tpen.goto(x_moonlight,y_moonlight)
    tpen.down()
    tpen.color(""silver"")
    tpen.circle(c_light)

# Function to create land
def land():
    tpen.penup()
    tpen.goto(-360,-200)
    tpen.pendown()
    tpen.color(""dark slate gray"")
    tpen.begin_fill()
    
    for i in range(4):
        tpen.forward(720)
        tpen.right(90)
    
    tpen.end_fill()

# Function to create Left Mountain
def left_mountain():
    tpen.penup()
    tpen.goto(-410,-201)
    tpen.pendown()
    tpen.color(""gray"")
    tpen.begin_fill()
    
    for i in range(3):
        tpen.forward(300)
        tpen.left(120)
    
    tpen.end_fill()

    # Snow cap on left Mountain
    tpen.penup()
    tpen.goto(-300, -10)
    tpen.pendown()
    tpen.color(""dark gray"")
    tpen.begin_fill()
    tpen.left(30)
    tpen.forward(25)
    tpen.right(60)
    tpen.forward(25)
    tpen.left(60)
    tpen.forward(32)
    tpen.left(90)
    tpen.forward(60)
    tpen.right(120)
    tpen.end_fill()

# Function to create Right Mountain
def right_mountain():
    tpen.penup()
    tpen.goto(100,-201)
    tpen.pendown()
    tpen.color(""gray"")
    tpen.begin_fill()
    
    for i in range(3):
        tpen.forward(300)
        tpen.left(120)
    
    tpen.end_fill()
    
    # Snow cap on right Mountain
    tpen.penup()
    tpen.goto(210, -10)
    tpen.pendown()
    tpen.color(""dark gray"")
    tpen.begin_fill()
    tpen.left(30)
    tpen.forward(25)
    tpen.right(60)
    tpen.forward(25)
    tpen.left(60)
    tpen.forward(32)
    tpen.left(90)
    tpen.forward(60)
    tpen.right(120)
    tpen.end_fill()

# Function to create Middle Mountain
def middle_mountain():
    tpen.penup()
    tpen.goto(-190,-201)
    tpen.pendown()
    tpen.color(""dim gray"")
    tpen.begin_fill()
    
    for i in range(3):
        tpen.forward(350)
        tpen.left(120)
    
    tpen.end_fill()
    
    # Snow cap on middle Mountain
    tpen.penup()
    tpen.goto(-55, 34)
    tpen.pendown()
    tpen.color(""gray"")
    tpen.begin_fill()
    tpen.left(30)
    tpen.forward(25)
    tpen.right(60)
    tpen.forward(25)
    tpen.left(60)
    tpen.forward(32)
    tpen.left(90)
    tpen.forward(60)
    tpen.right(120)
    tpen.end_fill()

# Function that create trees
def tree(x,y):
    tpen.penup()
    tpen.goto(x,y)
    tpen.pendown()
    tpen.color(""saddle brown"")
    tpen.left(90)
    tpen.forward(25)
    
    # Left Tree Branches
    tpen.left(60)
    tpen.forward(20)
    tpen.left(30)
    tpen.forward(15)
    # Tree Leaves
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.backward(15)
    tpen.right(60)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.right(30)
    
    # Middle Tree Branches
    tpen.penup()
    tpen.goto(x,y+25)
    tpen.pendown()
    tpen.forward(20)
    tpen.left(30)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.backward(15)
    tpen.right(60)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.left(30)
    
    # Right Tree Branches
    tpen.penup()
    tpen.goto(x,y+25)
    tpen.pendown()
    tpen.right(60)
    tpen.forward(20)
    tpen.left(30)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.backward(15)
    tpen.right(60)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")

# Function that create my initials
def my_initials():
    
    # Create J
    tpen.penup()
    tpen.goto(290,-305)
    tpen.pendown()
    tpen.pensize(2)
    tpen.pencolor(""alice blue"")
    #--------------------------
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(7)
    tpen.right(90)
    tpen.forward(2)
    tpen.left(180)
    
    # Create L
    tpen.penup()
    tpen.goto(305,-305)
    tpen.pendown()
    #--------------------------
    tpen.forward(20)
    tpen.left(90)
    tpen.forward(10)
    
    # Create first 7
    tpen.penup()
    tpen.goto(317,-305)
    tpen.pendown()
    #--------------------------
    tpen.forward(10)
    tpen.right(110)
    tpen.forward(20)
    tpen.left(110)
    
    # Create second 7
    tpen.penup()
    tpen.goto(330,-305)
    tpen.pendown()
    #--------------------------
    tpen.forward(10)
    tpen.right(110)
    tpen.forward(20)
    

# ------- MAIN ------- #

####### Create stars in random positions #######
for i in range(100):
    
    # generating random integer values for x and y
    x = random.randint(-330, 300)
    y = random.randint(-50, 330)

    # Insert x and y into function to create stars
    star(x,y)


# Function that creates the Moon and moon light
moon()
x_moonlight = 200
y_moonlight = 140
c_light = 80

# For loop creates multiple moonlight rings
for i in range(30):
    y_moonlight -= 35
    c_light += 35
    moonlight(x_moonlight,y_moonlight,c_light)


# Function that creates Plain Land
land()

# Functions that will create the Left, Middle and Right Mountains
middle_mountain()
left_mountain()
right_mountain()

####### Create trees in random positions #######
for j in range(40):
    
    # generating random integer values for x and y
    x = random.randint(-310, 310)
    y = random.randint(-320, -210)

    # Insert x and y into function to create trees
    tree(x,y)

# Function that will create my initials
my_initials()

screen.exitonclick()","/code/Main.cpp:7:3: error: invalid preprocessing directive #Creates
    7 | # Creates a night color background
      |   ^~~~~~~
/code/Main.cpp:14:3: error: invalid preprocessing directive #Function
   14 | # Function to create stars
      |   ^~~~~~~~
/code/Main.cpp:28:3: error: invalid preprocessing directive #Function
   28 | # Function to create moon
      |   ^~~~~~~~
/code/Main.cpp:38:3: error: invalid preprocessing directive #Function
   38 | # Function to create moolight effect
      |   ^~~~~~~~
/code/Main.cpp:46:3: error: invalid preprocessing directive #Function
   46 | # Function to create land
      |   ^~~~~~~~
/code/Main.cpp:60:3: error: invalid preprocessing directive #Function
   60 | # Function to create Left Mountain
      |   ^~~~~~~~
/code/Main.cpp:74:7: error: invalid preprocessing directive #Snow
   74 |     # Snow cap on left Mountain
      |       ^~~~
/code/Main.cpp:91:3: error: invalid preprocessing directive #Function
   91 | # Function to create Right Mountain
      |   ^~~~~~~~
/code/Main.cpp:105:7: error: invalid preprocessing directive #Snow
  105 |     # Snow cap on right Mountain
      |       ^~~~
/code/Main.cpp:122:3: error: invalid preprocessing directive #Function
  122 | # Function to create Middle Mountain
      |   ^~~~~~~~
/code/Main.cpp:136:7: error: invalid preprocessing directive #Snow
  136 |     # Snow cap on middle Mountain
      |       ^~~~
/code/Main.cpp:153:3: error: invalid preprocessing directive #Function
  153 | # Function that create trees
      |   ^~~~~~~~
/code/Main.cpp:162:7: error: invalid preprocessing directive #Left
  162 |     # Left Tree Branches
      |       ^~~~
/code/Main.cpp:167:7: error: invalid preprocessing directive #Tree
  167 |     # Tree Leaves
      |       ^~~~
/code/Main.cpp:178:7: error: invalid preprocessing directive #Leaves
  178 |     # Leaves of the Tree
      |       ^~~~~~
/code/Main.cpp:188:7: error: invalid preprocessing directive #Middle
  188 |     # Middle Tree Branches
      |       ^~~~~~
/code/Main.cpp:195:7: error: invalid preprocessing directive #Leaves
  195 |     # Leaves of the Tree
      |       ^~~~~~
/code/Main.cpp:206:7: error: invalid preprocessing directive #Leaves
  206 |     # Leaves of the Tree
      |       ^~~~~~
/code/Main.cpp:216:7: error: invalid preprocessing directive #Right
  216 |     # Right Tree Branches
      |       ^~~~~
/code/Main.cpp:224:7: error: invalid preprocessing directive #Leaves
  224 |     # Leaves of the Tree
      |       ^~~~~~
/code/Main.cpp:235:7: error: invalid preprocessing directive #Leaves
  235 |     # Leaves of the Tree
      |       ^~~~~~
/code/Main.cpp:244:3: error: invalid preprocessing directive #Function
  244 | # Function that create my initials
      |   ^~~~~~~~
/code/Main.cpp:247:7: error: invalid preprocessing directive #Create
  247 |     # Create J
      |       ^~~~~~
/code/Main.cpp:253:6: error: invalid preprocessing directive #--
  253 |     #--------------------------
      |      ^~
/code/Main.cpp:263:7: error: invalid preprocessing directive #Create
  263 |     # Create L
      |       ^~~~~~
/code/Main.cpp:267:6: error: invalid preprocessing directive #--
  267 |     #--------------------------
      |      ^~
/code/Main.cpp:272:7: error: invalid preprocessing directive #Create
  272 |     # Create first 7
      |       ^~~~~~
/code/Main.cpp:276:6: error: invalid preprocessing directive #--
  276 |     #--------------------------
      |      ^~
/code/Main.cpp:282:7: error: invalid preprocessing directive #Create
  282 |     # Create second 7
      |       ^~~~~~
/code/Main.cpp:286:6: error: invalid preprocessing directive #--
  286 |     #--------------------------
      |      ^~
/code/Main.cpp:292:3: error: invalid preprocessing directive #--
  292 | # ------- MAIN ------- #
      |   ^~
/code/Main.cpp:294:1: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      | ^~
/code/Main.cpp:294:3: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      |   ^~
/code/Main.cpp:294:5: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      |     ^~
/code/Main.cpp:294:7: error: stray ‘#’ in program
  294 | ####### Create stars in random positions #######
      |       ^
/code/Main.cpp:294:42: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      |                                          ^~
/code/Main.cpp:294:44: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      |                                            ^~
/code/Main.cpp:294:46: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      |                                              ^~
/code/Main.cpp:294:48: error: stray ‘#’ in program
  294 | ####### Create stars in random positions #######
      |                                                ^
/code/Main.cpp:297:7: error: invalid preprocessing directive #generating
  297 |     # generating random integer values for x and y
      |       ^~~~~~~~~~
/code/Main.cpp:301:7: error: invalid preprocessing directive #Insert; did you mean #assert?
  301 |     # Insert x and y into function to create stars
      |       ^~~~~~
      |       assert
/code/Main.cpp:305:3: error: invalid preprocessing directive #Function
  305 | # Function that creates the Moon and moon light
      |   ^~~~~~~~
/code/Main.cpp:311:3: error: invalid preprocessing directive #For
  311 | # For loop creates multiple moonlight rings
      |   ^~~
/code/Main.cpp:318:3: error: invalid preprocessing directive #Function
  318 | # Function that creates Plain Land
      |   ^~~~~~~~
/code/Main.cpp:321:3: error: invalid preprocessing directive #Functions
  321 | # Functions that will create the Left, Middle and Right Mountains
      |   ^~~~~~~~~
/code/Main.cpp:326:1: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      | ^~
/code/Main.cpp:326:3: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      |   ^~
/code/Main.cpp:326:5: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      |     ^~
/code/Main.cpp:326:7: error: stray ‘#’ in program
  326 | ####### Create trees in random positions #######
      |       ^
/code/Main.cpp:326:42: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      |                                          ^~
/code/Main.cpp:326:44: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      |                                            ^~
/code/Main.cpp:326:46: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      |                                              ^~
/code/Main.cpp:326:48: error: stray ‘#’ in program
  326 | ####### Create trees in random positions #######
      |                                                ^
/code/Main.cpp:329:7: error: invalid preprocessing directive #generating
  329 |     # generating random integer values for x and y
      |       ^~~~~~~~~~
/code/Main.cpp:333:7: error: invalid preprocessing directive #Insert; did you mean #assert?
  333 |     # Insert x and y into function to create trees
      |       ^~~~~~
      |       assert
/code/Main.cpp:336:3: error: invalid preprocessing directive #Function
  336 | # Function that will create my initials
      |   ^~~~~~~~
/code/Main.cpp:1:1: error: ‘import’ does not name a type
    1 | import turtle
      | ^~~~~~
/code/Main.cpp:1:1: note: C++20 ‘import’ only available with ‘-fmodules-ts’
",CERR,C++17,2022-07-30 15:43:07.07313,0
324,teamAverage,1,1006,"#include <iostream>
#include <iomanip>
using namespace std;
int main(){
    int i,j,k,x;
    cin>>x;
    for(i=0;i<x;i++){
        if(i==0)cout<<setw(x+1)<<'>'<<""\n""<<setw(x+1)<<'|'<<'\n'<<setw(x+1)<<'.'<<'\n'; 
        else{
            cout<<setw(x+1-i)<<'/';
            for(j=0;j<i;j++)cout<<char(65+j);
            for(k=i-2;k>-1;k--)cout<<char(65+k);
            cout<<""\\""<<""\n"";
        }   
    }
}
","",AC,C++17,2022-07-30 15:44:02.342289,50
325,TeamJin,1,1005,"def compAnswer():
    return int(input())


def query(num1, num2):
    print(""q 1"")
    print(str(num1) + "" < "" + str(num2))
    return compAnswer()


nums = list(map(int, input().split()))
n = nums[0]
m = nums[1]

aLst = list(range(n))

#query two nums
#make a list out of the two nums in proper order
# keep merging the lists

#------------------------------------------Geek For Geeks
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
 
    # create temp arrays
    L = [0] * (n1)
    R = [0] * (n2)
 
    # Copy data to temp arrays L[] and R[]
    for i in range(0, n1):
        L[i] = arr[l + i]
 
    for j in range(0, n2):
        R[j] = arr[m + 1 + j]
 
    # Merge the temp arrays back into arr[l..r]
    i = 0     # Initial index of first subarray
    j = 0     # Initial index of second subarray
    k = l     # Initial index of merged subarray
 
    while i < n1 and j < n2:
        if query(L[i], R[j]):
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
 
    # Copy the remaining elements of L[], if there
    # are any
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1
 
    # Copy the remaining elements of R[], if there
    # are any
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1
 
# l is for left index and r is right index of the
# sub-array of arr to be sorted
 
 
def mergeSort(arr, l, r):
    if l < r:
 
        # Same as (l+r)//2, but avoids overflow for
        # large l and h
        m = l+(r-l)//2
 
        # Sort first and second halves
        mergeSort(arr, l, m)
        mergeSort(arr, m+1, r)
        merge(arr, l, m, r)
 

#----------------------------------------------------------------------


def printAnswer():
    retSt = ""a""
    for i in range(len(aLst)):
        retSt += "" "" + str(aLst[i])
    print(retSt)

printAnswer()","WA on case 0, test 1","",Python3,2022-07-30 15:44:34.803547,0
326,FuduBoys,1,1006,"system(""clear"")
r = gets.chomp.to_i
r=r-1
if r > 2
  s = "" ""*(r-2)
else 
  s = "" ""
end
print(s + ""  >\n"", s+ ""  |\n"",s + ""  .\n"")
s.concat("" "")
c1 = c = k = 0
for i in 1..r
 c=r-i-1
  print(s)
  print(""/"")
  while k!=((2*i)-1)
    if c<=r-2
      print((k+65).chr)
      c+=1
    else
      c1+=1
      print((k-(2*c1)+65).chr)
    end
    k+= 1
  end
  c1 = c = k = 0
  print(""\\\n"")
  s = s.chop
end","",AC,Ruby,2022-07-30 15:46:16.902344,50
372,Albus,1,1007,"[n, q] = list(map(int, input().split()))
colors = [""white""]*n
ans = []
for i in range(q):
    row = input().split()
    if row[0] == 'q':
        ans.append(colors[int(row[1])-1])
    # if row[0] == 'p':
    else:
        for j in range(int(row[1])-1, int(row[2])):
            colors[j] = row[3]
for i in range(len(ans)):
    print(ans[i])

","Failed on case 3, test 0",TLE,Pypy3,2022-07-30 16:00:07.443342,40
371,datOvercommon,1,1007,"plank1 = list(map(int, input().split()))
query = plank1[1]
plank = plank1[0]

fences = {}

for x in range(1, plank+1):
    fences.update({x: ""white""})

out = []
for x in range(query):
    command = list(input().split())
    if command[0] == 'q':
        n = command[1]
        out.append(fences.get(int(n)))
    if command[0] == 'p':
        start = int(command[1])
        end = int(command[2])
        col = command[3]
        for x in range(start, end+1):
            fences[x] = col

for x in out:
    print(x)
","Failed on case 3, test 0",TLE,Pypy3,2022-07-30 16:00:07.109,40
330,JavaScriptJatts,1,1005,"#include <bits/stdc++.h>

using namespace ::std;

void merge(vector<int>& arr, int start, int mid, int end){

    if(start>=end){return;}

    vector<int> temp;

    int start1 = start;
    int start2 = mid+1;

    while(start1 <= mid && start2 <= end){
        cout << ""q 1\n"";
        cout << start1 << "" < "" << start2 << ""\n"";
        int ans;
        cin >> ans;

        if(ans == -1){return;}

        if(ans == 1){
            temp.push_back(arr[start1]);
            start1++;
        }
        else{
            temp.push_back(arr[start2]);
            start2++;
        }
    }

    while(start1 <= mid){
        temp.push_back(arr[start1]);
        start1++;
    }

    while(start2 <= end){
        temp.push_back(arr[start2]);
        start2++;
    }

    for(int i = 0; i < temp.size(); i++){
        arr[start+i] = temp[i];
    }


    return;
}

void mergeSort(vector<int>& arr, int start, int end){


//    cout << start << "" "" << end << endl;

    if(start >= end){return;}

    int mid = start+((end-start)/2);

    mergeSort(arr, start, mid);
    mergeSort(arr, mid+1, end);

    merge(arr,start, mid,end);

    return;

}



int main() {

    int n,m;

    cin >> n >> m;


    vector<int> arr;

    for(int i = 0; i < n; i++){
        arr.push_back(i);
    }


    mergeSort(arr,0,arr.size()-1);


    string l = ""a"";

    for(int x : arr){
        l += "" "";
        l += to_string(x);
    }

    cout << l << endl;

    cin >> n;

//    return(n);

}

// \o/
//  |
// /_\_","WA on case 0, test 2","",C++17,2022-07-30 15:47:44.063974,0
331,Albus,1,1006,"#include <stdio.h>
void s(int n){for (int i = 1; i < n; i++)printf("" "");}int main(){int n;scanf(""%d"", &n);s(n);printf("">\n"");s(n);printf(""|\n"");s(n);printf("".\n"");for (int i = 1; i < n; i++){int r = i - 1;s(n - r - 1);int j;printf(""/"");for (j = 0; j < r; j++)printf(""%c"", 'A' + j);for (j = r; j > -1; j--)printf(""%c"", 'A' + j);printf(""\\\n"");}}","",AC,C++17,2022-07-30 15:48:31.746886,50
332,student1,1,1005,"#include <bits/stdc++.h>
using namespace std;
// incomplete
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef complex<double> cd;

int n, m;
bool p = false;
void do_rep(vi &a){
	vector<pair<int, int>> qs;
	int nq = (n-p)/2;
	cout << ""q "" << nq << endl;
	if (!p) {
		for(int i=0; i<n-1; i+=2){
			qs.push_back({i, i+1});
			cout << a[i] << "" < "" << a[i+1] << endl;
		}
	} else {
		for(int i=1; i<n-1; i+=2){
			qs.push_back({i, i+1});
			cout << a[i] << "" < "" << a[i+1] << endl;
		}
	}
	rep(i,0,nq){
		int b;
		cin >> b;
		if (b == 0) {
			swap(a[qs[i].first], a[qs[i].second]);
		}
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	// int n, m;
	cin >> n >> m;
	vi a(n);
	iota(all(a), 0);
	rep(i, 0, m-1){
		do_rep(a);
		p = !p;
	}
	cout << ""a"";
	rep(i,0,n){
		cout << "" "" << a[i];
	}
	cout << endl;
}","WA on case 2, test 0","",C++17,2022-07-30 15:50:49.650576,70
334,Albus,1,1006,"#include <stdio.h>
void s(int n){for(int i=1;i<n;i++)printf("" "");}int main(){int n;scanf(""%d"", &n);s(n);printf("">\n"");s(n);printf(""|\n"");s(n);printf("".\n"");for (int i=1;i<n;i++){int r=i-1;s(n-r-1);int j;printf(""/"");for(j=0;j<r;j++)printf(""%c"",'A'+j);for(j=r;j>-1;j--)printf(""%c"",'A'+j);printf(""\\\n"");}}","",AC,C++17,2022-07-30 15:50:54.989124,50
335,Albus,1,1006,"#include <stdio.h>
void s(int n){for(int i=1;i<n;i++)printf("" "");}int main(){int n;scanf(""%d"", &n);s(n);printf("">\n"");s(n);printf(""|\n"");s(n);printf("".\n"");for(int i=1;i<n;i++){int r=i-1;s(n-r-1);int j;printf(""/"");for(j=0;j<r;j++)printf(""%c"",'A'+j);for(j=r;j>-1;j--)printf(""%c"",'A'+j);printf(""\\\n"");}}","",AC,C++17,2022-07-30 15:52:08.073709,50
336,untitled,1,1009,"#include <bits/stdc++.h>

using namespace std;
using namespace std::this_thread;     // sleep_for, sleep_until
using namespace std::chrono_literals; // ns, us, ms, s, h, etc.
using std::chrono::system_clock;


class drawable{
    public:
        drawable(vector<string> object){
            figure = object;
        }
        vector<string> getFigure(){
            return figure;
        }
    
    private:
        vector<string> figure{
            R""(        _____      )"",
            R""(    .-,;='';_),-.  )"",
            R""(     \_\(),()/_/   )"",
            R""(       (,___,)     )"",
            R""(      ,-/`~`\-,___ )"",
            R""(     / /).:.('--._))"",
            R""(    {_[ (_,_)      )"",
            R""(        | Y |      )"",
            R""(       /  |  \     )"",
            R""(       """""" """"""     )"",

        };
};
class Canvas{
    public:
        void clear(){
            mCurrentCanvas = mCleanCanvas;
            system(""clear"");
        }
        void addFigure(drawable t, int x, int y){
            vector<string> tt = t.getFigure();
            for(int i = 0; i < tt.size(); ++i){
                for(int j = 0; j < tt[i].length(); ++j){
                    mCurrentCanvas[y+i][x+j] = tt[i][j];
                }
            }
        }
        void draw(){
            for(auto str: mCurrentCanvas)
                cout << str << endl;
        }
    private:
        vector<string> mCleanCanvas{
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
            R""(                                                        )"",
        };
        vector<string> mCurrentCanvas;

};



int main(){
    int cycle = 10, step = 1;
    int direction = 1;

    Canvas* myCanvas = new Canvas();

    vector<string> figure1{
            R""(        _____      )"",
            R""(    .-,;='';_),-.  )"",
            R""(     \_\(),()/_/   )"",
            R""(       (,___,)     )"",
            R""(      ,-/`~`\-,___ )"",
            R""(     / /).:.('--._))"",
            R""(    {_[ (_,_)      )"",
            R""(        | Y |      )"",
            R""(       /  |  \     )"",
            R""(       """""" """"""     )"",

    };
    vector<string> figure2{
            R""(        _____      )"",
            R""(    .-,;='';_),-.  )"",
            R""(     \_\(),()/_/   )"",
            R""(       (,___,)     )"",
            R""(      ,-/`~`\-,___ )"",
            R""(     / /).:.('--._))"",
            R""(    {_[ (_,_)      )"",
            R""(        | Y |      )"",
            R""(       /  |  \     )"",
            R""(       """""" """"""     )"",

    };
    drawable actor1(figure1), actor2(figure2);

    int curY1 = 0, curY2 = 5;
    int curX1 = 0, curX2 = 20;
    int cnt = 0;
    int direction1 = 1, direction2 = -1;
    for(int i = 0; i < 103; ++i){
        myCanvas->clear();
        myCanvas->addFigure(actor1, curX1, curY1);
        myCanvas->addFigure(actor2, curX2, curY2);
        curY1+= direction1*step;
        curY2+= direction2*step;
        ++cnt;
        myCanvas->draw();
        sleep_for(0.005s);
        if(cnt == 5){
            direction1 *= -1;
            direction2 *= -1;
            cnt = 0;
        }
    }

    delete myCanvas;

}",Only your latest submission will be checked,AC,C++17,2022-07-30 15:52:10.739944,10
374,coffeepls,1,1007,"n, q = input().split()

n = int(n)
q = int(q)
l = ['white']*n
i = 0
ans = []
while (i<q):
    query = input().split()
    i += 1
    if query[0]=='q':
        ans.append(l[int(query[1])-1])
    else:
        a = int(query[1])-1
        b = int(query[2])
        for j in range(a, b):
            l[j] = query[3]
for i in range(len(ans)):
    print(ans[i])",,judging,Python3,2022-07-30 16:03:58.468568,0
338,HS,1,1009,"#include <vector>
#include <string>
#include <ctime>
#include <iostream>
#include <Windows.h>
#include <cstdlib>
using namespace std;

int SW = 50;
int SH = 15;

vector<string> script = {
	""I am a fish......"",
	""A lonely fish in a quiet terminal......"",
	""I will perish as soon as this Strange contest is over......"",
	""What am I worth......?"",
	""10 points? 20? Or, maybe......"",
	""It will be a dream if my short life is worth 100 points......"",
	""If I get 100 points, I will live the rest of my short life in happiness......."",
	"".......At least until my program is over......."",
	""Hey, friend..... Will you give me 100 points?"",
	""It's my only dream......"",
	""And it seems like my life is almost over......."",
	""This would be the end. Bye.........""
};

int main()
{
	int loc_x = rand() % SW + 1;
	int loc_y = rand() % SH + 1+3;

	srand(time(NULL));
	int loop_ind = 0;
	while (true) {
		cout << endl;
		string s = script[(loop_ind / 7) % script.size()];
		cout << ""                 "" << s;
		for (int i = 0; i < loc_y; i++) {
			cout << ""\n"";
		}
		for (int j = 0; j < loc_x; j++) {
			cout << "" "";
		}
		cout << ""<°)))><"" << endl;
		for (int i = 0; i < SH - loc_y - 1; i++) {
			cout << endl;
		}

		loc_x += (rand() % 10 - 5)/4;
		loc_y += (rand() % 10 - 5)/4;
		loop_ind++;
		Sleep(1000);
	}

	return 0;
}
","/code/Main.cpp:5:10: fatal error: Windows.h: No such file or directory
    5 | #include <Windows.h>
      |          ^~~~~~~~~~~
compilation terminated.
",CERR,C++17,2022-07-30 15:52:26.858926,0
337,JavaScriptJatts,1,1005,"#include <bits/stdc++.h>

using namespace ::std;

void merge(vector<int>& arr, int start, int mid, int end){

    if(start>=end){return;}

    vector<int> temp;

    int start1 = start;
    int start2 = mid+1;

    while(start1 <= mid && start2 <= end){
        cout << ""q 1\n"";
        cout << start1 << "" < "" << start2 << ""\n"";
        int ans;
        cin >> ans;

        if(ans == -1){throw std::invalid_argument( ""received negative value"" );}

        if(ans == 1){
            temp.push_back(arr[start1]);
            start1++;
        }
        else{
            temp.push_back(arr[start2]);
            start2++;
        }
    }

    while(start1 <= mid){
        temp.push_back(arr[start1]);
        start1++;
    }

    while(start2 <= end){
        temp.push_back(arr[start2]);
        start2++;
    }

    for(int i = 0; i < temp.size(); i++){
        arr[start+i] = temp[i];
    }


    return;
}

void mergeSort(vector<int>& arr, int start, int end){


//    cout << start << "" "" << end << endl;

    if(start >= end){return;}

    int mid = start+((end-start)/2);

    mergeSort(arr, start, mid);
    mergeSort(arr, mid+1, end);

    try {
        merge(arr,start, mid,end);
    }
    catch( const std::invalid_argument& e ) {
        throw std::invalid_argument( ""received negative value"" );
    }


    return;

}



int main() {

    int n,m;

    cin >> n >> m;


    vector<int> arr;

    for(int i = 0; i < n; i++){
        arr.push_back(i);
    }

    try {
        mergeSort(arr,0,arr.size()-1);
    }
    catch( const std::invalid_argument& e ) {
        return(0);
    }


    string l = ""a"";

    for(int x : arr){
        l += "" "";
        l += to_string(x);
    }

    cout << l << endl;

    cin >> n;

//    return(n);

}

// \o/
//  |
// /_\_","WA on case 0, test 4","",C++17,2022-07-30 15:52:26.473882,0
343,HS,1,1005,"
#include <bits/stdc++.h>
using namespace std;

struct Node_struct {
    vector<int> prev;
    vector<int> next;
};

int n, m;
int max_comparison;
vector<struct Node_struct> nodes;
int num_comparisons;
vector<pair<int, int>> comparison_targets;
vector<pair<int, int>> comparison_caller; // this is for change after comparison
vector<bool> in_targets;
vector<bool> visited;

// add to targets. increment num_comparisons
// option: (1: from prev), (2: from next)
void add_to_targets(const int& a, const int& b, const int& caller, const int& option) {
    comparison_targets.push_back(pair<int, int>(a, b));
    comparison_caller.push_back(pair<int, int>(caller, option));
    in_targets[a] = true;
    in_targets[b] = true;
    num_comparisons++;
}

/*DFS description:
    test if more than 2 prevs
        find possible targets and add
        return if (num_comparisons == m)
    test if more than 2 nexts
        find possible targets and add
        return if (num_comparisons == m)
    iterate nexts
        if not visited, DFS that.
        return if (num_comparisons == m)
*/
void DFS(const int& current) {
    visited[current] = true;
    if (nodes[current].prev.size() > 1) {
        int i = 0;
        while (num_comparisons < max_comparison && i < nodes[current].prev.size()) {
            int a = -1;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    a = nodes[current].prev[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].prev.size(); i++) {
                if (!in_targets[nodes[current].prev[i]]) {
                    b = nodes[current].prev[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 1);
            }
        }
        if (num_comparisons == max_comparison) return;
    }
    if (nodes[current].next.size() > 1) {
        int i = 0;
        while (num_comparisons < max_comparison && i < nodes[current].next.size()) {
            int a = -1;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    a = nodes[current].next[i];
                    break;
                }
            }
            int b = -1; i++;
            for (; i < nodes[current].next.size(); i++) {
                if (!in_targets[nodes[current].next[i]]) {
                    b = nodes[current].next[i];
                    break;
                }
            }
            if (a != -1 && b != -1) {
                add_to_targets(b, a, current, 2);
            }
        }
        if (num_comparisons == max_comparison) return;
    }

    // children
    for (int i = 0; i < nodes[current].next.size(); i++) {
        if (!visited[nodes[current].next[i]]) {
            DFS(nodes[current].next[i]);
            if (num_comparisons == max_comparison) return;
        }
    }
    for (int i = 0; i < nodes[current].prev.size(); i++) {
        if (!visited[nodes[current].prev[i]]) {
            DFS(nodes[current].prev[i]);
            if (num_comparisons == max_comparison) return;
        }
    }
}

int main()
{
    cin >> n >> m;
    
    max_comparison = n/2;
    nodes = vector<struct Node_struct>(n);
    
    bool ans_found = false;
    for(int i = 0; i < m; i++) {
        num_comparisons = 0;
        comparison_targets.clear();
        comparison_caller.clear();
        in_targets = vector<bool>(n, false);
        visited = vector<bool>(n, false);
        
        int last_DFS_start = -1;
        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            // connect disconnected graph
            if (last_DFS_start != -1) {
                for (int j = i-1; j >= 0; j--) {
                    if (!in_targets[j]) {
                        add_to_targets(j, i, -1, -1);
                        break;
                    }
                }
                if (num_comparisons == max_comparison) break;
            }
            // run DFS
            DFS(i);
            last_DFS_start = i;
            if (num_comparisons == max_comparison) break;
        }
        
        // break if no change
        if (num_comparisons == 0) break;
        
        // send query
        cout << ""q "" << num_comparisons << endl;
        for (int i = 0; i < num_comparisons; i++) {
             cout << comparison_targets[i].first << "" < "" << comparison_targets[i].second << endl;
        }
        
        // receive input
        for (int i = 0; i < num_comparisons; i++) {
            int ans;
            cin >> ans;
            
            // get 2 target nodes
            int a, b; // a <= b
            if (ans == 1) {
                a = comparison_targets[i].first;
                b = comparison_targets[i].second;
            }
            else {
                a = comparison_targets[i].second;
                b = comparison_targets[i].first;
            }
            // get caller and option
            int caller = comparison_caller[i].first;
            int option = comparison_caller[i].second;
            
            // connect two nodes
            //cout << ""--edge created between "" << a << "" -> "" << b << endl;
            nodes[a].next.push_back(b);
            nodes[b].prev.push_back(a);
            
            if (caller == -1) {
                // called to connect disconnected graphs
                // do nothing
            }
            else if (option == 1) {
                // called from caller's prev
                auto to_remove = find(nodes[caller].prev.begin(), nodes[caller].prev.end(), a);
                nodes[caller].prev.erase(to_remove);
                to_remove = find(nodes[a].next.begin(), nodes[a].next.end(), caller);
                nodes[a].next.erase(to_remove);
            }
            else if (option == 2) {
                // called from caller's next
                auto to_remove = find(nodes[caller].next.begin(), nodes[caller].next.end(), b);
                nodes[caller].next.erase(to_remove);
                to_remove = find(nodes[b].prev.begin(), nodes[b].prev.end(), caller);
                nodes[b].prev.erase(to_remove);
            }
        }
    }
    if (num_comparisons == 0) {
        // start from the very first
        int current = 0;
        while (nodes[current].prev.size() != 0) {
            current = nodes[current].prev[0];
        }
        cout << ""a "";
        while (nodes[current].next.size() != 0) {
            cout << current << "" "";
            current = nodes[current].next[0];
        }
        cout << current;
        cout << endl;
    }
    int result;
    cin >> result;
    cout << flush;

    return 0;
}
",,judging,C++17,2022-07-30 15:53:16.72531,0
344,TeamJin,1,1009,"import turtle
import random

turtle.screensize(80,24)
screen = turtle.Screen()

# Creates a night color background
screen.bgcolor(""midnight blue"")
screen.title(""My Movie"")
tpen = turtle.Turtle()
tpen.hideturtle()
tpen.speed(1000000000000)

# Function to create stars
def star(x,y):
    tpen.penup()
    tpen.goto(x,y)
    tpen.pendown()
    turtle.colormode(255)
    tpen.pencolor(random.randint(0,255),
                  random.randint(0,255),
                  random.randint(0,255))
    
    for i in range(5):
        tpen.forward(10)
        tpen.right(144)

# Function to create moon
def moon():
    tpen.up()
    tpen.goto(200,140)
    tpen.down()
    tpen.color(""honeydew"")
    tpen.begin_fill()
    tpen.circle(80)
    tpen.end_fill()
 
# Function to create moolight effect   
def moonlight(x_moonlight,y_moonlight,c_light):
    tpen.up()
    tpen.goto(x_moonlight,y_moonlight)
    tpen.down()
    tpen.color(""silver"")
    tpen.circle(c_light)

# Function to create land
def land():
    tpen.penup()
    tpen.goto(-360,-200)
    tpen.pendown()
    tpen.color(""dark slate gray"")
    tpen.begin_fill()
    
    for i in range(4):
        tpen.forward(720)
        tpen.right(90)
    
    tpen.end_fill()

# Function to create Left Mountain
def left_mountain():
    tpen.penup()
    tpen.goto(-410,-201)
    tpen.pendown()
    tpen.color(""gray"")
    tpen.begin_fill()
    
    for i in range(3):
        tpen.forward(300)
        tpen.left(120)
    
    tpen.end_fill()

    # Snow cap on left Mountain
    tpen.penup()
    tpen.goto(-300, -10)
    tpen.pendown()
    tpen.color(""dark gray"")
    tpen.begin_fill()
    tpen.left(30)
    tpen.forward(25)
    tpen.right(60)
    tpen.forward(25)
    tpen.left(60)
    tpen.forward(32)
    tpen.left(90)
    tpen.forward(60)
    tpen.right(120)
    tpen.end_fill()

# Function to create Right Mountain
def right_mountain():
    tpen.penup()
    tpen.goto(100,-201)
    tpen.pendown()
    tpen.color(""gray"")
    tpen.begin_fill()
    
    for i in range(3):
        tpen.forward(300)
        tpen.left(120)
    
    tpen.end_fill()
    
    # Snow cap on right Mountain
    tpen.penup()
    tpen.goto(210, -10)
    tpen.pendown()
    tpen.color(""dark gray"")
    tpen.begin_fill()
    tpen.left(30)
    tpen.forward(25)
    tpen.right(60)
    tpen.forward(25)
    tpen.left(60)
    tpen.forward(32)
    tpen.left(90)
    tpen.forward(60)
    tpen.right(120)
    tpen.end_fill()

# Function to create Middle Mountain
def middle_mountain():
    tpen.penup()
    tpen.goto(-190,-201)
    tpen.pendown()
    tpen.color(""dim gray"")
    tpen.begin_fill()
    
    for i in range(3):
        tpen.forward(350)
        tpen.left(120)
    
    tpen.end_fill()
    
    # Snow cap on middle Mountain
    tpen.penup()
    tpen.goto(-55, 34)
    tpen.pendown()
    tpen.color(""gray"")
    tpen.begin_fill()
    tpen.left(30)
    tpen.forward(25)
    tpen.right(60)
    tpen.forward(25)
    tpen.left(60)
    tpen.forward(32)
    tpen.left(90)
    tpen.forward(60)
    tpen.right(120)
    tpen.end_fill()

# Function that create trees
def tree(x,y):
    tpen.penup()
    tpen.goto(x,y)
    tpen.pendown()
    tpen.color(""saddle brown"")
    tpen.left(90)
    tpen.forward(25)
    
    # Left Tree Branches
    tpen.left(60)
    tpen.forward(20)
    tpen.left(30)
    tpen.forward(15)
    # Tree Leaves
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.backward(15)
    tpen.right(60)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.right(30)
    
    # Middle Tree Branches
    tpen.penup()
    tpen.goto(x,y+25)
    tpen.pendown()
    tpen.forward(20)
    tpen.left(30)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.backward(15)
    tpen.right(60)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.left(30)
    
    # Right Tree Branches
    tpen.penup()
    tpen.goto(x,y+25)
    tpen.pendown()
    tpen.right(60)
    tpen.forward(20)
    tpen.left(30)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.backward(15)
    tpen.right(60)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")

# Function that create my initials
def my_initials():
    
    # Create J
    tpen.penup()
    tpen.goto(290,-305)
    tpen.pendown()
    tpen.pensize(2)
    tpen.pencolor(""alice blue"")
    #--------------------------
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(7)
    tpen.right(90)
    tpen.forward(2)
    tpen.left(180)
    
    # Create L
    tpen.penup()
    tpen.goto(305,-305)
    tpen.pendown()
    #--------------------------
    tpen.forward(20)
    tpen.left(90)
    tpen.forward(10)
    
    # Create first 7
    tpen.penup()
    tpen.goto(317,-305)
    tpen.pendown()
    #--------------------------
    tpen.forward(10)
    tpen.right(110)
    tpen.forward(20)
    tpen.left(110)
    
    # Create second 7
    tpen.penup()
    tpen.goto(330,-305)
    tpen.pendown()
    #--------------------------
    tpen.forward(10)
    tpen.right(110)
    tpen.forward(20)
    

# ------- MAIN ------- #

####### Create stars in random positions #######
for i in range(100):
    
    # generating random integer values for x and y
    x = random.randint(-330, 300)
    y = random.randint(-50, 330)

    # Insert x and y into function to create stars
    star(x,y)


# Function that creates the Moon and moon light
moon()
x_moonlight = 200
y_moonlight = 140
c_light = 80

# For loop creates multiple moonlight rings
for i in range(30):
    y_moonlight -= 35
    c_light += 35
    moonlight(x_moonlight,y_moonlight,c_light)


# Function that creates Plain Land
land()

# Functions that will create the Left, Middle and Right Mountains
middle_mountain()
left_mountain()
right_mountain()

####### Create trees in random positions #######
for j in range(40):
    
    # generating random integer values for x and y
    x = random.randint(-310, 310)
    y = random.randint(-320, -210)

    # Insert x and y into function to create trees
    tree(x,y)

# Function that will create my initials
my_initials()

screen.exitonclick()","/code/Main.cpp:7:3: error: invalid preprocessing directive #Creates
    7 | # Creates a night color background
      |   ^~~~~~~
/code/Main.cpp:14:3: error: invalid preprocessing directive #Function
   14 | # Function to create stars
      |   ^~~~~~~~
/code/Main.cpp:28:3: error: invalid preprocessing directive #Function
   28 | # Function to create moon
      |   ^~~~~~~~
/code/Main.cpp:38:3: error: invalid preprocessing directive #Function
   38 | # Function to create moolight effect
      |   ^~~~~~~~
/code/Main.cpp:46:3: error: invalid preprocessing directive #Function
   46 | # Function to create land
      |   ^~~~~~~~
/code/Main.cpp:60:3: error: invalid preprocessing directive #Function
   60 | # Function to create Left Mountain
      |   ^~~~~~~~
/code/Main.cpp:74:7: error: invalid preprocessing directive #Snow
   74 |     # Snow cap on left Mountain
      |       ^~~~
/code/Main.cpp:91:3: error: invalid preprocessing directive #Function
   91 | # Function to create Right Mountain
      |   ^~~~~~~~
/code/Main.cpp:105:7: error: invalid preprocessing directive #Snow
  105 |     # Snow cap on right Mountain
      |       ^~~~
/code/Main.cpp:122:3: error: invalid preprocessing directive #Function
  122 | # Function to create Middle Mountain
      |   ^~~~~~~~
/code/Main.cpp:136:7: error: invalid preprocessing directive #Snow
  136 |     # Snow cap on middle Mountain
      |       ^~~~
/code/Main.cpp:153:3: error: invalid preprocessing directive #Function
  153 | # Function that create trees
      |   ^~~~~~~~
/code/Main.cpp:162:7: error: invalid preprocessing directive #Left
  162 |     # Left Tree Branches
      |       ^~~~
/code/Main.cpp:167:7: error: invalid preprocessing directive #Tree
  167 |     # Tree Leaves
      |       ^~~~
/code/Main.cpp:178:7: error: invalid preprocessing directive #Leaves
  178 |     # Leaves of the Tree
      |       ^~~~~~
/code/Main.cpp:188:7: error: invalid preprocessing directive #Middle
  188 |     # Middle Tree Branches
      |       ^~~~~~
/code/Main.cpp:195:7: error: invalid preprocessing directive #Leaves
  195 |     # Leaves of the Tree
      |       ^~~~~~
/code/Main.cpp:206:7: error: invalid preprocessing directive #Leaves
  206 |     # Leaves of the Tree
      |       ^~~~~~
/code/Main.cpp:216:7: error: invalid preprocessing directive #Right
  216 |     # Right Tree Branches
      |       ^~~~~
/code/Main.cpp:224:7: error: invalid preprocessing directive #Leaves
  224 |     # Leaves of the Tree
      |       ^~~~~~
/code/Main.cpp:235:7: error: invalid preprocessing directive #Leaves
  235 |     # Leaves of the Tree
      |       ^~~~~~
/code/Main.cpp:244:3: error: invalid preprocessing directive #Function
  244 | # Function that create my initials
      |   ^~~~~~~~
/code/Main.cpp:247:7: error: invalid preprocessing directive #Create
  247 |     # Create J
      |       ^~~~~~
/code/Main.cpp:253:6: error: invalid preprocessing directive #--
  253 |     #--------------------------
      |      ^~
/code/Main.cpp:263:7: error: invalid preprocessing directive #Create
  263 |     # Create L
      |       ^~~~~~
/code/Main.cpp:267:6: error: invalid preprocessing directive #--
  267 |     #--------------------------
      |      ^~
/code/Main.cpp:272:7: error: invalid preprocessing directive #Create
  272 |     # Create first 7
      |       ^~~~~~
/code/Main.cpp:276:6: error: invalid preprocessing directive #--
  276 |     #--------------------------
      |      ^~
/code/Main.cpp:282:7: error: invalid preprocessing directive #Create
  282 |     # Create second 7
      |       ^~~~~~
/code/Main.cpp:286:6: error: invalid preprocessing directive #--
  286 |     #--------------------------
      |      ^~
/code/Main.cpp:292:3: error: invalid preprocessing directive #--
  292 | # ------- MAIN ------- #
      |   ^~
/code/Main.cpp:294:1: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      | ^~
/code/Main.cpp:294:3: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      |   ^~
/code/Main.cpp:294:5: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      |     ^~
/code/Main.cpp:294:7: error: stray ‘#’ in program
  294 | ####### Create stars in random positions #######
      |       ^
/code/Main.cpp:294:42: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      |                                          ^~
/code/Main.cpp:294:44: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      |                                            ^~
/code/Main.cpp:294:46: error: stray ‘##’ in program
  294 | ####### Create stars in random positions #######
      |                                              ^~
/code/Main.cpp:294:48: error: stray ‘#’ in program
  294 | ####### Create stars in random positions #######
      |                                                ^
/code/Main.cpp:297:7: error: invalid preprocessing directive #generating
  297 |     # generating random integer values for x and y
      |       ^~~~~~~~~~
/code/Main.cpp:301:7: error: invalid preprocessing directive #Insert; did you mean #assert?
  301 |     # Insert x and y into function to create stars
      |       ^~~~~~
      |       assert
/code/Main.cpp:305:3: error: invalid preprocessing directive #Function
  305 | # Function that creates the Moon and moon light
      |   ^~~~~~~~
/code/Main.cpp:311:3: error: invalid preprocessing directive #For
  311 | # For loop creates multiple moonlight rings
      |   ^~~
/code/Main.cpp:318:3: error: invalid preprocessing directive #Function
  318 | # Function that creates Plain Land
      |   ^~~~~~~~
/code/Main.cpp:321:3: error: invalid preprocessing directive #Functions
  321 | # Functions that will create the Left, Middle and Right Mountains
      |   ^~~~~~~~~
/code/Main.cpp:326:1: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      | ^~
/code/Main.cpp:326:3: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      |   ^~
/code/Main.cpp:326:5: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      |     ^~
/code/Main.cpp:326:7: error: stray ‘#’ in program
  326 | ####### Create trees in random positions #######
      |       ^
/code/Main.cpp:326:42: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      |                                          ^~
/code/Main.cpp:326:44: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      |                                            ^~
/code/Main.cpp:326:46: error: stray ‘##’ in program
  326 | ####### Create trees in random positions #######
      |                                              ^~
/code/Main.cpp:326:48: error: stray ‘#’ in program
  326 | ####### Create trees in random positions #######
      |                                                ^
/code/Main.cpp:329:7: error: invalid preprocessing directive #generating
  329 |     # generating random integer values for x and y
      |       ^~~~~~~~~~
/code/Main.cpp:333:7: error: invalid preprocessing directive #Insert; did you mean #assert?
  333 |     # Insert x and y into function to create trees
      |       ^~~~~~
      |       assert
/code/Main.cpp:336:3: error: invalid preprocessing directive #Function
  336 | # Function that will create my initials
      |   ^~~~~~~~
/code/Main.cpp:1:1: error: ‘import’ does not name a type
    1 | import turtle
      | ^~~~~~
/code/Main.cpp:1:1: note: C++20 ‘import’ only available with ‘-fmodules-ts’
",CERR,C++17,2022-07-30 15:53:29.553491,0
375,datOvercommon,1,1005,"#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <queue>
#include <random>

using namespace std;

int randomindex(int start, int end)
{
	std::random_device dev;
	std::mt19937 rng(dev());
	std::uniform_int_distribution<std::mt19937::result_type> dist6(start, end); // distribution in range [1, 6]

	return dist6(rng);
}

class node {
public:
	int index, count = 0;
	vector<node*> lesser;
	node(int ind) : index(ind) { }
	int height(node* i, int height)
	{
		if (i->lesser.size() == 0) return 1;
		while (lesser.size() != 0)
		{
			int max = 0;
			for (auto& k : i->lesser)
			{
				if (i->height(k, height) > max) max = i->height(k, height);
			}
			return 1 + max;
		}
	}
};
bool lessThanKey(const node* n1, const node* n2)
{
	return n1->count > n2->count;
}
int sorted(vector<node*>& nodes, int& n)
{
	for (int i = 0; i < nodes.size(); i++)
	{
		if (nodes[i]->height(nodes[i], 1) == n) return i;
	}
	return -1;
}
int main()
{
	vector<node*> nodes;
	int n, m,temp;
	cin >> n;
	if (n == -1) return 0;
	cin >> m;
	if (n == -1) return 0;

	for (int i = 0; i < n; i++) 
	{ 
		node* newnode = new node(i);
		nodes.push_back(newnode);
	}

	for (int k = 1; k < n*10; k++)
	{
		vector<pair<node*, node*>> nodepairs;
		int index = randomindex(0,1);
		for (int i = 0; i < n / 2; i++)
		{
			nodepairs.push_back({ nodes[index], nodes[index+1] });
			index += 2;
		}
		cout << ""q "" << n / 2 << endl;
		for (auto& i : nodepairs) cout << i.first->index << "" > "" << i.second->index << endl;
		for (auto& i : nodepairs)
		{
			cin >> temp;
			if (temp == -1) return 0;
			if (temp == 1) { i.first->lesser.push_back(i.second); ++i.first->count; --i.second->count;}
			else { i.second->lesser.push_back(i.first); ++i.second->count; --i.first->count;}
		}
		sort(nodes.begin(),nodes.end(),lessThanKey);
		if (sorted(nodes, n) != -1)
		{
			vector<int> ordered;
			node* iterate = nodes[sorted(nodes, n)];
			ordered.push_back(iterate->index);
			while (iterate->lesser.size() != 0)
			{
				int maxheight = 0,max,index = 0;
				for (auto i : iterate->lesser)
				{
					if (i->height(i, 1) > maxheight)
					{
						maxheight = i->height(i, 1);
						max = index;
					}
					++index;
				}
				iterate = iterate->lesser[max];
				ordered.push_back(iterate->index);
			}
			reverse(ordered.begin(), ordered.end());
			cout << ""a "";
			for (int i = 0; i < ordered.size() - 1; i++) cout << ordered[i] << "" "";
			cout << ordered[ordered.size() - 1] << endl;
			cin >> temp;
			break;
		}
	}
	return 0;
}

",,judging,C++17,2022-07-30 16:05:39.384473,0
376,theKevin27,1,1008,"#include <iostream> //for input and output
#include <string> //for strings :D
using namespace std; //because ive only 25 minutes left

//CHOOSE YOUR OWN ADVENTURE GAME//

int main() {
  //Interface information

  //START//
  cout << ""You wake up in a forest without any clue of where you are"" << endl;
  cout << ""You find yourself unable to look or move in more than 4 directions"" << endl;

  //check to see if player is alive
  bool alive = 1;
  //PLAYER DIRECTIONS
  do {
    char MoL, m, l; //player inputs for movement and looking
    cout << ""Move (m) or look (l)?"" << endl;
    cin >> MoL; //move or look char
    //If player decides to move//
    if(MoL == 'm'){
      cout << ""Choose a direction to move, (n, e, s, w)"" << endl;
      cin >> m;
      if(m == 'n') {
        cout << ""You walk North"" << endl;
        cout << ""5 minutes left until submission"" << endl;
        alive = 0; //this kills the player and ends the game
      }
      else if(m == 'e') {
        cout << ""You walk East"" << endl;
        cout << ""You enter a nuclear warzone"" << endl;
        cout << ""You gaze upon the sky as ash falls"" << endl;
        cout << ""A bomb gets dropped down your gullet"" << endl;
        alive = 0;
      }
      else if(m == 's') {
        cout << ""You walk South"" << endl;
        cout << ""You enter a den of lions"" << endl;
        alive = 0;
      }
      else if(m == 'w') {
        cout << ""You walk West"" << endl;
        cout << ""You enter a black hole"" << endl;
        alive = 0;
      }
    //If player decides to look//
    else if(MoL == 'l') {
      if(m == 'l') {
        cout << ""You look North"" << endl;
        cout << ""You see a fiery inferno so bright that your eyes melt off"" << endl;
        alive = 0;
      }
      else if(l == 'e') {
        cout << ""You look East"" << endl;
        cout << ""Your eyes are met by two small glowing dots"" << endl;
        cout << ""You have been mauled by a wolf"" << endl;
        alive = 0;
      }
      else if(l == 's') {
        cout << ""You look South"" << endl;
        cout << ""The screen turns black and you see yourself in the monitors reflection"" << endl;
        cout << ""You are reminded of how much of a loser you are before you weep until you're fully dehydrated"" << endl;
        alive = 0;
        
      }
      else if(l == 'w') {
        cout << ""You look West"" << endl;
        cout << ""I am running out of time so you just die thanks"" << endl;
        alive = 0;
      }
    }
  }
}
  while(alive);
    //death screen//
    if(alive == 0) { 
     cout << ""You have died a tragic death and nobody will remember you"" << endl;
    }
}",,judging,C++17,2022-07-30 16:06:20.448426,0
345,FuduBoys,1,1007,"#include <cstring>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
struct strut {

  long start, end;
  std::string color;
};

int main(int argc, char *argv[]) {

  long n, q;
  std::cin >> n >> q;
  std::vector<strut> vec;
  // std::cout << ""n is "" << n << ""q is "" << q << '\n';

  for (auto count = 0; count < q; count++) {
    // std::cout << ""running"" << count << ""time"" << '\n';
    std::string query_input = """";
    std::string retVAL;
    // std::cout << ""query string is "" << query_input << '\n';
    std::cin >> query_input;
    if (query_input == ""p"") {
      // std::stringstream s(query_input);
      // std::string temp1, color;
      long start, end;
      std::string color;
      // s >> temp1; // takes out the first p
      // s >> start;
      // s >> end;
      // s >> color;
      std::cin >> start;
      std::cin >> end;
      std::cin >> color;
      strut temp;
      temp.color = color;
      temp.end = end;
      temp.start = start;
      vec.push_back(temp);
      continue;
    } else {
      long number;
      std::cin >> number;
      // s >> temp; // throws away q
      // s >> number;
      for (auto &x : vec) {
        if (number >= x.start && number <= x.end) {
          retVAL = x.color;
        }
      }
      if (retVAL == """") {
        std::cout << ""white\n"";
      } else {
        std::cout << retVAL << '\n';
      }
    }
  }

  return 0;
}
","Failed on case 3, test 0",TLE,C++17,2022-07-30 15:53:52.081468,40
346,teamAverage,1,1008,"#include <iostream>
#include <cassert>

using namespace std;

//move n disks from source to destination using a temporary
void move(int n, char source, char dest, char temp){
    if(n==1){
        cout << ""move from"" << source << ""to"" << dest << endl;
    }
    move(n-1, source, temp, dest);
    move(1, source, dest, temp);
    move(n-1, temp, dest, source);
}

//Let M(n) be the number of moves given n disks
//M(1) = 1, M(2) = 3
//M(n) = M(n-1) + M(1) + M(n-1)
//for n>1, M(n) = 2M(n-1) + M(1)
//M(3) = 2M(2) + 1 = 2 x 3 + 1 = 7
//M(4) = 2M(3) + 1 = 15         
//M(5) = 2M(4) + 1 = 31             M(n) = 2^n - 1 for all n>1, O(2^n)

int main(){
    int n;
    cout << ""Enter # of disks on tower > "";
    cin >> n;
    assert(n>0); //if false, terminates the program
    cout << ""n source is A and destination is C"" << endl;

    move(n, 'A', 'C', 'B');
    return 0;
}",Only your latest submission will be checked,AC,C++17,2022-07-30 15:54:10.517232,10
347,teamAverage,1,1005,"using namespace std;
#include <iostream>

int main() {
  int n,nRes, m, ind, trial = 1,temp, x=0, comparison;
  int numOfComparison ;
  cin >> n;
  cin >> m;
  numOfComparison = n/2;
  int indexes[n],indexesP[n],comparisonRes[numOfComparison];
  for (int i = 0; i < n; i++) {
    indexes[i] = i;
  }
  while (comparison<=n*(n-1)/2&&trial<=m) {
    if(trial%2 == 1){
      x=0;
      cout<<""q ""<<numOfComparison<<endl;
      for(int i=0;i<numOfComparison;i++){
        cout<<indexes[x++];
        cout<<"" < ""<<indexes[x++]<<endl;
      }
      for(int i=0;i<numOfComparison;i++){
        cin>>comparisonRes[i];
        comparison++;
        if (comparisonRes[i]==-1){
          return;
        }
      }
      for(int i=0;i<numOfComparison;i++){
        if (comparisonRes[i]==0){
          temp = indexes[i*2];
          indexes[i*2] = indexes[i*2+1];
          indexes[i*2+1] = temp;
        }
      }
      
    }
    else{
      x=n;
      cout<<""q ""<<numOfComparison<<endl;
      for(int i=numOfComparison-1;i>=0;i--){
        cout<<indexes[x--];
        cout<<"" > ""<<indexes[x--]<<endl;
      }
      for(int i=numOfComparison-1;i>=0;i--){
        cin>>comparisonRes[i];
        comparison++;
        if (comparisonRes[i]==-1){
          return;
        }
      }

      for(int i=numOfComparison-1;i>=0;i--){
        if (comparisonRes[i]==0){
          temp = indexes[n-i*2-1];
          indexes[n-i*2-1] = indexes[n-i*2-2];
          indexes[n-i*2-2] = temp;
        }
      }

    }
    
    trial++;
    
  }
  cout<<""a "";
  for (int i=0;i<n;i++){
    cout<<indexes[i]<<"" "";
  }
  cout<<endl;
  cin>>nRes;
  return;
}
","/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:26:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   26 |           return;
      |           ^~~~~~
/code/Main.cpp:49:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   49 |           return;
      |           ^~~~~~
/code/Main.cpp:72:3: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   72 |   return;
      |   ^~~~~~
/code/Main.cpp:5:18: warning: unused variable ‘ind’ [-Wunused-variable]
    5 |   int n,nRes, m, ind, trial = 1,temp, x=0, comparison;
      |                  ^~~
/code/Main.cpp:10:18: warning: unused variable ‘indexesP’ [-Wunused-variable]
   10 |   int indexes[n],indexesP[n],comparisonRes[numOfComparison];
      |                  ^~~~~~~~
",CERR,C++17,2022-07-30 15:54:13.867564,0
348,JavaScriptJatts,1,1005,"#include <bits/stdc++.h>

using namespace ::std;

void merge(vector<int>& arr, int start, int mid, int end){

    if(start>=end){return;}

    vector<int> temp;

    int start1 = start;
    int start2 = mid+1;

    while(start1 <= mid && start2 <= end){
        cout << ""q 1\n"";
        cout << start1 << "" < "" << start2 << ""\n"";
        int ans;
        cin >> ans;

        if(ans == -1){throw std::invalid_argument( ""received negative value"" );}

        if(ans == 1){
            temp.push_back(arr[start1]);
            start1++;
        }
        else{
            temp.push_back(arr[start2]);
            start2++;
        }
    }

    while(start1 <= mid){
        temp.push_back(arr[start1]);
        start1++;
    }

    while(start2 <= end){
        temp.push_back(arr[start2]);
        start2++;
    }

    for(int i = 0; i < temp.size(); i++){
        arr[start+i] = temp[i];
    }


    return;
}

void mergeSort(vector<int>& arr, int start, int end){


//    cout << start << "" "" << end << endl;

    if(start >= end){return;}

    int mid = start+((end-start)/2);

    mergeSort(arr, start, mid);
    mergeSort(arr, mid+1, end);

    try {
        merge(arr,start, mid,end);
    }
    catch( const std::invalid_argument& e ) {
        throw std::invalid_argument( ""received negative value"" );
    }


    return;

}



int main() {

    int n,m;

    cin >> n >> m;


    vector<int> arr;

    for(int i = 0; i < n; i++){
        arr.push_back(i);
    }

    try {
        mergeSort(arr,0,arr.size()-1);
    }
    catch( const std::invalid_argument& e ) {
        return(0);
    }


    string l = ""a"";

    for(int x : arr){
        l += "" "";
        l += to_string(x);
    }

    cout << l;

    cin >> n;

    return(0);
//    return(n);

}

// \o/
//  |
// /_\_","WA on case 0, test 0",WA,C++17,2022-07-30 15:54:29.880286,0
349,datOvercommon,1,1006,"n=int(input())
for i in range(n+1):
    print(' ',end='')
print('>')
for i in range(n+1):
    print(' ',end='')
print('|')
for i in range(n+1):
    print(' ',end='')
print('.')
l=n
t=1
while l-1>0:
    for i in range(l):
        print(' ',end='')
    print('/',end='')
    for i in range(65,65+t):
        print(chr(i),end='')
    for i in range(64+t-1,64,-1):
        print(chr(i),end='')
    print('\\')
    l-=1
    t+=1","",AC,Python3,2022-07-30 15:54:50.512675,50
350,JavaScriptJatts,1,1005,"#include <bits/stdc++.h>

using namespace ::std;

void merge(vector<int>& arr, int start, int mid, int end){

    if(start>=end){return;}

    vector<int> temp;

    int start1 = start;
    int start2 = mid+1;

    while(start1 <= mid && start2 <= end){
        cout << ""q 1\n"";
        cout << start1 << "" < "" << start2 << ""\n"";
        int ans;
        cin >> ans;

        if(ans == -1){throw std::invalid_argument( ""received negative value"" );}

        if(ans == 1){
            temp.push_back(arr[start1]);
            start1++;
        }
        else{
            temp.push_back(arr[start2]);
            start2++;
        }
    }

    while(start1 <= mid){
        temp.push_back(arr[start1]);
        start1++;
    }

    while(start2 <= end){
        temp.push_back(arr[start2]);
        start2++;
    }

    for(int i = 0; i < temp.size(); i++){
        arr[start+i] = temp[i];
    }


    return;
}

void mergeSort(vector<int>& arr, int start, int end){


//    cout << start << "" "" << end << endl;

    if(start >= end){return;}

    int mid = start+((end-start)/2);

    mergeSort(arr, start, mid);
    mergeSort(arr, mid+1, end);

    try {
        merge(arr,start, mid,end);
    }
    catch( const std::invalid_argument& e ) {
        throw std::invalid_argument( ""received negative value"" );
    }


    return;

}



int main() {

    int n,m;

    cin >> n >> m;


    vector<int> arr;

    for(int i = 0; i < n; i++){
        arr.push_back(i);
    }

    try {
        mergeSort(arr,0,arr.size()-1);
    }
    catch( const std::invalid_argument& e ) {
        return(0);
    }


    string l = ""a"";

    for(int x : arr){
        l += "" "";
        l += to_string(x);
    }

    cout << l << endl;

    cin >> n;

    return(0);
//    return(n);

}

// \o/
//  |
// /_\_","WA on case 0, test 2","",C++17,2022-07-30 15:54:51.974421,0
351,teamAverage,1,1005,"using namespace std;
#include <iostream>

int main() {
  int n,nRes, m, ind, trial = 1,temp, x=0, comparison;
  int numOfComparison ;
  cin >> n;
  cin >> m;
  numOfComparison = n/2;
  int indexes[n],indexesP[n],comparisonRes[numOfComparison];
  for (int i = 0; i < n; i++) {
    indexes[i] = i;
  }
  while (comparison<n*(n-1)/2&&trial<=m) {
    if(trial%2 == 1){
      x=0;
      cout<<""q ""<<numOfComparison<<endl;
      for(int i=0;i<numOfComparison;i++){
        cout<<indexes[x++];
        cout<<"" < ""<<indexes[x++]<<endl;
      }
      for(int i=0;i<numOfComparison;i++){
        cin>>comparisonRes[i];
        comparison++;
        if (comparisonRes[i]==-1){
          return;
        }
      }
      for(int i=0;i<numOfComparison;i++){
        if (comparisonRes[i]==0){
          temp = indexes[i*2];
          indexes[i*2] = indexes[i*2+1];
          indexes[i*2+1] = temp;
        }
      }
      
    }
    else{
      x=n;
      cout<<""q ""<<numOfComparison<<endl;
      for(int i=numOfComparison-1;i>=0;i--){
        cout<<indexes[x--];
        cout<<"" > ""<<indexes[x--]<<endl;
      }
      for(int i=numOfComparison-1;i>=0;i--){
        cin>>comparisonRes[i];
        comparison++;
        if (comparisonRes[i]==-1){
          return;
        }
      }

      for(int i=numOfComparison-1;i>=0;i--){
        if (comparisonRes[i]==0){
          temp = indexes[n-i*2-1];
          indexes[n-i*2-1] = indexes[n-i*2-2];
          indexes[n-i*2-2] = temp;
        }
      }

    }
    
    trial++;
    
  }
  cout<<""a "";
  for (int i=0;i<n;i++){
    cout<<indexes[i]<<"" "";
  }
  cout<<endl;
  cin>>nRes;
  return;
}
","/code/Main.cpp: In function ‘int main()’:
/code/Main.cpp:26:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   26 |           return;
      |           ^~~~~~
/code/Main.cpp:49:11: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   49 |           return;
      |           ^~~~~~
/code/Main.cpp:72:3: error: return-statement with no value, in function returning ‘int’ [-fpermissive]
   72 |   return;
      |   ^~~~~~
/code/Main.cpp:5:18: warning: unused variable ‘ind’ [-Wunused-variable]
    5 |   int n,nRes, m, ind, trial = 1,temp, x=0, comparison;
      |                  ^~~
/code/Main.cpp:10:18: warning: unused variable ‘indexesP’ [-Wunused-variable]
   10 |   int indexes[n],indexesP[n],comparisonRes[numOfComparison];
      |                  ^~~~~~~~
",CERR,C++17,2022-07-30 15:55:01.461246,0
352,PinesCyrex,1,1008,"""""""
This is a maze game. The player starts in a Certain position and has to reach the goal.
The player can only move in 4 directions: up, down, left and 2 spaces to the right.
The player can't go out of the maze.
The player can't go back to the previous position. (A wall will spawn in the previous position)

You need to plan carefully how to move around the maze otherwise you will lock yourself in.

""#"" marks walls. ""P"" marks the player. ""G"" marks the goal.
an empty space marks a traversible path.
""""""
import random

# Global variables
width = 80
height = 26
maze = []
isGameNotOver = True

#[height, width]
playerPosition = [20, 20]

def initMaze():
    """"""
    Generates the canvas for the maze
    """"""
    global maze
    for i in range(height):
        maze.append([])
        for j in range(width):
            maze[i].append(0)


def initWalls():
    """"""
    create walls by setting the maze[i][j] to 1
    places them randomly because of time constraints
    10/10 times so far it is a solvable maze
    """"""
    global maze

    # funny number of walls
    for i in range(420):
        x = random.randint(0, height - 1)
        y = random.randint(0, width - 1)
        maze[x][y] = 1


def initGoal():
    """"""
    create goal by setting the maze[i][j] to 2
    also place it randomly
    """"""
    global maze

    x = random.randint(0, height - 1)
    y = random.randint(0, width - 1)
    maze[x][y] = 2


def initPlayer():
    """"""
    Plop the player in the maze
    """"""
    global playerPosition
    global maze
    maze[playerPosition[0]][playerPosition[1]] = 3


def printMaze():
    """"""
    Prints the maze
    maze[i][j] == 0 indicates an open space
    maze[i][j] == 1 indicates a wall
    maze[i][j] == 2 indicates the goal
    maze[i][j] == 3 indicates the player
    """"""

    global maze
    for i in range(height):
        for j in range(width):
            if (maze[i][j] == 0):
                print("" "", end="""")
            elif (maze[i][j] == 1):
                print(""#"", end="""")
            elif (maze[i][j] == 2):
                print(""G"", end="""")
            elif (maze[i][j] == 3):
                print(""P"", end="""")
        print()


def performMove(move: str):
    """"""
    move is expected to be a string of length 1
    """"""
    global isGameNotOver
    
    # mark where the player was as empty space
    maze[playerPosition[0]][playerPosition[1]] = 1

    # convert the move to uppercase to make it a bit more friendly for the user
    move = move.upper()

    # Move in the specified direction
    if (move == ""A""):
        playerPosition[1] -= 1
        
        # first check if we are out of bounds
        # then check if in a wall. Rest is the same
        if (playerPosition[1] < 0):
            playerPosition[1] += 1
        elif (maze[playerPosition[0]][playerPosition[1]] == 1):
            playerPosition[1] += 1
    elif (move == ""D""):
        playerPosition[1] += 1
        if (playerPosition[1] >= height):
            playerPosition[1] += 1
        elif (maze[playerPosition[0]][playerPosition[1]] == 1):
            playerPosition[1] -= 1
    elif (move == ""S""):
        playerPosition[0] += 1
        if (playerPosition[1] >= width):
            playerPosition[0] -= 1
        elif (maze[playerPosition[0]][playerPosition[1]] == 1):
            playerPosition[0] -= 1
    elif (move == ""W""):
        playerPosition[0] -= 1
        if (playerPosition[1] >= width):
            playerPosition[0] += 1
        elif (maze[playerPosition[0]][playerPosition[1]] == 1):
            playerPosition[0] += 1
    else:
        print(""Invalid move"")
        return

    # reached the Goal? if not, mark where the player is
    if(maze[playerPosition[0]][playerPosition[1]] == 2):
        isGameNotOver = False
    else:
        maze[playerPosition[0]][playerPosition[1]] = 3

def printVictory():
    """"""
    VICTORY SCREEEEEEECH !!!
    https://www.youtube.com/watch?v=MdN0NXgjsn8
    """"""
    print(""__   _______ _   _    ___ ______ _____   _    _ _____ _   _ _   _ ___________ _ "")
    print(""\ \ / |  _  | | | |  / _ \| ___ |  ___| | |  | |_   _| \ | | \ | |  ___| ___ | |"")
    print("" \ V /| | | | | | | / /_\ | |_/ | |__   | |  | | | | |  \| |  \| | |__ | |_/ | |"")
    print(""  \ / | | | | | | | |  _  |    /|  __|  | |/\| | | | | . ` | . ` |  __||    /| |"")
    print(""  | | \ \_/ | |_| | | | | | |\ \| |___  \  /\  /_| |_| |\  | |\  | |___| |\ \|_|"")
    print(""  \_/  \___/ \___/  \_| |_\_| \_\____/   \/  \/ \___/\_| \_\_| \_\____/\_| \_(_)"")
    print(""https://www.youtube.com/watch?v=MdN0NXgjsn8"")
                                                                                

def main():
    """"""
    the main function.
    Pieces together all the other functions to make the game work
    """"""
    global isGameNotOver
    initMaze()
    initWalls()
    initGoal()
    initPlayer()

    while (isGameNotOver):
        printMaze()
        print(""Enter your move (A, S, W, D): "")
        move = input()

        performMove(move)

    printVictory()
    printVictory()
    printVictory()
    printVictory()
    printVictory()
    print(""Give Full Points Please. Thank You!"")

# Run the main function if this is the main file
if __name__ == ""__main__"":
    main()

",Only your latest submission will be checked,AC,Python3,2022-07-30 15:55:12.241806,10
353,HS,1,1009,"#include <vector>
#include <string>
#include <ctime>
#include <iostream>
#include <Windows.h>
#include <cstdlib>
using namespace std;

int SW = 50;
int SH = 15;

vector<string> script = {
	""I am a fish......"",
	""A lonely fish in a quiet terminal......"",
	""I will perish as soon as this Strange contest is over......"",
	""What am I worth......?"",
	""10 points? 20? Or, maybe......"",
	""It will be a dream if my short life is worth 100 points......"",
	""If I get 100 points, I will live the rest of my short life in happiness......."",
	"".......At least until my program is over......."",
	""Hey, friend..... Will you give me 100 points?"",
	""It's my only dream......"",
	""And it seems like my life is almost over......."",
	""This would be the end. Bye.........""
};

int main()
{
	int loc_x = rand() % SW + 1;
	int loc_y = rand() % SH + 1+3;

	srand(time(NULL));
	int loop_ind = 0;
	while (true) {
		cout << endl;
		string s = script[(loop_ind / 7) % script.size()];
		cout << ""                 "" << s;
		for (int j = 0; j < loc_x + (loc_y*80); j++) {
			cout << "" "";
		}
		cout << ""<°)))><"" << endl;
		for (int i = 0; i < (SH - loc_y - 1)*80; i++) {
			cout << "" "";
		}
		cout << endl;

		loc_x += (rand() % 10 - 5)/4;
		loc_y += (rand() % 10 - 5)/4;
		loop_ind++;
		Sleep(1000);
	}

	return 0;
}
","/code/Main.cpp:5:10: fatal error: Windows.h: No such file or directory
    5 | #include <Windows.h>
      |          ^~~~~~~~~~~
compilation terminated.
",CERR,C++17,2022-07-30 15:55:13.215708,0
354,teamAverage,1,1008,"#include <iostream>
using namespace std;
string reverseString(string word);
int main() {
    cout << reverseString(""What the fuck is up kyle"");
}

string reverseString(string word){
    if (word.length() == 1)
        return word;
    else{
        string smallerWord = word.substr(0,word.length()-1);
        return word.at(word.length()-1) + reverseString(smallerWord);

    }
}
",Only your latest submission will be checked,AC,C++17,2022-07-30 15:55:34.892479,10
355,FuduBoys,1,1009,"",,judging,Python3,2022-07-30 15:56:19.570171,0
356,FuduBoys,1,1009,"print(""temp"")",Only your latest submission will be checked,AC,Python3,2022-07-30 15:57:28.423889,10
357,PinesCyrex,1,1005,"#include <iostream>
using namespace std;
int main() {
    int numcount;
    int guess;
    int judge = 0;
    bool isSolved = false;

    // int *nums = new int[numcount];
    int nums[10];
    for (int i = 0; i < 10; i++) {
        nums[i] = i;
    }

    cin >> numcount >> guess;
    for (int curr = 1; curr < numcount; curr++) {
        int j = curr;
        while(j >= 0 && judge == 0) {
            cout << ""q 1"" << endl;
            cout << nums[j-1] << "" < "" << nums[j] << endl;
            cin >> judge;
            if (judge == 0) {
                int temp = nums[j];
                nums[j] = nums[j-1];
                nums[j-1] = temp;
            } else if (judge == -1) {
                exit(0);
            }
            j--;
        }
    }

    string result = ""a"";
    for (int i = 0; i < numcount; i++) {
        result += "" "" + to_string(nums[i]);
    }

    cout << result;

    //delete[] nums;
    return 0;
}
","WA on case 0, test 0","",C++17,2022-07-30 15:57:34.933452,0
358,NKSquared,1,1006,"
n = int(input())


print("" ""*(n-1) + chr(62))
print("" ""*(n-1) + chr(124))
print("" ""*(n-1) + chr(46))

for i in range(1, n):
    print((n-1-i) * "" "" + ""/"", end = '')
    for j in range(i):
        print(chr(65 + j), end = '') 

    for j in range(i-1):
        print(chr(65 - j + i - 2), end = '') 

    print(""\\"")","",AC,Python3,2022-07-30 15:57:36.491286,50
361,TeamJin,1,1008,"import turtle
import random

# Description: The program creates stars base on the the amount of stars and length of sides of the stars inputed by the user.

# Setting the window's Screensize
turtle.screensize(80,24)

# Giving a name to the function
screen = turtle.Screen()

# Creates a night color background
screen.bgcolor(""midnight blue"")

# Giving a name to the window
screen.title(""My Movie"")

# Naming the turtle/pen
tpen = turtle.Turtle()

tpen.hideturtle()

# Setting the speed of the turtle
tpen.speed(10000)

#Defining a function to create stars where x and y is the coordinates in the window
def star(x,y,size):
    # while using penup() function, the turtle named tpen will not draw anything in the window
    tpen.penup()
    
    # goto() sends tpen to a specific coordinate in the window
    tpen.goto(x,y)
    
    # while using pendown() function, tpen will not draw anything in the window
    tpen.pendown()
    
    # colormode() allows users to enter RGB values into pencolor() to create desired colors
    turtle.colormode(255)
    
    # pencolor() is used to set the color of tpen with RGB values ---> ie. pencolor(0,0,0)
    # random.randit() randomly chooses an integer value between 0 - 255.
    tpen.pencolor(random.randint(0,255),
                  random.randint(0,255),
                  random.randint(0,255))
    
    s = size #length of each side of a star
    # Using for-loop to create a star
    for i in range(5):
        
        # forward() is used to tell tpen to move towards the direction it is pointing at
        # The values inside forward() is how much pixels will it move
        tpen.forward(s)
        
        # right() is used to change tpen's direction clockwise
        # The values in right() is the degree of how much it will change
        tpen.right(144)

# Function that creates S
def s():
    tpen.penup()
    tpen.goto(50,-50)
    tpen.pencolor(""white"")
    
    # fillcolor() fills the letter with the intended color
    tpen.fillcolor(""white"")
    
    # Initiates color filling at it's current coordinate
    tpen.begin_fill()
    tpen.pendown()
    tpen.right(90)
    tpen.forward(30)
    tpen.right(90)
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(20)
    tpen.left(90)
    tpen.forward(10)
    tpen.left(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(40)
    tpen.right(90)
    tpen.forward(5)
    tpen.right(90)
    tpen.forward(20)
    tpen.left(90)
    tpen.forward(8)
    tpen.left(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(27)
    tpen.right(90)
    tpen.forward(20)
    
    # Ends color filling at it's current coordinate
    tpen.end_fill()

# Function that creates F
def f():
    tpen.penup()
    tpen.goto(100,-50)
    tpen.pencolor(""white"")
    tpen.fillcolor(""white"")
    tpen.begin_fill()
    tpen.pendown()
    tpen.forward(40)
    tpen.right(90)
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(20)
    tpen.left(90)
    tpen.forward(5)
    tpen.left(90)
    tpen.forward(13)
    tpen.right(90)
    tpen.forward(8)
    tpen.right(90)
    tpen.forward(13)
    tpen.left(90)
    tpen.forward(16)
    tpen.right(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(39)
    tpen.right(90)
    tpen.end_fill()

# Function that creates U
def u():
    tpen.penup()
    tpen.goto(160,-50)
    tpen.pencolor(""white"")
    tpen.pendown()
    tpen.fillcolor(""white"")
    tpen.begin_fill()
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(30)
    tpen.left(90)
    tpen.forward(10)
    tpen.left(90)
    tpen.forward(30)
    tpen.right(90)
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(40)
    tpen.right(90)
    tpen.forward(35)
    tpen.right(90)
    tpen.forward(40)
    tpen.right(90)
    tpen.forward(5)
    tpen.end_fill() 

# Function that creates the red background of the SFU logo
def sfu():
    tpen.penup()
    tpen.goto(-200,100)
    tpen.pencolor(""red"")
    tpen.pendown()
    tpen.fillcolor(""red"")
    tpen.begin_fill()
    tpen.forward(400)
    tpen.right(90)
    tpen.forward(200)
    tpen.right(90)
    tpen.forward(400)
    tpen.right(90)
    tpen.forward(200)
    tpen.end_fill()
    
    # Calling out the s(), f() and u() functions
    s()
    f()
    u()
    
    # ------- MAIN ------- #

####### Create stars in random positions #######

# Asks user for input
stars = int(input(""Enter amount stars: ""))
size = int(input(""Enter length of side of star: ""))

for i in range(stars):
    # generating random integer values for x and y
    x = random.randint(-330, 300)
    y = random.randint(-330, 330)

    # Insert x and y into function to create stars
    star(x,y,size)


surprise = int(input(""Enter 1 for a surprise or 0 for none: ""))
if surprise == 1:
    sfu()

print(""Terminated..."")
screen.exitonclick()",Only your latest submission will be checked,AC,Python3,2022-07-30 15:58:17.64725,10
362,SoloGuy,1,1009,"
# Quite literally just says hello with your name as you input your name
a = [['.' for i in range(80)]for i in range(24)]

while True:
    s = ''
    for row in a:
        s += ''.join(row) + '\n'
    
    print(s)
",Only your latest submission will be checked,AC,Python3,2022-07-30 15:58:33.26404,10
363,TeamJin,1,1009,"import turtle
import random

turtle.screensize(80,24)
screen = turtle.Screen()

# Creates a night color background
screen.bgcolor(""midnight blue"")
screen.title(""My Movie"")
tpen = turtle.Turtle()
tpen.hideturtle()
t = 100000^1000000000
tpen.speed(t)

# Function to create stars
def star(x,y):
    tpen.penup()
    tpen.goto(x,y)
    tpen.pendown()
    turtle.colormode(255)
    tpen.pencolor(random.randint(0,255),
                  random.randint(0,255),
                  random.randint(0,255))
    
    for i in range(5):
        tpen.forward(10)
        tpen.right(144)

# Function to create moon
def moon():
    tpen.up()
    tpen.goto(200,140)
    tpen.down()
    tpen.color(""honeydew"")
    tpen.begin_fill()
    tpen.circle(80)
    tpen.end_fill()
 
# Function to create moolight effect   
def moonlight(x_moonlight,y_moonlight,c_light):
    tpen.up()
    tpen.goto(x_moonlight,y_moonlight)
    tpen.down()
    tpen.color(""silver"")
    tpen.circle(c_light)

# Function to create land
def land():
    tpen.penup()
    tpen.goto(-360,-200)
    tpen.pendown()
    tpen.color(""dark slate gray"")
    tpen.begin_fill()
    
    for i in range(4):
        tpen.forward(720)
        tpen.right(90)
    
    tpen.end_fill()

# Function to create Left Mountain
def left_mountain():
    tpen.penup()
    tpen.goto(-410,-201)
    tpen.pendown()
    tpen.color(""gray"")
    tpen.begin_fill()
    
    for i in range(3):
        tpen.forward(300)
        tpen.left(120)
    
    tpen.end_fill()

    # Snow cap on left Mountain
    tpen.penup()
    tpen.goto(-300, -10)
    tpen.pendown()
    tpen.color(""dark gray"")
    tpen.begin_fill()
    tpen.left(30)
    tpen.forward(25)
    tpen.right(60)
    tpen.forward(25)
    tpen.left(60)
    tpen.forward(32)
    tpen.left(90)
    tpen.forward(60)
    tpen.right(120)
    tpen.end_fill()

# Function to create Right Mountain
def right_mountain():
    tpen.penup()
    tpen.goto(100,-201)
    tpen.pendown()
    tpen.color(""gray"")
    tpen.begin_fill()
    
    for i in range(3):
        tpen.forward(300)
        tpen.left(120)
    
    tpen.end_fill()
    
    # Snow cap on right Mountain
    tpen.penup()
    tpen.goto(210, -10)
    tpen.pendown()
    tpen.color(""dark gray"")
    tpen.begin_fill()
    tpen.left(30)
    tpen.forward(25)
    tpen.right(60)
    tpen.forward(25)
    tpen.left(60)
    tpen.forward(32)
    tpen.left(90)
    tpen.forward(60)
    tpen.right(120)
    tpen.end_fill()

# Function to create Middle Mountain
def middle_mountain():
    tpen.penup()
    tpen.goto(-190,-201)
    tpen.pendown()
    tpen.color(""dim gray"")
    tpen.begin_fill()
    
    for i in range(3):
        tpen.forward(350)
        tpen.left(120)
    
    tpen.end_fill()
    
    # Snow cap on middle Mountain
    tpen.penup()
    tpen.goto(-55, 34)
    tpen.pendown()
    tpen.color(""gray"")
    tpen.begin_fill()
    tpen.left(30)
    tpen.forward(25)
    tpen.right(60)
    tpen.forward(25)
    tpen.left(60)
    tpen.forward(32)
    tpen.left(90)
    tpen.forward(60)
    tpen.right(120)
    tpen.end_fill()

# Function that create trees
def tree(x,y):
    tpen.penup()
    tpen.goto(x,y)
    tpen.pendown()
    tpen.color(""saddle brown"")
    tpen.left(90)
    tpen.forward(25)
    
    # Left Tree Branches
    tpen.left(60)
    tpen.forward(20)
    tpen.left(30)
    tpen.forward(15)
    # Tree Leaves
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.backward(15)
    tpen.right(60)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.right(30)
    
    # Middle Tree Branches
    tpen.penup()
    tpen.goto(x,y+25)
    tpen.pendown()
    tpen.forward(20)
    tpen.left(30)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.backward(15)
    tpen.right(60)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.left(30)
    
    # Right Tree Branches
    tpen.penup()
    tpen.goto(x,y+25)
    tpen.pendown()
    tpen.right(60)
    tpen.forward(20)
    tpen.left(30)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")
    tpen.backward(15)
    tpen.right(60)
    tpen.forward(15)
    # Leaves of the Tree
    tpen.pensize(3)
    tpen.color(""dark green"")
    tpen.begin_fill()
    tpen.circle(5)
    tpen.end_fill()
    tpen.pensize(1)
    tpen.color(""saddle brown"")

# Function that create my initials
def my_initials():
    
    # Create J
    tpen.penup()
    tpen.goto(290,-305)
    tpen.pendown()
    tpen.pensize(2)
    tpen.pencolor(""alice blue"")
    #--------------------------
    tpen.forward(10)
    tpen.right(90)
    tpen.forward(20)
    tpen.right(90)
    tpen.forward(7)
    tpen.right(90)
    tpen.forward(2)
    tpen.left(180)
    
    # Create L
    tpen.penup()
    tpen.goto(305,-305)
    tpen.pendown()
    #--------------------------
    tpen.forward(20)
    tpen.left(90)
    tpen.forward(10)
    
    # Create first 7
    tpen.penup()
    tpen.goto(317,-305)
    tpen.pendown()
    #--------------------------
    tpen.forward(10)
    tpen.right(110)
    tpen.forward(20)
    tpen.left(110)
    
    # Create second 7
    tpen.penup()
    tpen.goto(330,-305)
    tpen.pendown()
    #--------------------------
    tpen.forward(10)
    tpen.right(110)
    tpen.forward(20)
    

# ------- MAIN ------- #

####### Create stars in random positions #######
for i in range(10):
    
    # generating random integer values for x and y
    x = random.randint(-330, 300)
    y = random.randint(-50, 330)

    # Insert x and y into function to create stars
    star(x,y)


# Function that creates the Moon and moon light
moon()
x_moonlight = 200
y_moonlight = 140
c_light = 80

# For loop creates multiple moonlight rings
for i in range(30):
    y_moonlight -= 35
    c_light += 35
    moonlight(x_moonlight,y_moonlight,c_light)


# Function that creates Plain Land
land()

# Functions that will create the Left, Middle and Right Mountains
middle_mountain()
left_mountain()
right_mountain()

####### Create trees in random positions #######
for j in range(5):
    
    # generating random integer values for x and y
    x = random.randint(-310, 310)
    y = random.randint(-320, -210)

    # Insert x and y into function to create trees
    tree(x,y)

# Function that will create my initials
my_initials()

screen.exitonclick()",Only your latest submission will be checked,AC,Python3,2022-07-30 15:58:37.929074,10
364,NKSquared,1,1005,"
    
def merge(mainArr, arr, l, mid, r, m):
    n1 = mid - l + 1
    n2 = r - mid
 
    # create temp arrays
    L = [0] * (n1)
    R = [0] * (n2)
 
    # Copy data to temp arrays L[] and R[]
    for i in range(0, n1):
        L[i] = arr[l + i]
 
    for j in range(0, n2):
        R[j] = arr[mid + 1 + j]
 
    # Merge the temp arrays back into arr[l..r]
    i = 0     # Initial index of first subarray
    j = 0     # Initial index of second subarray
    k = l     # Initial index of merged subarray
    
    print(""q 1"")
    while i < n1 and j < n2:
        print(L[i], "" < "", R[j])
        x = input()
        if x == 1:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
 
    # Copy the remaining elements of L[], if there
    # are any
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1
 
    # Copy the remaining elements of R[], if there
    # are any
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1
 
# l is for left index and r is right index of the
# sub-array of arr to be sorted
 
 
def mergeSort(mainArr, arr, l, r, m):
    if l < r:
 
        # Same as (l+r)//2, but avoids overflow for
        # large l and h
        mid = l+(r-l)//2
 
        # Sort first and second halves
        mergeSort(mainArr, arr, l, mid, m)
        mergeSort(mainArr, arr, mid+1, r, m)
        merge(mainArr, arr, l, mid, r, m)
 

# def bubbleSort(arr, n):
#     # optimize code, so if the array is already sorted, it doesn't need
#     # to go through the entire process
#     swapped = False
#     # Traverse through all array elements
#     for i in range(n-1):
#         # range(n) also work but outer loop will
#         # repeat one time more than needed.
#         # Last i elements are already in place
#         for j in range(0, n-i-1):

#             # traverse the array from 0 to n-i-1
#             # Swap if the element found is greater
#             # than the next element
#             print(arr[j], "" > "", arr[j+1])
#             x = input()
#             if x == 1:
#                 swapped = True
#                 arr[j], arr[j + 1] = arr[j + 1], arr[j]
            
#         if not swapped:
#             # if we haven't needed to make a single swap, we
#             # can just exit the main loop.
#             return


#MAIN
nums = list(map(int, input().split()))

#n
n = nums[0]
#m
m = nums[1]
m = int(m/2)
if m > n:
    m = int(n/2)

indexArr = list(range(0, n))
mainArr = indexArr
print(indexArr)

mergeSort(mainArr, indexArr, 0, n-1, m)

# bubbleSort(indexArr, n)

print(indexArr)

# print(""a"", end = '')
# for i in range(n):
#     print(' ',end = '')
#     print(indexArr[i], end = '')","WA on case 0, test 0","",Python3,2022-07-30 15:58:52.362882,0
365,JavaScriptJatts,1,1008,"const { emitKeypressEvents } = require('readline');

// Enable keypress events
emitKeypressEvents(process.stdin);
process.stdin.setRawMode(true);
process.stdin.resume();

const RESET = '\x1b[0m'
const BRIGHT = '\x1b[1m'
const DIM = '\x1b[2m'
const UNDERSCORE = '\x1b[4m'
const BLINK = '\x1b[5m'
const REVERSE = '\x1b[7m'
const HIDDEN = '\x1b[8m'

const FG_BLACK = '\x1b[30m'
const FG_RED = '\x1b[31m'
const FG_GREEN = '\x1b[32m'
const FG_YELLOW = '\x1b[33m'
const FG_BLUE = '\x1b[34m'
const FG_MAGENTA = '\x1b[35m'
const FG_CYAN = '\x1b[36m'
const FG_WHITE = '\x1b[37m'

const BG_BLACK = '\x1b[40m'
const BG_RED = '\x1b[41m'
const BG_GREEN = '\x1b[42m'
const BG_YELLOW = '\x1b[43m'
const BG_BLUE = '\x1b[44m'
const BG_MAGENTA = '\x1b[45m'
const BG_CYAN = '\x1b[46m'
const BG_WHITE = '\x1b[47m'

const WIDTH = process.stdout.columns,
    HEIGHT = process.stdout.rows;
const FPS = 5;
const GRAVITY = 0.3,
    FRICTION = 0.8;

// Create a buffer of the given size.
const buffer = new Array(WIDTH)
for (let i = 0; i < WIDTH; i++) {
    buffer[i] = new Array(HEIGHT)
}

/**
 * Clears the buffer with the given character.
 * 
 * @param {any} x Character to override the buffer with.
 */
function clearBuffer(x = 0) {
    for (let i = 0; i < WIDTH; i++) {
        for (let j = 0; j < HEIGHT; j++) {
            buffer[i][j] = x;
        }
    }
}

/**
 * Draws the buffer to the screen.
 */
function drawBuffer() {
    let str = '';
    for (let y = 0; y < HEIGHT; y++) {
        for (let x = 0; x < WIDTH; x++) {
            str += isNaN(buffer[x][y]) ? buffer[x][y] : ' ';
        }
        str += '\n';
    }
    process.stdout.write(str + '\n')
}

/**
 * Clamps the given number between the given min and max.
 * 
 * @param {number} x X coordinate.
 * @param {number} min Minimum value.
 * @param {number} max Maximum value.
 * @returns 
 */
function clamp(x, min, max) {
    return Math.max(min, Math.min(x, max));
}

class Platform {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    draw() {
        buffer[this.x][this.y] = '█';
    }
}

class Finish {
    #color = BG_YELLOW;
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    update() {
        if (this.#color === BG_YELLOW) {
            this.#color = BG_RED;
        } else {
            this.#color = BG_YELLOW;
        }
    }
    draw() {
        buffer[this.x][this.y] = this.#color + '*' + RESET;
    }
}

let level = `
                                        *

                                    #######

                        #######                      #######

    ##################                                          ###################

                        #######                      #######

       ################            ################             ################

`
level += '#'.repeat(WIDTH)

const platforms = [];
var finish;
function loadLevel() {
    level.split('\n').forEach((line, y) => {
        line.split('').forEach((_, x) => {
            if (line[x] === '#')
                platforms.push(new Platform(x, HEIGHT - level.split('\n').length + y));
            else if (line[x] === '*')
                finish = new Finish(x, HEIGHT - level.split('\n').length + y);
        })
    })
}
function drawLevel() {
    platforms.forEach(p => p.draw());
}


class Character {
    jumping = true;
    constructor(x, y, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
    }
    update() {
        this.x = clamp(this.x += this.vx, 2, WIDTH - 3);
        this.y = clamp(this.y += this.vy, 2, HEIGHT - 3);
        this.vx *= FRICTION;
        this.vy += GRAVITY;
        platforms.forEach(p => {
            if (Math.floor(this.x) == p.x && Math.floor(this.y) == p.y - 2) {
                this.jumping = false;
                this.vy = 0;
            }
        })
        // Check if we've reached the finish
        if (Math.floor(this.x) == finish.x && Math.abs(Math.floor(this.y) - finish.y) < 2) {
            console.log('You win!');
            process.exit();
        }
    }
    draw() {
        buffer[Math.floor(this.x)][Math.floor(this.y)] = FG_RED + '█' + RESET;
        buffer[Math.floor(this.x) + 1][Math.floor(this.y)] = FG_RED + '█' + RESET;
        buffer[Math.floor(this.x)][Math.floor(this.y) + 1] = FG_BLUE + '█' + RESET;
        buffer[Math.floor(this.x) + 1][Math.floor(this.y) + 1] = FG_BLUE + '█' + RESET;
    }
}

loadLevel()
const character = new Character(3, HEIGHT - 3);

setInterval(function () {
    clearBuffer();
    drawLevel();
    finish.update();
    finish.draw();
    character.update();
    character.draw();
    drawBuffer();
}, 1000 / FPS);


process.stdin.on('keypress', function (_, key) {
    if (key && key.ctrl && key.name == 'c')
        process.exit();
    if ((key.name == 'w' || key.name == 'up' || key.name == 'space') && !character.jumping) {
        character.vy = -1;
        character.jumping = true;
    } else if ((key.name == 's' || key.name == 'down' || key.name == 'lshift') && character.jumping) {
        character.vy = 1;
    }
    if (key.name == 'a' || key.name == 'left') {
        character.vx = -1;
    } else if (key.name == 'd' || key.name == 'right') {
        character.vx = 1;
    }
});
",Only your latest submission will be checked,AC,NodeJS,2022-07-30 15:58:55.784069,10
366,datOvercommon,1,1007,"#include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

int main(){
    int plank;
    int query;
    cin >> plank; 
    cin >> query;
    char command;
    map<int, string> fences;
    for(int i = 0; i < plank; i++){
        fences[i] = ""white"";
    }
    vector<string> out;
    for(int i = 0; i < query; i++){
        cin >> command;
        if(command == 'q'){
            int n;
            cin >> n;
            out.push_back(fences[n]);
        }
        if(command == 'p'){
            int start;
            int end;
            string col;
            cin >> start;
            cin >> end;
            cin >> col;
            for(int i = start; i <= end; i++){
                fences[i] = col;
            }
        }
    }
    for(const auto i: out){
        cout << i << endl;
    }
}","WA on case 1, test 0",WA,C++17,2022-07-30 15:59:17.406425,0
367,untitled,1,1009,"#include <bits/stdc++.h>

using namespace std;
using namespace std::this_thread;     // sleep_for, sleep_until
using namespace std::chrono_literals; // ns, us, ms, s, h, etc.
using std::chrono::system_clock;


class drawable{
    public:
        drawable(vector<string> object){
            figure = object;
        }
        vector<string> getFigure(){
            return figure;
        }
    
    private:
        vector<string> figure{
            R""(        _____      )"",
            R""(    .-,;='';_),-.  )"",
            R""(     \_\(),()/_/   )"",
            R""(       (,___,)     )"",
            R""(      ,-/`~`\-,___ )"",
            R""(     / /).:.('--._))"",
            R""(    {_[ (_,_)      )"",
            R""(        | Y |      )"",
            R""(       /  |  \     )"",
            R""(       """""" """"""     )"",

        };
};
class Canvas{
    public:
        void clear(){
            mCurrentCanvas = mCleanCanvas;
            system(""clear"");
        }
        void addFigure(drawable t, int x, int y){
            vector<string> tt = t.getFigure();
            for(int i = 0; i < tt.size(); ++i){
                for(int j = 0; j < tt[i].length(); ++j){
                    mCurrentCanvas[y+i][x+j] = tt[i][j];
                }
            }
        }
        void draw(){
            for(auto str: mCurrentCanvas)
                cout << str << endl;
        }
    private:
        vector<string> mCleanCanvas{
R""(                            .                                            .)"",
R""(     *   .                  .              .        .   *               .)"",
R""(  .         .                     .       .           .      .          .)"",
R""(        o                             .                                .)"",
R""(         .              .                  .                          .)"",
R""(          0     .                                                      )"",
R""(                 .          .                 ,                ,    , )"",
R""( .          \          .                                            .  )"",
R""(      .      \   ,                                                     )"",
R""(   .          o     .                 .                   .            .)"",
R""(     .         \                 ,             .                .        )"",
R""(               #\##\#      .                              .        .      )"",
R""(             #  #O##\###                .                        .        )"",
R""(   .        #*#  #\##\###                       .                     ,    )"",
R""(        .   ##*#  #\##\##               .                     .            )"",
R""(      .      ##*#  #o##\#         .                             ,       .  )"",
R""(          .     *#  #\#     .                    .             .          ,)"",
R""(                      \          .                         .               )"",
R""(____^/\___^--____/\____O______________/\/\---/\___________---______________)"",
R""(   /\^   ^  ^    ^                  ^^ ^  '\ ^          ^       ---          )"",
R""(         --           -            --  -      -         ---  __       ^      )"",
R""(   --  __                      ___--  ^  ^                         --  __   )""
        };
        vector<string> mCurrentCanvas;

};



int main(){
    int cycle = 10, step = 1;
    int direction = 1;

    Canvas* myCanvas = new Canvas();

    vector<string> figure1{
            R""(        _____      )"",
            R""(    .-,;='';_),-.  )"",
            R""(     \_\(),()/_/   )"",
            R""(       (,___,)     )"",
            R""(      ,-/`~`\-,___ )"",
            R""(     / /).:.('--._))"",
            R""(    {_[ (_,_)      )"",
            R""(        | Y |      )"",
            R""(       /  |  \     )"",
            R""(       """""" """"""     )"",

    };
    vector<string> figure2{
            R""(        _____      )"",
            R""(    .-,;='';_),-.  )"",
            R""(     \_\(),()/_/   )"",
            R""(       (,___,)     )"",
            R""(      ,-/`~`\-,___ )"",
            R""(     / /).:.('--._))"",
            R""(    {_[ (_,_)      )"",
            R""(        | Y |      )"",
            R""(       /  |  \     )"",
            R""(       """""" """"""     )"",

    };
    drawable actor1(figure1), actor2(figure2);

    int curY1 = 5, curY2 = 10;
    int curX1 = 0, curX2 = 20;
    int cnt = 0;
    int direction1 = 1, direction2 = -1;
    for(int i = 0; i < 103; ++i){
        myCanvas->clear();
        myCanvas->addFigure(actor1, curX1, curY1);
        myCanvas->addFigure(actor2, curX2, curY2);
        curY1+= direction1*step;
        curY2+= direction2*step;
        ++cnt;
        myCanvas->draw();
        sleep_for(0.005s);
        if(cnt == 5){
            direction1 *= -1;
            direction2 *= -1;
            cnt = 0;
        }
    }

    delete myCanvas;

}",Only your latest submission will be checked,AC,C++17,2022-07-30 15:59:19.377107,10
368,NKSquared,1,1005,"
    
def merge(mainArr, arr, l, mid, r, m):
    n1 = mid - l + 1
    n2 = r - mid
 
    # create temp arrays
    L = [0] * (n1)
    R = [0] * (n2)
 
    # Copy data to temp arrays L[] and R[]
    for i in range(0, n1):
        L[i] = arr[l + i]
 
    for j in range(0, n2):
        R[j] = arr[mid + 1 + j]
 
    # Merge the temp arrays back into arr[l..r]
    i = 0     # Initial index of first subarray
    j = 0     # Initial index of second subarray
    k = l     # Initial index of merged subarray
    
    print(""q 1"")
    while i < n1 and j < n2:
        print(L[i], "" < "", R[j])
        x = input()
        if x == 1:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
 
    # Copy the remaining elements of L[], if there
    # are any
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1
 
    # Copy the remaining elements of R[], if there
    # are any
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1
 
# l is for left index and r is right index of the
# sub-array of arr to be sorted
 
 
def mergeSort(mainArr, arr, l, r, m):
    if l < r:
 
        # Same as (l+r)//2, but avoids overflow for
        # large l and h
        mid = l+(r-l)//2
 
        # Sort first and second halves
        mergeSort(mainArr, arr, l, mid, m)
        mergeSort(mainArr, arr, mid+1, r, m)
        merge(mainArr, arr, l, mid, r, m)
 

# def bubbleSort(arr, n):
#     # optimize code, so if the array is already sorted, it doesn't need
#     # to go through the entire process
#     swapped = False
#     # Traverse through all array elements
#     for i in range(n-1):
#         # range(n) also work but outer loop will
#         # repeat one time more than needed.
#         # Last i elements are already in place
#         for j in range(0, n-i-1):

#             # traverse the array from 0 to n-i-1
#             # Swap if the element found is greater
#             # than the next element
#             print(arr[j], "" > "", arr[j+1])
#             x = input()
#             if x == 1:
#                 swapped = True
#                 arr[j], arr[j + 1] = arr[j + 1], arr[j]
            
#         if not swapped:
#             # if we haven't needed to make a single swap, we
#             # can just exit the main loop.
#             return


#MAIN
nums = list(map(int, input().split()))

#n
n = nums[0]
#m
m = nums[1]
m = int(m/2)
if m > n:
    m = int(n/2)

indexArr = list(range(0, n))
mainArr = indexArr

mergeSort(mainArr, indexArr, 0, n-1, m)

# bubbleSort(indexArr, n)


print(""a"", end = '')
for i in range(n):
    print(' ',end = '')
    print(indexArr[i], end = '')","WA on case 0, test 0",WA,Python3,2022-07-30 15:59:30.278391,0
369,datOvercommon,1,1007,"plank1 = list(map(int, input().split()))
query = plank1[1]
plank = plank1[0]

fences = {}

for x in range(1, plank+1):
    fences.update({x: ""white""})

out = []
for x in range(query):
    command = list(input().split())
    if command[0] == 'q':
        n = command[1]
        out.append(fences.get(int(n)))
    if command[0] == 'p':
        start = int(command[1])
        end = int(command[2])
        col = command[3]
        for x in range(start, end+1):
            fences[x] = col

for x in out:
    print(x)
","Failed on case 2, test 0",TLE,Python3,2022-07-30 15:59:44.068775,20
370,datOvercommon,1,1007,"plank1 = list(map(int, input().split()))
query = plank1[1]
plank = plank1[0]

fences = {}

for x in range(1, plank+1):
    fences.update({x: ""white""})

out = []
for x in range(query):
    command = list(input().split())
    if command[0] == 'q':
        n = command[1]
        out.append(fences.get(int(n)))
    if command[0] == 'p':
        start = int(command[1])
        end = int(command[2])
        col = command[3]
        for x in range(start, end+1):
            fences[x] = col

for x in out:
    print(x)
","Error with code 1:
Traceback (most recent call last):
  File ""/code/Main.py"", line 1, in <module>
    plank1 = list(map(int, input().split()))
  File ""<string>"", line 1
    10 5
       ^
SyntaxError: unexpected EOF while parsing
",ERR,Python2,2022-07-30 15:59:52.531741,0
373,teamAverage,1,1005,"using namespace std;
#include <iostream>

int main() {
  int n, nRes, m, ind, trial = 1, temp, x = 0, comparison;
  int numOfComparison;
  bool sorted = 0,s1=0,s2=0;
  cin >> n;
  cin >> m;
  numOfComparison = n / 2;
  int indexes[n], indexesP[n], comparisonRes[numOfComparison];
  for (int i = 0; i < n; i++) {
    indexes[i] = i;
  }
  while (sorted == 0 / 2 && trial <= m) {
    s1=1;
    if (trial % 2 == 1) {
      x = 0;
      cout << ""q "" << numOfComparison << endl;
      for (int i = 0; i < numOfComparison; i++) {
        cout << indexes[x++];
        cout << "" < "" << indexes[x++] << endl;
      }
      for (int i = 0; i < numOfComparison; i++) {
        cin >> comparisonRes[i];
        comparison++;
        if (comparisonRes[i] == -1) {
          return;
        }
      }
      for (int i = 0; i < numOfComparison; i++) {
        if (comparisonRes[i] == 0) {
          s1=0;
          temp = indexes[i * 2];
          indexes[i * 2] = indexes[i * 2 + 1];
          indexes[i * 2 + 1] = temp;
        }
      }

    } else {
      s2=1;
      x = n;
      cout << ""q "" << numOfComparison << endl;
      for (int i = numOfComparison - 1; i >= 0; i--) {
        cout << indexes[x--];
        cout << "" > "" << indexes[x--] << endl;
      }
      for (int i = numOfComparison - 1; i >= 0; i--) {
        cin >> comparisonRes[i];
        comparison++;
        if (comparisonRes[i] == -1) {
          return;
        }
      }

      for (int i = numOfComparison - 1; i >= 0; i--) {
        if (comparisonRes[i] == 0) {
          s2=0;
          temp = indexes[n - i * 2 - 1];
          indexes[n - i * 2 - 1] = indexes[n - i * 2 - 2];
          indexes[n - i * 2 - 2] = temp;
        }
      }
    }
    if (s1==1&&s2==1){
      sorted =1;
    }
    trial++;
  }
  cout << ""a "";
  for (int i = 0; i < n; i++) {
    cout << indexes[i] << "" "";
  }
  cout << endl;
  cin >> nRes;
  return;
}",,judging,C++17,2022-07-30 16:01:01.703659,0
377,theKevin27,1,1009,"#include <iostream>
#include <string>
#include <vector>

struct ball {
  int x;
  int y;
  int vx;
  int vy;
  int colour;
};

bool clamp(int *input, int min, int max) {
  if (*input < min) {
    *input = min;
    return true;
  }
  if (*input > max) {
    *input = max;
    return true;
  }
  return false;
}

void update(std::vector<std::vector<int>> grid, std::vector<ball> balls) {
  for (int y = 0; y < 20; y++) {
    for (int x = 0; x < 84; x++) {
      grid[x][y] = 0;
    }
  }
  for (int i = 0; i < balls.size(); i++) {
    balls[i].x += balls[i].vx;
    balls[i].y += balls[i].vy;
    if (clamp(&balls[i].x, 0, 83)) {
      balls[i].vx *= -1;
      balls[i].vx /= 2;
    }
    if (clamp(&balls[i].y, 0, 19)) {
      balls[i].vy *= -1;
      balls[i].vy /= 2;
    }
    balls[i].vx += 1;
    grid[balls[i].x][balls[i].y] = balls[i].colour;
  }
}

void draw(std::vector<std::vector<int>> grid) {
  std::string palette =
      ""$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,\""`'. "";
  std::string screen[20];
  for (int y = 0; y < 20; y++) {
    std::string line;
    for (int x = 0; x < 84; x++) {
      line.push_back(palette.at(grid[x][y]));
    }
    screen[y] = line;
  }
  system(""cls"");
  for (int i = 0; i < 20; i++) {
    std::cout << screen[i] << std::endl;
  }
}

int main() {
  std::vector<ball> balls;
  for (int i = 0; i < 10; i++) {
    ball temp;
    temp.x = rand() % 80;
    temp.x = rand() % 24;
    temp.colour = (rand() % 53) + 1;
    temp.vx = (rand() % 5) - 2;
    temp.vy = 0;
    balls.push_back(temp);
  }
  std::vector<std::vector<int>> grid;
  while (true) {
    update(grid, balls);
    draw(grid);
  }
}
",,judging,C++17,2022-07-30 16:21:17.376715,0
378,theKevin27,1,1008,"#include <iostream>  //for input and output
#include <string>    //for strings :D
using namespace std; // because ive only 25 minutes left

// CHOOSE YOUR OWN ADVENTURE GAME//

int main() {
  // Interface information

  // START//
  cout << ""You wake up in a forest without any clue of where you are"" << endl;
  cout << ""You find yourself unable to look or move in more than 4 directions""
       << endl;

  // check to see if player is alive
  bool alive = 1;
  // PLAYER DIRECTIONS
  do {
    char MoL, m, l; // player inputs for movement and looking
    cout << ""Move (m) or look (l)?"" << endl;
    cin >> MoL; // move or look char
    // If player decides to move//
    if (MoL == 'm') {
      cout << ""Choose a direction to move, (n, e, s, w)"" << endl;
      cin >> m;
      if (m == 'n') {
        cout << ""You walk North"" << endl;
        cout << ""5 minutes left until submission"" << endl;
        alive = 0; // this kills the player and ends the game
      } else if (m == 'e') {
        cout << ""You walk East"" << endl;
        cout << ""You enter a nuclear warzone"" << endl;
        cout << ""You gaze upon the sky as ash falls"" << endl;
        cout << ""A bomb gets dropped down your gullet"" << endl;
        alive = 0;
      } else if (m == 's') {
        cout << ""You walk South"" << endl;
        cout << ""You enter a den of lions"" << endl;
        alive = 0;
      } else if (m == 'w') {
        cout << ""You walk West"" << endl;
        cout << ""You enter a black hole"" << endl;
        alive = 0;
      }
    }
      // If player decides to look//
      else if (MoL == 'l') {
        cout << ""Choose a direction to look, (n, e, s, w)"" << endl;
        cin >> l;
        if (l == 'n') {
          cout << ""You look North"" << endl;
          cout << ""You see a fiery inferno so bright that your eyes melt off""
               << endl;
          alive = 0;
        } else if (l == 'e') {
          cout << ""You look East"" << endl;
          cout << ""Your eyes are met by two small glowing dots"" << endl;
          cout << ""You have been mauled by a wolf"" << endl;
          alive = 0;
        } else if (l == 's') {
          cout << ""You look South"" << endl;
          cout << ""The screen turns black and you see yourself in the monitors ""
                  ""reflection""
               << endl;
          cout << ""You are reminded of how much of a loser you are before you ""
                  ""weep until you're fully dehydrated""
               << endl;
          alive = 0;

        } else if (l == 'w') {
          cout << ""You look West"" << endl;
          cout << ""I am running out of time so you just die thanks"" << endl;
          alive = 0;
        }
      }
    }
  while (alive);
  // death screen//
  if (alive == 0) {
    cout << ""You have died a tragic death and nobody will remember you"" << endl;
  }
}
",,judging,C++17,2022-07-30 16:35:08.257886,0
